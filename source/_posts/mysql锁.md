---
title: mysql锁
categories:
  - 数据库
date: 2020-02-21 19:02:57
tags: [数据库,mysql]
---

按照使用方式，锁分为：

- 悲观锁
- 乐观锁

## 乐观锁

概念就不细讲了，乐观锁和悲观锁的区别是乐观锁是假设在修改数据之前，所有的数据都不会有改变，只会在修改数据的时候才会去验证数据。乐观锁的实现mysql没有默认方法。可以自己手动实现，如增加一个字段version，每次去查询数据的时候把这个字段查出来，修改的时候检查这个字段是否和查出来的一致，如果一致，就修改，否则就抛出异常或者回滚。

引用参数考中的例子：

```sql
//step1: 查询出商品信息
select (quantity,version) from items where id=100;
//step2: 根据商品信息生成订单
insert into orders(id,item_id) values(null,100);
//step3: 修改商品的库存
update items set quantity=quantity-1,version=version+1 where id=100 and version=#{version};
```

**选择好作为乐观锁的字段，控制好乐观锁的粒度，能大大的提到系统的并发量**

## 悲观锁

悲观锁会假设所有操作都是有风险的，从开始到结束，不管是select语句还是修改，删除语句全部在锁里面

优点是完美保证了事务的ACID特性，缺点是锁的粒度过大，导致并发性能下降

mysql的实现方式（互斥锁）：

```sql
select ... for update
```

使用悲观锁需要将事务自动提交关闭。

即

```sql
set autocommit = false
```



这个操作会在执行select操作时就会对数据库进行加锁，直到该次事务提交，其他的事务才能够执行。

---

按照锁的级别，分为：

- 共享锁
- 排他锁（互斥锁）

- 意向锁
- 间隙锁

## 共享锁（share lock，S锁）

共享锁也被称为读锁

- 其他事务只能对已经加共享锁的资源再加共享锁，不能再加其他的锁。

- 获得了共享锁的事务只能够读数据，不能够写数据。

- 对加了共享锁的资源进行的修改删除操作会被阻塞，直到事务提交（锁释放）。

共享锁可以在多个事务中并发读取

mysql中的实现方式：

```sql
select * from sys_user lock in share mode;
```

加上之后`lock in share mode`后会对查询结果中的每行都加上共享锁

## 排他锁（exclusive lock，X锁）

排他锁也被称为写锁，顾名思义，资源被一个事务加锁后，不能被其他事务访问，修改，直到再次这个事务提交（锁释放）

- 其他事务不能对已经加排他锁的资源再加锁，要获取锁只能等到事务提交（锁释放）

- 获取排他锁的事务可以对资源进行读写数据

mysql中的实现方式：

```sql
select ... for update
```

## 意向锁

意向锁是InnoDB自动加的，不需要用户干预 ，意向锁也是一种表锁。

意向锁又分为意向共享锁（IS），意向排他锁（IX）

> 意向锁的作用：
> 意向锁是在添加行锁之前添加。当再向一个表添加表级X锁的时候：
> 如果没有意向锁的话，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突。
> 如果有了意向锁，只需要判断该意向锁与即将添加的表级锁是否兼容即可。因为意向锁的存在代表了，有行级锁的存在或者即将有行级锁的存在。因而无需遍历整个表，即可获取结果。
>
> 引用官方的话来说就是：意向锁只会阻塞全表锁，不会阻塞没有交集的行锁。目的是为了提高读写性能。 

## 间隙锁

## 表锁和行锁

在mysql 的 InnoDB引擎支持行锁，与Oracle不同，mysql的行锁是通过索引加载的，即是行锁是加在索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描，行锁则无法实现，取而代之的是表锁。

---
参考：

 https://www.jianshu.com/p/ed896335b3b4 

 https://www.jianshu.com/p/904f52bde904 

行锁和表锁：

 https://blog.csdn.net/u014453898/article/details/56068841 

 https://www.jianshu.com/p/fb06e23e3332 