<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

	<!-- generator="WordPress/5.1.4" created="2020-01-16 03:46" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>Me</title>
	<link>https://blog.easysc.cn</link>
	<description></description>
	<pubDate>Thu, 16 Jan 2020 03:46:55 +0000</pubDate>
	<language>zh-CN</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>https://blog.easysc.cn</wp:base_site_url>
	<wp:base_blog_url>https://blog.easysc.cn</wp:base_blog_url>

		<wp:author><wp:author_id>1</wp:author_id><wp:author_login><![CDATA[cononyc]]></wp:author_login><wp:author_email><![CDATA[cononyc@163.com]]></wp:author_email><wp:author_display_name><![CDATA[cononyc]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>

		<wp:category>
		<wp:term_id>2</wp:term_id>
		<wp:category_nicename><![CDATA[docker]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[docker]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>3</wp:term_id>
		<wp:category_nicename><![CDATA[elasticsearch]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[elasticsearch]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>4</wp:term_id>
		<wp:category_nicename><![CDATA[front]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[front]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>5</wp:term_id>
		<wp:category_nicename><![CDATA[java]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[java]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>6</wp:term_id>
		<wp:category_nicename><![CDATA[linux]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[linux]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>7</wp:term_id>
		<wp:category_nicename><![CDATA[mysql]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[mysql]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>8</wp:term_id>
		<wp:category_nicename><![CDATA[python]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[python]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>9</wp:term_id>
		<wp:category_nicename><![CDATA[redis]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[redis]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>10</wp:term_id>
		<wp:category_nicename><![CDATA[spring]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[spring]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>11</wp:term_id>
		<wp:category_nicename><![CDATA[spring-boot]]></wp:category_nicename>
		<wp:category_parent><![CDATA[spring]]></wp:category_parent>
		<wp:cat_name><![CDATA[spring boot]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>12</wp:term_id>
		<wp:category_nicename><![CDATA[spring-cloud]]></wp:category_nicename>
		<wp:category_parent><![CDATA[spring]]></wp:category_parent>
		<wp:cat_name><![CDATA[spring cloud]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>13</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%95%b0%e6%8d%ae%e5%ba%93]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[数据库]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>1</wp:term_id>
		<wp:category_nicename><![CDATA[uncategorized]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[未分类]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>14</wp:term_id>
		<wp:category_nicename><![CDATA[various]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[杂]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>15</wp:term_id>
		<wp:category_nicename><![CDATA[thread]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[线程]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>16</wp:term_id>
		<wp:category_nicename><![CDATA[about-config]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[配置相关]]></wp:cat_name>
	</wp:category>
			<wp:tag>
		<wp:term_id>17</wp:term_id>
		<wp:tag_slug><![CDATA[css]]></wp:tag_slug>
		<wp:tag_name><![CDATA[css]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>18</wp:term_id>
		<wp:tag_slug><![CDATA[docker]]></wp:tag_slug>
		<wp:tag_name><![CDATA[docker]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>19</wp:term_id>
		<wp:tag_slug><![CDATA[es]]></wp:tag_slug>
		<wp:tag_name><![CDATA[es]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>20</wp:term_id>
		<wp:tag_slug><![CDATA[es6]]></wp:tag_slug>
		<wp:tag_name><![CDATA[es6]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>21</wp:term_id>
		<wp:tag_slug><![CDATA[front]]></wp:tag_slug>
		<wp:tag_name><![CDATA[front]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>22</wp:term_id>
		<wp:tag_slug><![CDATA[html]]></wp:tag_slug>
		<wp:tag_name><![CDATA[html]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>23</wp:term_id>
		<wp:tag_slug><![CDATA[java]]></wp:tag_slug>
		<wp:tag_name><![CDATA[java]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>24</wp:term_id>
		<wp:tag_slug><![CDATA[linux]]></wp:tag_slug>
		<wp:tag_name><![CDATA[linux]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>25</wp:term_id>
		<wp:tag_slug><![CDATA[mysql]]></wp:tag_slug>
		<wp:tag_name><![CDATA[mysql]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>26</wp:term_id>
		<wp:tag_slug><![CDATA[python]]></wp:tag_slug>
		<wp:tag_name><![CDATA[python]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>27</wp:term_id>
		<wp:tag_slug><![CDATA[redis]]></wp:tag_slug>
		<wp:tag_name><![CDATA[redis]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>28</wp:term_id>
		<wp:tag_slug><![CDATA[spring]]></wp:tag_slug>
		<wp:tag_name><![CDATA[spring]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>29</wp:term_id>
		<wp:tag_slug><![CDATA[tomcat]]></wp:tag_slug>
		<wp:tag_name><![CDATA[tomcat]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>30</wp:term_id>
		<wp:tag_slug><![CDATA[vue]]></wp:tag_slug>
		<wp:tag_name><![CDATA[vue]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>31</wp:term_id>
		<wp:tag_slug><![CDATA[webpack]]></wp:tag_slug>
		<wp:tag_name><![CDATA[webpack]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>32</wp:term_id>
		<wp:tag_slug><![CDATA[xml]]></wp:tag_slug>
		<wp:tag_name><![CDATA[xml]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>33</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%8f%8d%e5%b0%84]]></wp:tag_slug>
		<wp:tag_name><![CDATA[反射]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>34</wp:term_id>
		<wp:tag_slug><![CDATA[sustain]]></wp:tag_slug>
		<wp:tag_name><![CDATA[持续交付]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>35</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%95%b0%e6%8d%ae%e5%ba%93]]></wp:tag_slug>
		<wp:tag_name><![CDATA[数据库]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>36</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%9d%82]]></wp:tag_slug>
		<wp:tag_name><![CDATA[杂]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>37</wp:term_id>
		<wp:tag_slug><![CDATA[pool]]></wp:tag_slug>
		<wp:tag_name><![CDATA[池]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>38</wp:term_id>
		<wp:tag_slug><![CDATA[about-config]]></wp:tag_slug>
		<wp:tag_name><![CDATA[配置相关]]></wp:tag_name>
	</wp:tag>
			<wp:term>
		<wp:term_id><![CDATA[17]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[css]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[css]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[2]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[docker]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[docker]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[18]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[docker]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[docker]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[3]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[elasticsearch]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[elasticsearch]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[19]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[es]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[es]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[20]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[es6]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[es6]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[4]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[front]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[front]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[21]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[front]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[front]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[22]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[html]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[html]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[5]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[java]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[java]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[23]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[java]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[java]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[6]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[linux]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[linux]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[24]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[linux]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[linux]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[7]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[mysql]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[mysql]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[25]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[mysql]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[mysql]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[8]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[python]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[python]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[26]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[python]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[python]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[9]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[redis]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[redis]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[27]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[redis]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[redis]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[10]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[spring]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[spring]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[28]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[spring]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[spring]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[11]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[spring-boot]]></wp:term_slug>
		<wp:term_parent><![CDATA[spring]]></wp:term_parent>
		<wp:term_name><![CDATA[spring boot]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[12]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[spring-cloud]]></wp:term_slug>
		<wp:term_parent><![CDATA[spring]]></wp:term_parent>
		<wp:term_name><![CDATA[spring cloud]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[29]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[tomcat]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[tomcat]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[30]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[vue]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[vue]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[31]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[webpack]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[webpack]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[32]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[xml]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[xml]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[33]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%8f%8d%e5%b0%84]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[反射]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[34]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[sustain]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[持续交付]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[13]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b0%e6%8d%ae%e5%ba%93]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[数据库]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[35]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b0%e6%8d%ae%e5%ba%93]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[数据库]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[1]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[uncategorized]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[未分类]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[14]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[various]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[杂]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[36]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%9d%82]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[杂]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[37]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[pool]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[池]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[15]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[thread]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[线程]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[16]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[about-config]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[配置相关]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[38]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[about-config]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[配置相关]]></wp:term_name>
	</wp:term>
		
	<generator>https://wordpress.org/?v=5.1.4</generator>

		<item>
		<title>
				隐私政策		</title>
		<link>https://blog.easysc.cn/?page_id=3</link>
		<pubDate>Mon, 01 Apr 2019 08:35:39 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://blog.easysc.cn/?page_id=3</guid>
		<description></description>
		<content:encoded>
				<![CDATA[<!-- wp:heading --><h2>我们是谁</h2><!-- /wp:heading --><!-- wp:paragraph --><p>我们的站点地址是：http://blog.easysc.cn。</p><!-- /wp:paragraph --><!-- wp:heading --><h2>我们收集何种及为何收集个人数据</h2><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>评论</h3><!-- /wp:heading --><!-- wp:paragraph --><p>当访客留下评论时，我们会收集评论表单所显示的数据，和访客的IP地址及浏览器的user agent字符串来帮助检查垃圾评论。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>由您的电子邮件地址所生成的匿名化字符串（又称为哈希）可能会被提供给Gravatar服务确认您是否有使用该服务。Gravatar服务的隐私政策在此：https://automattic.com/privacy/。在您的评论获批准后，您的资料图片将在您的评论旁公开展示。</p><!-- /wp:paragraph --><!-- wp:heading {"level":3} --><h3>媒体</h3><!-- /wp:heading --><!-- wp:paragraph --><p>如果您向此网站上传图片，您应当避免上传那些有嵌入地理位置信息（EXIF GPS）的图片。此网站的访客将可以下载并提取此网站的图片中的位置信息。</p><!-- /wp:paragraph --><!-- wp:heading {"level":3} --><h3>联系表单</h3><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>Cookies</h3><!-- /wp:heading --><!-- wp:paragraph --><p>如果您在我们的站点上留下评论，您可以选择用cookies保存您的姓名、电子邮件地址和网站。这是通过让您可以不用在评论时再次填写相关内容而向您提供方便。这些cookies会保留一年。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>如果您有此站点的账户并且您登录了此站点，我们会设置一个临时的cookie来确认您的浏览器是否接受cookies。此cookie不包含个人数据且会在您关闭浏览器时被丢弃。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>当您登录时，我们也会设置多个cookies来保存您的登录信息及屏幕显示选项。登录cookies会保留两天，而屏幕显示选项cookies会保留一年。如果您选择了“记住我”，您的登录状态则会保留两周。如果您登出您的账户，用于登录的cookies将会被移除。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>如果您编辑或发布文章，我们会在您的浏览器中保存一个额外的cookie。这个cookie不包含个人数据而只记录了您刚才编辑的文章的ID。这个cookie会保留一天。</p><!-- /wp:paragraph --><!-- wp:heading {"level":3} --><h3>其他站点的嵌入内容</h3><!-- /wp:heading --><!-- wp:paragraph --><p>此站点上的文章可能会包含嵌入的内容（如视频、图像、文章等）。来自其他站点的嵌入内容的行为和您直接访问这些其他站点没有区别。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>这些站点可能会收集关于您的数据、使用cookies、嵌入额外的第三方跟踪程序及监视您与这些嵌入内容的交互，包括在您有这些站点的账户并登录了这些站点时，跟踪您与嵌入内容的交互。</p><!-- /wp:paragraph --><!-- wp:heading {"level":3} --><h3>统计</h3><!-- /wp:heading --><!-- wp:heading --><h2>我们与谁共享您的信息</h2><!-- /wp:heading --><!-- wp:heading --><h2>我们保留多久您的信息</h2><!-- /wp:heading --><!-- wp:paragraph --><p>如果您留下评论，评论和其元数据将被无限期保存。我们这样做以便能识别并自动批准任何后续评论，而不用将这些后续评论加入待审队列。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>对于本网站的注册用户，我们也会保存用户在个人资料中提供的个人信息。所有用户可以在任何时候查看、编辑或删除他们的个人信息（除了不能变更用户名外）、站点管理员也可以查看及编辑那些信息。</p><!-- /wp:paragraph --><!-- wp:heading --><h2>您对您的信息有什么权利</h2><!-- /wp:heading --><!-- wp:paragraph --><p>如果您有此站点的账户，或曾经留下评论，您可以请求我们提供我们所拥有的您的个人数据的导出文件，这也包括了所有您提供给我们的数据。您也可以要求我们抹除所有关于您的个人数据。这不包括我们因管理、法规或安全需要而必须保留的数据。</p><!-- /wp:paragraph --><!-- wp:heading --><h2>我们将您的信息发送到哪</h2><!-- /wp:heading --><!-- wp:paragraph --><p>访客评论可能会被自动垃圾评论监测服务检查。</p><!-- /wp:paragraph --><!-- wp:heading --><h2>您的联系信息</h2><!-- /wp:heading --><!-- wp:heading --><h2>其他信息</h2><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>我们如何保护您的数据</h3><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>我们有何种数据泄露处理流程</h3><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>我们从哪些第三方接收数据</h3><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>我们通过用户数据进行何种自动决策及/或归纳</h3><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>行业监管披露要求</h3><!-- /wp:heading -->]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>3</wp:post_id>
		<wp:post_date><![CDATA[2019-04-01 16:35:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-01 08:35:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[privacy-policy]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
														<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
		<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				隐私政策		</title>
		<link>https://blog.easysc.cn/?page_id=13</link>
		<pubDate>Mon, 14 Jan 2019 01:06:03 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://120.77.81.112:9000/?page_id=3</guid>
		<description></description>
		<content:encoded>
				<![CDATA[<!-- wp:heading --><h2>我们是谁</h2><!-- /wp:heading --><!-- wp:paragraph --><p>我们的站点地址是：http://120.77.81.112:9000。</p><!-- /wp:paragraph --><!-- wp:heading --><h2>我们收集何种及为何收集个人数据</h2><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>评论</h3><!-- /wp:heading --><!-- wp:paragraph --><p>当访客留下评论时，我们会收集评论表单所显示的数据，和访客的IP地址及浏览器的user agent字符串来帮助检查垃圾评论。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>由您的电子邮件地址所生成的匿名化字符串（又称为哈希）可能会被提供给Gravatar服务确认您是否有使用该服务。Gravatar服务的隐私政策在此：https://automattic.com/privacy/。在您的评论获批准后，您的资料图片将在您的评论旁公开展示。</p><!-- /wp:paragraph --><!-- wp:heading {"level":3} --><h3>媒体</h3><!-- /wp:heading --><!-- wp:paragraph --><p>如果您向此网站上传图片，您应当避免上传那些有嵌入地理位置信息（EXIF GPS）的图片。此网站的访客将可以下载并提取此网站的图片中的位置信息。</p><!-- /wp:paragraph --><!-- wp:heading {"level":3} --><h3>联系表单</h3><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>Cookies</h3><!-- /wp:heading --><!-- wp:paragraph --><p>如果您在我们的站点上留下评论，您可以选择用cookies保存您的姓名、电子邮件地址和网站。这是通过让您可以不用在评论时再次填写相关内容而向您提供方便。这些cookies会保留一年。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>如果您有此站点的账户并且您登录了此站点，我们会设置一个临时的cookie来确认您的浏览器是否接受cookies。此cookie不包含个人数据且会在您关闭浏览器时被丢弃。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>当您登录时，我们也会设置多个cookies来保存您的登录信息及屏幕显示选项。登录cookies会保留两天，而屏幕显示选项cookies会保留一年。如果您选择了“记住我”，您的登录状态则会保留两周。如果您登出您的账户，用于登录的cookies将会被移除。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>如果您编辑或发布文章，我们会在您的浏览器中保存一个额外的cookie。这个cookie不包含个人数据而只记录了您刚才编辑的文章的ID。这个cookie会保留一天。</p><!-- /wp:paragraph --><!-- wp:heading {"level":3} --><h3>其他站点的嵌入内容</h3><!-- /wp:heading --><!-- wp:paragraph --><p>此站点上的文章可能会包含嵌入的内容（如视频、图像、文章等）。来自其他站点的嵌入内容的行为和您直接访问这些其他站点没有区别。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>这些站点可能会收集关于您的数据、使用cookies、嵌入额外的第三方跟踪程序及监视您与这些嵌入内容的交互，包括在您有这些站点的账户并登录了这些站点时，跟踪您与嵌入内容的交互。</p><!-- /wp:paragraph --><!-- wp:heading {"level":3} --><h3>统计</h3><!-- /wp:heading --><!-- wp:heading --><h2>我们与谁共享您的信息</h2><!-- /wp:heading --><!-- wp:heading --><h2>我们保留多久您的信息</h2><!-- /wp:heading --><!-- wp:paragraph --><p>如果您留下评论，评论和其元数据将被无限期保存。我们这样做以便能识别并自动批准任何后续评论，而不用将这些后续评论加入待审队列。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>对于本网站的注册用户，我们也会保存用户在个人资料中提供的个人信息。所有用户可以在任何时候查看、编辑或删除他们的个人信息（除了不能变更用户名外）、站点管理员也可以查看及编辑那些信息。</p><!-- /wp:paragraph --><!-- wp:heading --><h2>您对您的信息有什么权利</h2><!-- /wp:heading --><!-- wp:paragraph --><p>如果您有此站点的账户，或曾经留下评论，您可以请求我们提供我们所拥有的您的个人数据的导出文件，这也包括了所有您提供给我们的数据。您也可以要求我们抹除所有关于您的个人数据。这不包括我们因管理、法规或安全需要而必须保留的数据。</p><!-- /wp:paragraph --><!-- wp:heading --><h2>我们将您的信息发送到哪</h2><!-- /wp:heading --><!-- wp:paragraph --><p>访客评论可能会被自动垃圾评论监测服务检查。</p><!-- /wp:paragraph --><!-- wp:heading --><h2>您的联系信息</h2><!-- /wp:heading --><!-- wp:heading --><h2>其他信息</h2><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>我们如何保护您的数据</h3><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>我们有何种数据泄露处理流程</h3><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>我们从哪些第三方接收数据</h3><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>我们通过用户数据进行何种自动决策及/或归纳</h3><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>行业监管披露要求</h3><!-- /wp:heading -->]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>13</wp:post_id>
		<wp:post_date><![CDATA[2019-01-14 09:06:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-01-14 01:06:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[privacy-policy]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
														<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
		<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				在Linux下安装文件		</title>
		<link>https://blog.easysc.cn/?p=14</link>
		<pubDate>Thu, 18 Oct 2018 08:15:21 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=8</guid>
		<description></description>
		<content:encoded>
				<![CDATA[<h2>安装Java</h2>

<h3>通过压缩文件安装</h3>

下载Linux下的Java安装包<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">Java</a>
解压缩

<pre><code>tar -xzvf jre-8u144-linux-x64.tar.gz
</code></pre>

这种方式解压出来的文件直接就可以使用，只需要配置一下环境变量，在下面统一

<h3>通过rpm安装</h3>

下载rpm文件
安装

<pre><code>rpm -ivh jre-8u144-linux-x64.rpm
</code></pre>

这种安装方式，安装之后默认是在<code>/usr/java</code>目录下的

<h3>设置环境变量</h3>

<pre><code>vi /etc/profile
</code></pre>

在末尾加上下面的内容

<pre><code>#Java
JAVA_HOME=/usr/local/soft/jdk1.8.0_144
CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
PATH=$JAVA_HOME/bin:$PATH
export JAVA_HOME CLASSPATH PATH
</code></pre>

这里的<code>JAVA_HOME</code>对应的是Java的安装目录
让配置马上生效

<pre><code>source /etc/profile
</code></pre>

验证：

<pre><code>java -version
</code></pre>

<hr />

<h2>安装Tomcat</h2>

下载Tomcat在Linux的安装包<a href="http://tomcat.apache.org/">Tomcat</a>
放到<code>/usr/local/src</code>下，然后解压缩

<pre><code>tar -xzvf redis-3.2.9.tar.gz
</code></pre>

解压完之后就可以通过<code>bin/startup.sh</code>启动了，通过<code>bin/shutdown.sh</code>关闭

<hr />

<h2>安装MySQL</h2>

<h3>安装前准备</h3>

这里以安装MySQL5.6为例
访问<a href="https://dev.mysql.com/downloads/repo/yum/">MySQL官网</a>下载yum版本的MySQL存储库，因为这里用的是Centos，所以下载的是红帽企业版
参照<a href="https://dev.mysql.com/doc/mysql-yum-repo-quick-guide/en/">快速安装指南</a>
将下载下来的存储库<code>mysql57-community-release-el6-11.noarch.rpm</code>上传到服务器之后，执行下列命令

<pre><code>sudo rpm -Uvh mysql57-community-release-el6-11.noarch.rpm
</code></pre>

执行了上面的命令之后就可以执行下面的命令查看可以安装的MySQL版本信息

<pre><code>yum repolist all | grep mysql
</code></pre>

得到结果如下：

<pre><code>mysql-cluster-7.5-community        MySQL Cluster 7.5 Community   disabled
mysql-cluster-7.5-community-source MySQL Cluster 7.5 Community - disabled
mysql-cluster-7.6-community        MySQL Cluster 7.6 Community   disabled
mysql-cluster-7.6-community-source MySQL Cluster 7.6 Community - disabled
mysql-connectors-community         MySQL Connectors Community    enabled:     42
mysql-connectors-community-source  MySQL Connectors Community -  disabled
mysql-tools-community              MySQL Tools Community         enabled:     51
mysql-tools-community-source       MySQL Tools Community - Sourc disabled
mysql-tools-preview                MySQL Tools Preview           disabled
mysql-tools-preview-source         MySQL Tools Preview - Source  disabled
mysql55-community                  MySQL 5.5 Community Server    disabled
mysql55-community-source           MySQL 5.5 Community Server -  disabled
mysql56-community                  MySQL 5.6 Community Server    disabled
mysql56-community-source           MySQL 5.6 Community Server -  disabled
mysql57-community                  MySQL 5.7 Community Server    enabled:    201
mysql57-community-source           MySQL 5.7 Community Server -  disabled
mysql80-community                  MySQL 8.0 Community Server    disabled
mysql80-community-source           MySQL 8.0 Community Server -  disabled
</code></pre>

可以看到这里后面为enabled的是可以安装的，因为下载的是5.7的仓库，所以默认是5.7为可以安装的，如果要改为5.6可以使用下面的方法

<h3>更改MySQL安装版本</h3>

<h4>使用yum工具类更改安装版本</h4>

执行下面的方法可以将5.7变为5.6，以此类推

<pre><code>sudo yum-config-manager --disable mysql57-community
sudo yum-config-manager --enable mysql56-community
</code></pre>

如果提示<code>sudo: yum-config-manager: command not found</code>说明没有安装yum的工具包，先执行下面的命令：

<pre><code>yum -y install yum-utils
</code></pre>

安装工具包之后执行上面的命令就可以了

<h4>手动编辑文件更改版本</h4>

还可以通过手动编辑<code>/etc/yum.repos.d/mysql-community.repo</code>文件来选择一个系列

<pre><code class="line-numbers">[mysql57-community]
name=MySQL 5.7 Community Server
baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/6/$basearch/
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql
</code></pre>

找到要配置的子链接条目，然后编辑该enabled选项。指定enabled=0禁用子广告素材，或 enabled=1启用子广告素材。例如，要安装MySQL 5.6，请确保您具有 enabled=0上述用于MySQL5.7的子功能表项，并具有enabled=15.6系列的条目
验证是否更改成功

<pre><code>yum repolist enabled | grep mysql
</code></pre>

看到要更改的版本变为<code>enabled</code>,5.7变为<code>disabled</code>就表示更改成功
###安装MySQL
执行下列命令就可以安装了

<pre><code>sudo yum install mysql-community-server
</code></pre>

通过<code>rpm -qa |grep mysql</code>可以看到下面的东西已经在系统中了

<pre><code>mysql-community-libs-5.6.37-2.el6.x86_64
mysql-community-libs-compat-5.6.37-2.el6.x86_64
mysql57-community-release-el6-11.noarch
mysql-community-common-5.6.37-2.el6.x86_64
mysql-community-client-5.6.37-2.el6.x86_64
mysql-community-server-5.6.37-2.el6.x86_64
</code></pre>

<h3>启动MySQL服务</h3>

启动/关闭/重启/检查状态

<pre><code>sudo service mysqld start/stop/restart/status
</code></pre>

也可以不加sudo，如果是root用户的话
一开始的MySQL是没有密码的，可以直接使用<code>mysql -uroot -p</code>直接登录
针对5.6版本可以使用下面的命令来更改一些比较敏感的内容如root用户密码

<pre><code>mysql_secure_installation
</code></pre>

也可以参考这个<a href="http://www.cnblogs.com/liufei88866/p/5619215.html">网址</a>设置root用户的密码
如果是5.7会生成一个初始密码，可以通过下面的命令查看

<pre><code>sudo grep 'temporary password' /var/log/mysqld.log
</code></pre>

<hr />

<h2>开放端口</h2>

<h3>开放防火墙端口</h3>

这里的开放端口是更改防火墙设置，让linux的对应端口可以通过外网访问
比如Tomcat的8080端口，如果不开放端口，就只能通过内网访问

<pre><code>vi /etc/sysconfig/iptables
</code></pre>

可以看到只开放了22端口

<pre><code>-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
</code></pre>

遵照这个内容，在下面加上

<pre><code>-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT
</code></pre>

开放8080(Tomcat)，3306(MySQL)，80端口
修改之后重启防护墙

<pre><code>/etc/init.d/iptables restart
</code></pre>

查看端口是否开放

<pre><code>/sbin/iptables -L -n
</code></pre>

云服务器开放端口的方式不同，参照对应的云服务器

<h3>开放MySQL的访问权限</h3>

开启了外网访问权限之后，MySQL还是不能访问，因为MySQL自身有一个访问权限(默认为127.0.0.1即本地)
参照<a href="http://www.cnblogs.com/fslnet/p/3143344.html">MySQL授权</a>
先登录MySQL
可以用下面的方法将所有的权限都赋给root

<pre><code>grant all privileges on  *.*  to root@'%'  identified by 'xxxx';
</code></pre>

这里的xxxx是用户的密码
执行完之后刷新权限

<pre><code>flush privileges;
</code></pre>

就可以使用外网连接数据库了

<h2>安装Nginx</h2>

下载nginx的<a href="http://nginx.org/en/download.html">安装包</a>
解压缩

<pre><code>tar -zxvf nginx-1.14.0
</code></pre>

安装必备的组件

<pre><code>yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel
</code></pre>

配置要安装的位置，安装的组件

<pre><code>./configure --prefix=/usr/local/nginx \
--with-http_ssl_module \
--with-http_realip_module \
--with-http_gunzip_module \
--with-http_gzip_static_module \
--with-http_secure_link_module \
--with-http_v2_module \
--with-http_stub_status_module \
--with-http_sub_module \
--with-http_ssl_module
</code></pre>

然后编译

<pre><code>make
</code></pre>

安装

<pre><code>make install
</code></pre>

<h3>错误</h3>

如果遇到

<pre><code>make: *** No rule to make target `build', needed by `default'.  Stop.
</code></pre>

一般是因为上面的必备组件没有安装，执行<code>./configure</code>导致的，安装之后重新<code>./configure</code>再执行后面的操作就可以了

<h2>安装Nodejs(centos)</h2>

到nodejs<a href="https://nodejs.org/en/download/">官网</a>下载linux源码
上传到服务器
解压缩

<pre><code>tar -zxvf node-v8.11.4.tar.gz
</code></pre>

切换到解压后的文件夹配置路径

<pre><code>./configure --prefix=/usr/local/nodejs_v8.11.4
</code></pre>

编译安装

<pre><code>make &amp; make install
</code></pre>

配置环境变量

<pre><code>vi /etc/profile
</code></pre>

加入

<pre><code>export NODE_HOME=/usr/local/nodejs_v8.11.4
export PATH=$NODE_HOME/bin:$PATH
</code></pre>

更新环境变量

<pre><code>source /etc/profile
</code></pre>

验证是否成功

<pre><code>node -v
</code></pre>

<h3>将源替换为<a href="http://npm.taobao.org/">淘宝源</a></h3>

<pre><code>npm config set registry https://registry.npm.taobao.org
</code></pre>

使用淘宝定制的cnpm

<pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>14</wp:post_id>
		<wp:post_date><![CDATA[2018-10-18 16:15:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-18 08:15:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[linux%e4%b8%8b%e5%ae%89%e8%a3%85%e7%a8%8b%e5%ba%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="linux"><![CDATA[linux]]></category>
		<category domain="post_tag" nicename="linux"><![CDATA[linux]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				blogi		</title>
		<link>https://blog.easysc.cn/?p=21</link>
		<pubDate>Thu, 18 Oct 2018 08:56:27 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/2018/10/18/blogi/</guid>
		<description></description>
		<content:encoded>
				<![CDATA[
/**:not([class*="icon"]):not(i) {
font-family: Segoe UI,Monaco,"Microsoft Yahei" !important;
}*/
*:not([class*="icon"]):not(i) {
font-family: Menlo, "Ubuntu Mono", Consolas, "Courier New", "Microsoft Yahei", "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif,"Microsoft Yahei" !important;
}
.article-content .aplayer{line-height:normal}
.aplayer .aplayer-pic .aplayer-play .aplayer-icon-play{top:0px;left:3px}]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>21</wp:post_id>
		<wp:post_date><![CDATA[2018-10-18 16:56:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-18 08:56:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[blogi]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[custom_css]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
														</item>
					<item>
		<title>
				说明		</title>
		<link>https://blog.easysc.cn/?page_id=26</link>
		<pubDate>Thu, 18 Oct 2018 09:39:06 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?page_id=26</guid>
		<description></description>
		<content:encoded>
				<![CDATA[<h1>这只是用来说明的</h1>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>26</wp:post_id>
		<wp:post_date><![CDATA[2018-10-18 17:39:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-18 09:39:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[gdfagsd]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
														<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_customize_changeset_uuid]]></wp:meta_key>
		<wp:meta_value><![CDATA[c94d6570-43a9-474f-951b-137918d15af1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				Spring FactoryBean		</title>
		<link>https://blog.easysc.cn/?p=32</link>
		<pubDate>Thu, 18 Oct 2018 11:48:35 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=32</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags：FactoryBean Spring SpringBean

<blockquote>
  首先要分辨BeanFactory 与 FactoryBean的区别， 两个名字很像，所以容易搞混
  BeanFactory： 以Factory结尾，表示它是一个工厂类，是用于管理Bean的一个工厂
  FactoryBean：以Bean结尾，表示它是一个Bean，不同于普通Bean的是：它是实现了<code>FactoryBean&lt;T&gt;</code>接口的Bean，根据该Bean的Id从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，而不是FactoryBean本身， 如果要获取FactoryBean对象，可以在id前面加一个&amp;符号来获取。
</blockquote>

和代理模式很像
FactoryBean对象

<pre><code class="language-java line-numbers">public class AppResultFactoryBean implements FactoryBean&lt;AppResult&gt; {
    private String info ;

    public AppResult getObject() throws Exception {
        String[] split = info.split(",");
        AppResult appResult = new AppResult(split[0],split[1],split[2]);
        return appResult;
    }

    public Class&lt;AppResult&gt; getObjectType() {
        return AppResult.class;
    }

    public boolean isSingleton() {
        return true;
    }

    public void setInfo(String info) {
        this.info = info;
    }
}
</code></pre>

xml配置

<pre data-language=XML><code class="language-markup line-numbers">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:task="http://www.springframework.org/schema/task"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
        http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;

    &lt;bean id="appResultFactoryBean" class="cn.ws.test.AppResultFactoryBean" autowire="default"&gt;
        &lt;property name="info" value="1,2,1"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

获取对象

<hr />

<h2>通过applicationContext获取对象</h2>

<pre><code class="language-java line-numbers">//通过applicationContext注入可以正确拿到对象,但是通@AutoWired存在问题，拿到的是FactoryBean本身
ApplicationContext context  = new ClassPathXmlApplicationContext("classpath:spring/spring-beans.xml");
        Object tryBean = context.getBean("tryBean");
</code></pre>

<hr />

<h2>通过@Resource根据bean的id获取对象</h2>

<pre><code class="language-java line-numbers">//通过bean的id拿到的对象，这里的对象是通过FacatoryBean拿到的
@Resource
AppResultInterface appResultFactoryBean;
</code></pre>

<hr />

<h2>通过@Autowired注入</h2>

注：如果在xml中配置了对应的FactoryBean就不需要在加<code>@Component</code>注解，要不然会报
<code>springframework.beans.factory.NoUniqueBeanDefinitionException</code>这个错

<pre><code class="language-java line-numbers">    @Autowired
    AppResult appResult;
</code></pre>

这里因为使用了FactoryBean所以注入的都是经过了FactoryBean处理的AppResult对象

<hr />

<h2>通过纯注解的方式使用</h2>

这种方式不需要在xml里面配置，但是要注意注解的使用方式，要将<code>@Component</code>打在实现了FactoryBean的类上，然后在<code>@Autowired</code>的时候使用<code>getObject</code>返回的对象也可以实现
注：这种方式在getObject的对象上不用打<code>@Component</code>标签，要不然注入的时候是真实对象。

<hr />

<h2>使用<code>@Resouce</code>+<code>@Component</code>实现</h2>

通过在实现FactoryBean的类上加上标签<code>@Component("")</code>指定这个加载到spring容器中的名字，然后通过<code>@Resouce(name = "")</code>到spring的容器中取到对应的Bean

<pre><code class="language-java line-numbers">@Component("appResultFactoryBean")
public class AppResultFactoryBean implements FactoryBean&lt;AppResult&gt;,InitializingBean,ApplicationListener{
    private String info ;
    @Override
    public AppResult getObject() throws Exception {
        AppResult appResult = new AppResult("调用成功");
        return appResult;
    }
    @Override
    public Class&lt;AppResult&gt; getObjectType() {
        return AppResult.class;
    }
    @Override
    public boolean isSingleton() {
        return true;
    }

    public void setInfo(String info) {
        this.info = info;
    }
    @Override
    public void afterPropertiesSet() throws Exception {

    }

    @Override
    public void onApplicationEvent(ApplicationEvent applicationEvent) {

    }
}
</code></pre>

获取对象：

<pre><code class="language-java line-numbers">    @Resource(name = "appResultFactoryBean")
    AppResult appResult;
</code></pre>

使用这种方式也可以注入成功，而且比较方便，在原生的AppResult上面也可以使用<code>@Component("")</code>注解，注入的时候用<code>@Autowired</code>或者不用name属性的<code>@Resouce</code>注入就可以拿到

<hr />

<h2>调用顺序</h2>

<pre><code>getObjectType 调用！
getObjectType 调用！
getObjectType 调用！
isSingleton 调用！
getObjectType 调用！
isSingleton 调用！
getObject 调用！
{returnCode=1, returnMsg=2, details=1}
isSingleton 调用！
getObjectType 调用！
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>32</wp:post_id>
		<wp:post_date><![CDATA[2018-10-18 19:48:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-18 11:48:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[spring-factorybean]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="spring"><![CDATA[spring]]></category>
		<category domain="post_tag" nicename="spring"><![CDATA[spring]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				自定义注解		</title>
		<link>https://blog.easysc.cn/?p=83</link>
		<pubDate>Fri, 19 Oct 2018 00:36:36 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=83</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： @Annotation

<a href="http://www.cnblogs.com/xd502djj/archive/2012/07/26/2610040.html">引用1</a>
<a href="http://www.cnblogs.com/peida/archive/2013/04/24/3036689.html">引用2</a>

<hr />

<h2>元注解</h2>

注解的注解(给其他注解打注解的注解)
有四种：@Target，@Retention，@Documented，@Inherited

<ul>
<li><code>@Target</code>：
概述：用于指定注解的使用位置</li>
</ul>

<pre><code class="line-numbers">ElementType.CONSTRUCTOR:用于描述构造器
ElementType.FIELD:用于描述域
ElementType.LOCAL_VARIABLE:用于描述局部变量
ElementType.METHOD:用于描述方法
ElementType.PACKAGE:用于描述包
ElementType.PARAMETER:用于描述参数
ElementType.TYPE:用于描述类、接口(包括注解类型) 或enum声明
</code></pre>

使用如下，表明这个注解只能在方法和类接口等上使用

<pre><code class="language-java line-numbers">@Target({ElementType.METHOD,ElementType.TYPE})
public @interface AccessCheck {
}
</code></pre>

<hr />

<ul>
<li><code>@Retention</code>：
概述：注解存在的地方</li>
</ul>

<pre><code class="line-numbers">RetentionPolicy.SOURCE  //只存在于源码中，不被编译到Class文件中
RetentionPolicy.CLASS  //可以编译到Class文件中，但是不能再运行时被获取（默认）
RetentionPolicy.RUNTIME  //可以编译到Class文件中，可以在运行时通过反射获取
</code></pre>

使用如下：

<pre><code class="language-java line-numbers">@Retention(RetentionPolicy.RUNTIME)
public @interface AccessCheck {
}
</code></pre>

<hr />

<ul>
<li><code>@Documented</code>：
概述：这个注解是否可以被包含在javaDoc中，打了这个注解表示可以包含
使用如下：</li>
</ul>

<pre><code class="language-java line-numbers">@Documented
public @interface AccessCheck {
}
</code></pre>

<hr />

<ul>
<li><code>@Inherited</code>：
概述：说明子类可以继承父类中的该注解

<blockquote>
  @Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。
  
  注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。
  
  当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。
</blockquote></li>
</ul>

<hr />

<h2>自定义注解</h2>

<blockquote>
  使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。
</blockquote>

注意：
　　第一,只能用public或默认(default)这两个访问权修饰.例如,Stringvalue();这里把方法设为defaul默认类型；　 　
　　第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String;　　
　　第三,如果只有一个参数成员,最好把参数名称设为"value",后加小括号.例:下面的例子FruitName注解就只有一个参数成员。

<pre><code class="language-java line-numbers">@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface AccessCheck {
    String value() default "";  //参数
    String level() default "1";
}
</code></pre>

<h3>自定义注解使用</h3>

通过反射机制操作自定义注解

<pre><code class="language-java line-numbers">        AppResult a = new AppResult();
        Field[] fields = a.getClass().getDeclaredFields();//拿到私有的字段
        int modifiers = a.getClass().getModifiers();
        System.out.println(modifiers);
        for (Field field : fields){
            AccessCheck annotation = field.getAnnotation(AccessCheck.class);
            System.out.println(field.getModifiers());;
            System.out.println(field.getName()); //获取字段名
            if (annotation!=null){
                if (annotation.level().equals("1")){
                    try {
                        Class&lt;?&gt; type = field.getType();    //获取字段类型
                        System.out.println("是否相等："+type.equals(String.class)); //这个字段为String,输出为true
                        field.setAccessible(true);  //允许访问私有字段
                        System.out.println(field.get(a)); //拿到a对象中f字段的值
                        field.set(a, "zasjfdals");              //设置a对象中f字段的值
                        System.out.println(field.get(a));
                    } catch (IllegalAccessException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>83</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 08:36:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 00:36:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%87%aa%e5%ae%9a%e4%b9%89%e6%b3%a8%e8%a7%a3]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="various"><![CDATA[杂]]></category>
		<category domain="post_tag" nicename="%e6%9d%82"><![CDATA[杂]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				@Transactional标签的事务特性		</title>
		<link>https://blog.easysc.cn/?p=85</link>
		<pubDate>Fri, 19 Oct 2018 00:39:14 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=85</guid>
		<description></description>
		<content:encoded>
				<![CDATA[<h1>@Transactional标签的事务特性</h1>

tags： Spring @Annotation 事务

<h2>使用方式</h2>

<h2>事务传播方式</h2>

<pre><code class="language-java line-numbers">@Transactional(propagation=Propagation.REQUIRED)
</code></pre>

默认的方式：如果有事务, 那么加入事务, 没有的话新建一个

<pre><code class="language-java line-numbers">@Transactional(propagation=Propagation.NOT_SUPPORTED)
</code></pre>

容器不为这个方法开启事务

<pre><code class="language-java line-numbers">@Transactional(propagation=Propagation.REQUIRES_NEW)
</code></pre>

不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务

<pre><code class="language-java line-numbers">@Transactional(propagation=Propagation.MANDATORY) 
</code></pre>

必须在一个已有的事务中执行,否则抛出异常

<pre><code class="language-java line-numbers">@Transactional(propagation=Propagation.NEVER) 
</code></pre>

必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)

<pre><code class="language-java line-numbers">@Transactional(propagation=Propagation.SUPPORTS) 
</code></pre>

如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务

<h2>事务隔离级别</h2>

<pre><code class="language-java line-numbers">@Transactional(isolation = Isolation.READ_UNCOMMITTED)
</code></pre>

读取未提交数据(会出现脏读, 不可重复读) 基本不使用

<pre><code class="language-java line-numbers">@Transactional(isolation = Isolation.READ_COMMITTED)
</code></pre>

读取已提交数据(会出现不可重复读和幻读)

<pre><code class="language-java line-numbers">@Transactional(isolation = Isolation.REPEATABLE_READ)
</code></pre>

可重复读(会出现幻读)

<pre><code class="language-java line-numbers">@Transactional(isolation = Isolation.SERIALIZABLE)
</code></pre>

<h2>标签中的常用属性</h2>

<ul>
<li>readOnly
该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。例如：<code>@Transactional(readOnly=true)</code></li>
<li>rollbackFor
该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。例如：
指定单一异常类：<code>@Transactional(rollbackFor=RuntimeException.class)</code>
指定多个异常类：<code>@Transactional(rollbackFor={RuntimeException.class, Exception.class})</code></li>
<li>rollbackForClassName
该属性用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。例如：
指定单一异常类名称：<code>@Transactional(rollbackForClassName="RuntimeException")</code>
指定多个异常类名称：<code>@Transactional(rollbackForClassName={"RuntimeException","Exception"})</code></li>
<li>propagation
该属性用于设置事务的传播行为
例如：<code>@Transactional(propagation=Propagation.NOT_SUPPORTED,readOnly=true)</code></li>
</ul>

<h2>Attention:</h2>

@Transactional使用的时候同一个类的不同方法不会有事务的传播，不同的类会有事务的传播，比如

<pre><code class="language-java line-numbers">Class Test{
    public void A(){
        B("a");
    }

    @Transactional(rollbackFor = Exception.class)
    public void B(String word){

        System.out.println(word);
        int a = 1/0;
    }
}
//在A中调用B当B中发生异常的时候，这里不会出现回滚，因为这个时候A不具有事务特性，在同一个类中的不同方法上不具有事务的传播特性
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>85</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 08:39:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 00:39:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[transactional%e6%a0%87%e7%ad%be%e7%9a%84%e4%ba%8b%e5%8a%a1%e7%89%b9%e6%80%a7]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="spring"><![CDATA[spring]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				Apache Pool		</title>
		<link>https://blog.easysc.cn/?p=87</link>
		<pubDate>Fri, 19 Oct 2018 00:41:36 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=87</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： Apache pool 对象池
引用：<a href="http://www.cnblogs.com/jinzhiming/p/5120670.html">对象池，包括带key的</a>

<hr />

导入pom.xml

<pre data-language=XML><code class="language-markup line-numbers">&lt;!--commons pool--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-pool&lt;/groupId&gt;
    &lt;artifactId&gt;commons-pool&lt;/artifactId&gt;
    &lt;version&gt;1.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

注：这里的pool不是pool2

<hr />

<h2>不带key的对象池</h2>

概述：
　　factory对象实现<code>PoolableObjectFactory</code>接口，完成其中的方法，可以在调用实例中将factory对象通过构造方法放入<code>GenericObjectPool</code>或者<code>StackObjectPool</code>

测试对象

<pre><code class="language-java line-numbers">public class PoolTestObject {

    //记录次数
    private int num;
    private boolean active;
    //对象id
    private String uuid;

    public PoolTestObject() {
        this.uuid = UUID.randomUUID().toString();
        System.out.println("create a Object UUID:"+ uuid);
    }
    //略去getter/setter
}
</code></pre>

不带key的poolFactory

<pre><code class="language-java line-numbers">public class PoolTestFactory implements PoolableObjectFactory&lt;PoolTestObject&gt; {

    @Override
    public PoolTestObject makeObject() throws Exception {
        PoolTestObject testPoolObject = new PoolTestObject();
        System.out.println("创建对象,uuid:"+testPoolObject.getUuid());
        return testPoolObject;
    }

    @Override
    public void destroyObject(PoolTestObject testPoolObject) throws Exception {
        testPoolObject = null;
        System.out.println("摧毁对象！,uuid:"+testPoolObject.getUuid());
    }


    @Override
    public boolean validateObject(PoolTestObject testPoolObject) {
        System.out.println("验证对象！,uuid:"+testPoolObject.getUuid());
        //验证实例是否安全
        if (testPoolObject.isActive()){
            return true;
        }else {
            return false;
        }
    }

    //重新初始化实例返回池
    @Override
    public void activateObject(PoolTestObject testPoolObject) throws Exception {
        testPoolObject.setActive(true);
        System.out.println("激活对象！uuid:"+testPoolObject.getUuid());
    }

    //取消初始化实例返回到空闲对象池
    @Override
    public void passivateObject(PoolTestObject testPoolObject) throws Exception {
        testPoolObject.setActive(false);
        System.out.println("钝化对象 uuid:"+testPoolObject.getUuid());
    }
}
</code></pre>

验证(使用的引用中的例子，并做了点修改)：

<pre><code class="language-java line-numbers">@Test
    public void testPool(){
        PoolTestObject bo = null;
        PoolableObjectFactory factory = new PoolTestFactory();
        GenericObjectPool pool = new GenericObjectPool(factory);
        GenericObjectPool.Config config = new GenericObjectPool.Config();//连接池配置
        config.maxActive = 5;
        pool.setConfig(config);//设置连接池
        //这里两种池都可以
        //ObjectPool pool = new StackObjectPool(factory);
        try {
            for(int i = 0; i &lt; 5; i++) {
                System.out.println("\n==========="+i+"===========");
                System.out.println("池中处于闲置状态的实例pool.getNumIdle()："+pool.getNumIdle());//拿到闲置状态的链接数
                //从池里取一个对象，新创建makeObject或将以前闲置的对象取出来
                bo = (PoolTestObject)pool.borrowObject();
                System.out.println(bo.getUuid());
                bo.setUuid("-----------------------------------------1");
                System.out.println("bo:"+bo);
                System.out.println(bo.getNum());;
                System.out.println("池中所有在用实例数量pool.getNumActive()："+pool.getNumActive());
                if((i%2) == 0) {
                    //用完之后归还对象
                    pool.returnObject(bo);
                    System.out.println("归还对象！！！！");
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if(bo != null) {
                    pool.returnObject(bo);
                }
                //关闭池
                pool.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
</code></pre>

调用结果，可以看到factory中的各个方法的执行过程,以及返回的对象如果做了修改，会保存这个修改，归还了对象之后，这个对象会回到池中作为空闲对象，下次borrow的时候，如果有空闲对象，会先调用空闲对象，如果没有空闲对象了，会调用<code>makeObject</code>去自动创建对象

<pre><code class="line-numbers">===========0===========
池中处于闲置状态的实例pool.getNumIdle()：0
create a Object UUID:04ef2118-0b83-458c-b8e9-dc6d4b6548f8
创建对象,uuid:04ef2118-0b83-458c-b8e9-dc6d4b6548f8
激活对象！uuid:04ef2118-0b83-458c-b8e9-dc6d4b6548f8
04ef2118-0b83-458c-b8e9-dc6d4b6548f8
bo:cn.ws.apachepool.PoolTestObject@3d012ddd
0
池中所有在用实例数量pool.getNumActive()：1
钝化对象 uuid:-----------------------------------------1
归还对象！！！！

===========1===========
池中处于闲置状态的实例pool.getNumIdle()：1
激活对象！uuid:-----------------------------------------1
-----------------------------------------1
bo:cn.ws.apachepool.PoolTestObject@3d012ddd
0
池中所有在用实例数量pool.getNumActive()：1

===========2===========
池中处于闲置状态的实例pool.getNumIdle()：0
create a Object UUID:d979744b-fa76-4547-a34d-432e75049249
创建对象,uuid:d979744b-fa76-4547-a34d-432e75049249
激活对象！uuid:d979744b-fa76-4547-a34d-432e75049249
d979744b-fa76-4547-a34d-432e75049249
bo:cn.ws.apachepool.PoolTestObject@6f2b958e
0
池中所有在用实例数量pool.getNumActive()：2
钝化对象 uuid:-----------------------------------------1
归还对象！！！！

===========3===========
池中处于闲置状态的实例pool.getNumIdle()：1
激活对象！uuid:-----------------------------------------1
-----------------------------------------1
bo:cn.ws.apachepool.PoolTestObject@6f2b958e
0
池中所有在用实例数量pool.getNumActive()：2

===========4===========
池中处于闲置状态的实例pool.getNumIdle()：0
create a Object UUID:34bf5dce-6449-439c-ac92-5d26557d37b9
创建对象,uuid:34bf5dce-6449-439c-ac92-5d26557d37b9
激活对象！uuid:34bf5dce-6449-439c-ac92-5d26557d37b9
34bf5dce-6449-439c-ac92-5d26557d37b9
bo:cn.ws.apachepool.PoolTestObject@1eb44e46
0
池中所有在用实例数量pool.getNumActive()：3
钝化对象 uuid:-----------------------------------------1
归还对象！！！！
钝化对象 uuid:-----------------------------------------1
</code></pre>

<code>GenericObjectPool</code>可以在创建了之后设置<code>Cofig</code>可以查看设置的源码
具体参数如下：

<pre><code class="line-numbers">public void setConfig(GenericObjectPool.Config conf) {
        synchronized(this) {
            this.setMaxIdle(conf.maxIdle); 
            this.setMinIdle(conf.minIdle);  
            this.setMaxActive(conf.maxActive); //能借出的最大值，为负数表示没限制
            this.setMaxWait(conf.maxWait);  //最大等待时间
            this.setWhenExhaustedAction(conf.whenExhaustedAction);//借出对象达到最大值时的行为
            this.setTestOnBorrow(conf.testOnBorrow);    //设定在借出对象时是否进行有效性检查
            this.setTestOnReturn(conf.testOnReturn);    //设定在还回对象时是否进行有效性检查
            this.setTestWhileIdle(conf.testWhileIdle);  //设定在进行后台对象清理时，是否还对没有过期的池内对象进行有效性检查。不能通过有效性检查的对象也将被回收
            this.setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
            this.setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);    //设定在进行后台对象清理时，视休眠时间超过了多少毫秒的对象为过期。过期的对象将被回收。如果这个值不是正数，那么对休眠时间没有特别的约束。
            this.setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);  //设定间隔每过多少毫秒进行一次后台对象清理的行动。如果这个值不是正数，则实际上不会进行后台对象清理。
            this.setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
            this.setLifo(conf.lifo);    //池对象的放入和取出默认是后进先出的原则，默认是true，代表后进后出，设置为false代表先进先出。
        }
</code></pre>

<blockquote>
  参数whenExhaustedA
  ction指定在池中借出对象的数目已达极限的情况下，调用它的borrowObject方法时的行为。可以选用的值有：
</blockquote>

<pre><code>GenericObjectPool.WHEN_EXHAUSTED_BLOCK，表示等待；
GenericObjectPool.WHEN_EXHAUSTED_GROW，表示创建新的实例（不过这就使maxActive参数失去了意义）；
GenericObjectPool.WHEN_EXHAUSTED_FAIL，表示抛出一个java.util.NoSuchElementException异常。
</code></pre>

<hr />

<h2>带key的对象池</h2>

概述：factory对象实现<code>KeyedPoolableObjectFactory</code>接口，完成其中的方法，可以在调用实例中将factory对象通过构造方法放入<code>GenericKeyedObjectPool</code>
可以通过<code>keyPool.addObject("name");</code>往池中添加对象，也可以直接通过<code>keyPool.borrow("name");</code>如果没有，会自动创建一个再借出来

带key的对象池和不带key的对象池区别在于可以通过key去取到特定的对象(在添加对象的时候回去设置key)，具体参考<a href="http://www.cnblogs.com/jinzhiming/p/5120670.html">引用</a>

<hr />

<h2>其他</h2>

还可以实现<code>ObjectPool</code>接口，完成其中的方法，来自己定义一个Pool，这里的<code>GenericObjectPool</code>就是实现了<code>ObjectPool</code>接口。

<pre><code class="line-numbers">public interface ObjectPool&lt;T&gt; {
    T borrowObject() throws Exception, NoSuchElementException, IllegalStateException;

    void returnObject(T var1) throws Exception;

    void invalidateObject(T var1) throws Exception;

    void addObject() throws Exception, IllegalStateException, UnsupportedOperationException;

    int getNumIdle() throws UnsupportedOperationException;

    int getNumActive() throws UnsupportedOperationException;

    void clear() throws Exception, UnsupportedOperationException;

    void close() throws Exception;

    /** @deprecated */
    @Deprecated
    void setFactory(PoolableObjectFactory&lt;T&gt; var1) throws IllegalStateException, UnsupportedOperationException;
}
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>87</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 08:41:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 00:41:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[apache-pool]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="various"><![CDATA[杂]]></category>
		<category domain="post_tag" nicename="%e6%9d%82"><![CDATA[杂]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				在Linux上安装Redis		</title>
		<link>https://blog.easysc.cn/?p=89</link>
		<pubDate>Fri, 19 Oct 2018 00:43:45 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=89</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： Redis Linux Centos
引用：<a href="http://www.cnblogs.com/dongfanghao/p/7158282.html">Redis1</a> <a href="http://blog.csdn.net/ludonqin/article/details/47211109">Redis2</a>

<hr />

<h2>安装</h2>

安装C语言的编译环境

<pre><code>yum install gcc
</code></pre>

下载Redis的安装包<a href="https://redis.io/download">Redis</a>
放到<code>/usr/local/src</code>下面
解压缩

<pre><code>tar -xzvf redis-3.2.9.tar.gz
</code></pre>

到解压后的目录<code>/usr/local/src/redis-3.2.9</code>
编译打包

<pre><code>make
</code></pre>

常用命令

<pre><code>make     　　　　　　　　　　// 编译redis
make distclean　　   　　// 清除之前编译过程中残留的文件等,可在make前执行
redis-server       // 默认启动redis服务器
redis-server redis.conf    // 使用配置文件启动redis服务器
</code></pre>

跳转到<code>src</code>目录执行,也可以手动拷贝redis-server、redis-cli、redis-check-aof、redis-check-dump等至/usr/local/bin目录下

<pre><code>make install
</code></pre>

跳转到<code>/usr/local/bin</code>下，会多出下面的文件

<pre><code>[root@centos bin]# ll
总用量 26348
-rwxr-xr-x. 1 root root 5580423  redis-benchmark
-rwxr-xr-x. 1 root root   22185  redis-check-aof
-rwxr-xr-x. 1 root root 7830146  redis-check-rdb
-rwxr-xr-x. 1 root root 5709355  redis-cli
lrwxrwxrwx. 1 root root      12  redis-sentinel -&gt; redis-server
-rwxr-xr-x. 1 root root 7830146  redis-server
</code></pre>

<h2>redis.conf</h2>

在<code>/usr/local/src</code>下面建一个redis文件夹，用来存放配置文件和一些其他信息

<pre><code>mkdir redis //创建redis文件夹
cp ../redis-3.2.9/redis.conf . //将redis.conf复制到当前目录
vi redis.conf
</code></pre>

打开redis.conf设置

<pre><code class="line-numbers">`bind 127.0.0.1`
protected-mode yes
`port 6379`
tcp-backlog 511
timeout 0
tcp-keepalive 300
`daemonize yes`
supervised no
`pidfile /var/run/redis_6379.pid`
loglevel notice
`logfile ./redis.log`
databases 16
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
`dir ./`
slave-serve-stale-data yes
slave-read-only yes
repl-diskless-sync no
repl-diskless-sync-delay 5
repl-disable-tcp-nodelay no
slave-priority 100
`appendonly yes`
appendfilename "appendonly.aof"
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
aof-load-truncated yes
lua-time-limit 5000
slowlog-log-slower-than 10000
slowlog-max-len 128
latency-monitor-threshold 0
notify-keyspace-events ""
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-size -2
list-compress-depth 0
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
hll-sparse-max-bytes 3000
activerehashing yes
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
hz 10
aof-rewrite-incremental-fsync yes
</code></pre>

几个常用的设置

<pre><code>bind 127.0.0.1  //访问ip，0.0.0.0 表示任何人都可以访问
port 6379 //默认的端口
daemonize yes //运行模式，yes表示后台运行 no表示Console运行
pidfile /var/run/redis_6379.pid 进程文件
logfile ./redis.log  //log文件
appendonly yes //是否持久化，yes会在当前目录生成文件
</code></pre>

使用<code>i</code>编辑，<code>/</code>查找内容，<code>:wq</code>保存并退出 <code>:q!</code>不保存退出<code>n</code>查找下一个

<h2>启动和关闭</h2>

使用配置文件启动
可以在新建的redis目录里执行

<pre><code>redis-server redis.conf
</code></pre>

使用客户端连接redis

<pre><code>redis-cli
</code></pre>

退出客户端

<pre><code>Ctrl+c
</code></pre>

关闭redis

<pre><code>redis-cli shutdown
#带密码的关闭(带密码连接一样，修改后面命令即可)
redis-cli -a 密码 shutdown
</code></pre>

或者

<pre><code>ps -ef |grep redis
kill -9 pid
</code></pre>

<h2>配置Redis服务</h2>

创建redis启动脚本
拷贝解压包下utils下redis启动脚本至<code>/etc/init.d/</code>

<pre><code>cp redis_init_script /etc/init.d/
</code></pre>

修改脚本名称(也可不修改)为redis_6379

<pre><code>mv redis_init_script redis_6379

vi redis_6379
</code></pre>

将对应的参数修改

<pre><code>REDISPORT=6379
EXEC=/usr/local/bin/redis-server
CLIEXEC=/usr/local/bin/redis-cli

PIDFILE=/var/run/redis_${REDISPORT}.pid
</code></pre>

CONF="/usr/local/src/redis/redis_${REDISPORT}.conf"

启动/关闭/重启

<pre><code>/etc/init.d/redis_6379 start/stop/restart
</code></pre>

或者

<pre><code>service redis_6379 start/stop/restart
</code></pre>

<hr />

<h2>Redis的常用命令</h2>

参考：<a href="http://www.cnblogs.com/whoamme/p/3532129.html">Redis常用命令</a>

<pre><code>redis-cli -p 6379  //客户端连接指定端口
</code></pre>

返回值说明。默认返回<code>(integer) 0</code>表示false，即失败，返回<code>(integer) 1</code>表示true，即成功
字符串：

<pre><code>set key value
get key value
setnx key value  //如果key存在就不设置，如果不存在就设置，
mset key value key value...     //同时设置多个值，同时成功，同时失败
msetnx key value key value...
mget key1 key2 key3     //获取多个Key的值
getset key newvalue     //获取key并设置为新值
append key word         //给key追加word中的内容
setrange key n repvalue    //将key对应value的第n个字符和这里的repvalue替换(从0开始)
getrange key start end  //获取key的值从start到end
strlen key      //返回key对应value值的长度
</code></pre>

key-value

<pre><code>keys *      //列出所有的键值
rename key new key  //重命名键值
type key    //判断key的类型
exists key  //判断key是否存在
del key     //删除key
expire key second   //设置key的过期时间，单位为秒
ttl key         //查看key的过期时间 -2为已过期 -1为没有设置过期
persist key     //取消过期时间设置
randomkey 随机返回一个key
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>89</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 08:43:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 00:43:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%9c%a8linux%e4%b8%8a%e5%ae%89%e8%a3%85redis]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="redis"><![CDATA[redis]]></category>
		<category domain="post_tag" nicename="redis"><![CDATA[redis]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				JDK8 Stream API		</title>
		<link>https://blog.easysc.cn/?p=91</link>
		<pubDate>Fri, 19 Oct 2018 00:46:21 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=91</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： JDK8

参考：
<a href="https://www.cnblogs.com/CarpenterLee/p/6545321.html">Java Stream API入门篇</a>
<a href="https://blog.csdn.net/chaoer89/article/details/52389458">Java8 Stream API介绍</a>
<a href="https://www.jianshu.com/p/c53eb31752c4">Java8之Stream类</a>

<hr />

<pre><code>    List&lt;String&gt; strings = Arrays.asList("a", "d", "ga", "dsagafd","adfsafdsa","a","d");
    strings.stream().filter(e-&gt;e.startsWith("a")).forEach(e-&gt; System.out.println(e));
    System.out.println("-------------------");
    strings.stream().distinct().forEach(e-&gt; System.out.println(e));
    Stream&lt;String&gt; sorted = strings.stream().sorted((a, b) -&gt; b.length() - a.length());
    System.out.println("==================");
    sorted.forEach(a-&gt; System.out.println(a));
    boolean a = strings.stream().anyMatch((s) -&gt; s.equals("a"));
    boolean b = strings.stream().allMatch((s) -&gt; s.equals("a"));
    boolean c = strings.stream().noneMatch((s) -&gt; s.equals("a"));
    System.out.println(a);
    System.out.println(b);
    System.out.println(c);
    ---------------------结果--------------------------
    a
    adfsafdsa
    a
    -------------------
    a
    d
    ga
    dsagafd
    adfsafdsa
    ==================
    adfsafdsa
    dsagafd
    ga
    a
    d
    a
    d
    true
    false
    false
</code></pre>

对stream的操作分为为两类，中间操作(intermediate operations)和结束操作(terminal operations)
中间操作是惰性化的，每次调用会对Stream做一定的处理，返回一个新的Stream，并没有真正开始计算
每个stream只能有一个结束操作，执行了结束操作之后，stream就被消费掉了。

常用方法：
中间操作：<code>concat() distinct() filter() flatMap() limit() map() peek() 
skip() sorted() parallel() sequential() unordered()</code>
结束操作：<code>allMatch() anyMatch() collect() count() findAny() findFirst() 
forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()</code>

<code>sort()</code>有两种方式，对stream进行排序，默认排序和自定义的Comparable形式，例子参见上方
<code>map</code>和<code>flatMap</code> 都是对stream进行遍历操作，都会返回操作之后的stream，不同的是flatMap会将多个集合中的元素全部拿出来放到一个集合中，而map不会
如对两个集合[1,2,3],[8,9,7]
stream之后的map操作的结果是[1,2,3],[8,9,7]
stream之后的flatMap结果是[1,2,3,8,9,7]
<code>filter</code>可以对元素进行过滤，参考上面例子
<code>limit</code>截取stream中的元素
<code>skip</code>跳过stream中的元素
<code>distinct</code>去重，通过equals和hashcode方法，自定义类
<code>anyMatch</code>,<code>allMatch</code>,<code>noneMatch</code>,stream中的元素有匹配，全部匹配，全都不匹配。
<code>reduce</code>聚合操作]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>91</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 08:46:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 00:46:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[jdk8-stream-api]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="various"><![CDATA[杂]]></category>
		<category domain="post_tag" nicename="%e6%9d%82"><![CDATA[杂]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				使用Jedis连接Redis		</title>
		<link>https://blog.easysc.cn/?p=93</link>
		<pubDate>Fri, 19 Oct 2018 00:47:33 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=93</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： Redis Jedis pool

<hr />

如果是通过外网访问Redis一定要开放防火墙的端口权限，不然不能访问
导入pom.xml

<pre data-language=XML><code class="language-markup line-numbers">    &lt;dependency&gt;
        &lt;groupId&gt;redis.clients&lt;/groupId&gt;
        &lt;artifactId&gt;jedis&lt;/artifactId&gt;
        &lt;version&gt;2.9.0&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>

Java代码

<pre><code class="language-java line-numbers">Jedis jedis = new Jedis("127.0.0.1",6379);      //新建一个到指定ip和端口的Jedis对象
jedis.set("test","这是一个测试");
</code></pre>

创建对象还有一些其他方法，这里不赘述

<hr />

<h2>通过JedisPool连接</h2>

设置JedisPool，参照<a href="http://www.cnblogs.com/tankaixiong/p/4048167.html">JedisPoolConfig配置</a>

<pre><code class="line-numbers">JedisPoolConfig config = new JedisPoolConfig();

//连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true
config.setBlockWhenExhausted(true);

//设置的逐出策略类名, 默认DefaultEvictionPolicy(当连接超过最大空闲时间,或连接数超过最大空闲连接数)
config.setEvictionPolicyClassName("org.apache.commons.pool2.impl.DefaultEvictionPolicy");

//是否启用pool的jmx管理功能, 默认true
config.setJmxEnabled(true);

//MBean ObjectName = new ObjectName("org.apache.commons.pool2:type=GenericObjectPool,name=" + "pool" + i); 默 认为"pool", JMX不熟,具体不知道是干啥的...默认就好.
config.setJmxNamePrefix("pool");

//是否启用后进先出, 默认true
config.setLifo(true);

//最大空闲连接数, 默认8个
config.setMaxIdle(8);

//最大连接数, 默认8个
config.setMaxTotal(8);

//获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1
config.setMaxWaitMillis(-1);

//逐出连接的最小空闲时间 默认1800000毫秒(30分钟)
config.setMinEvictableIdleTimeMillis(1800000);

//最小空闲连接数, 默认0
config.setMinIdle(0);

//每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3
config.setNumTestsPerEvictionRun(3);

//对象空闲多久后逐出, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲数 时直接逐出,不再根据MinEvictableIdleTimeMillis判断  (默认逐出策略)   
config.setSoftMinEvictableIdleTimeMillis(1800000);

//在获取连接的时候检查有效性, 默认false
config.setTestOnBorrow(false);

//在空闲时检查有效性, 默认false
config.setTestWhileIdle(false);

//逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1
config.setTimeBetweenEvictionRunsMillis(-1);
</code></pre>

注：Jedis低版本可能不存在<code>maxTotal</code>和<code>maxWaitMillis</code>，使用<code>maxActive</code>和<code>maxWait</code>

<pre><code class="language-java line-numbers">JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        jedisPoolConfig.setMaxIdle(5);      //设置最大空闲数
        jedisPoolConfig.setBlockWhenExhausted(true);    //设置连接耗尽时是否阻塞，true为阻塞到超时（默认），false抛出异常
        jedisPoolConfig.setEvictionPolicyClassName("org.apache.commons.pool2.impl.DefaultEvictionPolicy");//设置逐出策略
        jedisPoolConfig.setJmxEnabled(true);        //是否启用pool的jmx
        jedisPoolConfig.setMinIdle(2);      //初始化连接数
        jedisPoolConfig.setMaxWaitMillis(3000);//设置资源耗尽时最大阻塞时间
        JedisPool jedisPool = new JedisPool(jedisPoolConfig,"127.0.0.1",6379,3000);
        Jedis jedis = jedisPool.getResource();
        String aa = jedis.get("aa");
        System.out.println(aa);
</code></pre>

<hr />

<h2>Jedis集成Spring</h2>

配置文件加载

<pre><code class="line-numbers">&lt;context:property-placeholder location="classpath:config/redis.properties" ignore-unresolvable="true" file-encoding="utf-8"/&gt;
&lt;!--配置jedispoolconfig--&gt;
    &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt;
        &lt;property name="minIdle" value="${jedis.minIdle}"&gt;&lt;/property&gt;
        &lt;property name="lifo" value="${jedis.lifo}"&gt;&lt;/property&gt;
        &lt;property name="maxIdle" value="${jedis.maxIdle}"&gt;&lt;/property&gt;
        &lt;property name="maxTotal" value="${jedis.maxTotal}"&gt;&lt;/property&gt;
        &lt;property name="maxWaitMillis" value="${jedis.maxWaitMillis}"&gt;&lt;/property&gt;
        &lt;property name="minEvictableIdleTimeMillis" value="${jedis.minEvictableIdleTimeMillis}"&gt;&lt;/property&gt;
        &lt;property name="numTestsPerEvictionRun" value="${jedis.numTestsPerEvictionRun}"&gt;&lt;/property&gt;
        &lt;property name="softMinEvictableIdleTimeMillis" value="${jedis.softMinEvictableIdleTimeMillis}"&gt;&lt;/property&gt;
        &lt;property name="testOnBorrow" value="${jedis.testOnBorrow}"&gt;&lt;/property&gt;
        &lt;property name="testWhileIdle" value="${jedis.testWhileIdle}"&gt;&lt;/property&gt;
        &lt;property name="timeBetweenEvictionRunsMillis" value="${jedis.timeBetweenEvictionRunsMillis}"&gt;&lt;/property&gt;
        &lt;property name="blockWhenExhausted" value="${jedis.blockWhenExhausted}"&gt;&lt;/property&gt;
        &lt;property name="jmxEnabled" value="${jedis.jmxEnabled}"&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;!--配置jedispool--&gt;
    &lt;bean id="jedisPool" class="redis.clients.jedis.JedisPool" scope="singleton"&gt;
        &lt;constructor-arg index="0" ref="jedisPoolConfig" /&gt;
        &lt;constructor-arg index="1" value="${jedis.address}" /&gt;
        &lt;constructor-arg index="2" value="${jedis.port}" type="int" /&gt;
        &lt;constructor-arg index="3" value="0" type="int" /&gt;
    &lt;/bean&gt;
</code></pre>

通过上面的方式，使用<code>@Autowired</code>注入的时候会自动注入<code>jedispool</code>并且使用配置文件中的配置
redis.properties:

<pre><code class="line-numbers">#设置初始化实例数
jedis.minIdle=1
#设置最大空闲数
jedis.maxIdle=5
#设置进出策略，默认为true,LIFO（后进先出）false为FIFO
jedis.lifo=true
#设置最大连接数
jedis.maxTotal=10
#连接耗尽时。最大等待时间
jedis.maxWaitMillis=3000
#逐出连接的最小空闲时间 默认1800000毫秒(30分钟)
jedis.minEvictableIdleTimeMillis=1800000
#每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3
jedis.numTestsPerEvictionRun=3
#对象空闲多久后逐出, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲数 时直接逐出,不再根据MinEvictableIdleTimeMillis判断  (默认逐出策略)
jedis.softMinEvictableIdleTimeMillis=1800000
#在获取连接的时候检查有效性, 默认false
jedis.testOnBorrow=true
#在空闲时检查有效性, 默认false
jedis.testWhileIdle=true
#逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1
jedis.timeBetweenEvictionRunsMillis=1000
#连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true
jedis.blockWhenExhausted=true
#是否启用pool的jmx管理功能, 默认true
jedis.jmxEnabled=true

######################JedisPool################################
jedis.address=127.0.0.1
jedis.port=6379
</code></pre>

上面设置只能为参考，不具有实际项目的应用能力
<br>
Java代码

<pre><code class="line-numbers">    @Autowired
    private JedisPool jedisPool;

    public String get(String key){
        try {
            Jedis jedis = jedisPool.getResource();
            return jedis.get(key);
        } catch (Exception e) {
            e.printStackTrace();
           log.error("get Error!"+e);
        }
        return null;
    }
</code></pre>

也可以只注入JedisPoolConfig，手动创建JedisPool

<pre><code class="line-numbers">@Component
public class JedisUtil {
    @Autowired
    JedisPoolConfig jedisPoolConfig;

    private static JedisPool jedisPool;

    @Value("${jedis.address}")
    private String redisAddress;

    @Value("${jedis.port}")
    private int redisPort;

    private static final Log log = LogFactory.getLog(JedisUtil.class);

    //单例
    private JedisPool getPool(){
        if (jedisPool==null){
            synchronized (JedisUtil.class){
                if (jedisPool==null){
                    jedisPool = new JedisPool(jedisPoolConfig,redisAddress,redisPort);
                }
            }
        }
        return jedisPool;
    }

    public String get(String key){
        try{
            Jedis jedis = getPool().getResource();
            return jedis.get(key);
        }catch (Exception e){
            log.error("get Error"+e);
        }
        return null;
    }
}
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>93</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 08:47:33]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 00:47:33]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bd%bf%e7%94%a8jedis%e8%bf%9e%e6%8e%a5redis]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="redis"><![CDATA[redis]]></category>
		<category domain="post_tag" nicename="redis"><![CDATA[redis]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				narayana		</title>
		<link>https://blog.easysc.cn/?p=161</link>
		<pubDate>Fri, 19 Oct 2018 07:40:18 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/archives/161</guid>
		<description></description>
		<content:encoded>
				<![CDATA[/**:not([class*="icon"]):not(i) {
font-family: Segoe UI,Monaco,"Microsoft Yahei" !important;
}*/
*:not([class*="icon"]):not(i) {
font-family: Menlo, "Ubuntu Mono", Consolas, "Courier New", "Microsoft Yahei", "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif,"Microsoft Yahei" !important;
}]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>161</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 15:40:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 07:40:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[narayana]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[custom_css]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
														</item>
					<item>
		<title>
				Privacy Policy		</title>
		<link>https://blog.easysc.cn/?page_id=162</link>
		<pubDate>Thu, 18 Oct 2018 07:43:40 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?page_id=3</guid>
		<description></description>
		<content:encoded>
				<![CDATA[<h2>Who we are</h2>

Our website address is: http://106.12.110.168:9000.</p>

<h2>What personal data we collect and why we collect it</h2>

<h3>评论</h3>

When visitors leave comments on the site we collect the data shown in the comments form, and also the visitor’s IP address and browser user agent string to help spam detection.

An anonymized string created from your email address (also called a hash) may be provided to the Gravatar service to see if you are using it. The Gravatar service privacy policy is available here: https://automattic.com/privacy/. After approval of your comment, your profile picture is visible to the public in the context of your comment.

<h3>媒体</h3>

If you upload images to the website, you should avoid uploading images with embedded location data (EXIF GPS) included. Visitors to the website can download and extract any location data from images on the website.

<h3>Contact forms</h3>

<h3>Cookies</h3>

If you leave a comment on our site you may opt-in to saving your name, email address and website in cookies. These are for your convenience so that you do not have to fill in your details again when you leave another comment. These cookies will last for one year.

If you have an account and you log in to this site, we will set a temporary cookie to determine if your browser accepts cookies. This cookie contains no personal data and is discarded when you close your browser.

When you log in, we will also set up several cookies to save your login information and your screen display choices. Login cookies last for two days, and screen options cookies last for a year. If you select "Remember Me", your login will persist for two weeks. If you log out of your account, the login cookies will be removed.

If you edit or publish an article, an additional cookie will be saved in your browser. This cookie includes no personal data and simply indicates the post ID of the article you just edited. It expires after 1 day.

<h3>Embedded content from other websites</h3>

Articles on this site may include embedded content (e.g. videos, images, articles, etc.). Embedded content from other websites behaves in the exact same way as if the visitor has visited the other website.

These websites may collect data about you, use cookies, embed additional third-party tracking, and monitor your interaction with that embedded content, including tracking your interaction with the embedded content if you have an account and are logged in to that website.

<h3>Analytics</h3>

<h2>Who we share your data with</h2>

<h2>How long we retain your data</h2>

If you leave a comment, the comment and its metadata are retained indefinitely. This is so we can recognize and approve any follow-up comments automatically instead of holding them in a moderation queue.

For users that register on our website (if any), we also store the personal information they provide in their user profile. All users can see, edit, or delete their personal information at any time (except they cannot change their username). Website administrators can also see and edit that information.

<h2>What rights you have over your data</h2>

If you have an account on this site, or have left comments, you can request to receive an exported file of the personal data we hold about you, including any data you have provided to us. You can also request that we erase any personal data we hold about you. This does not include any data we are obliged to keep for administrative, legal, or security purposes.

<h2>Where we send your data</h2>

Visitor comments may be checked through an automated spam detection service.

<h2>Your contact information</h2>

<h2>Additional information</h2>

<h3>How we protect your data</h3>

<h3>What data breach procedures we have in place</h3>

<h3>What third parties we receive data from</h3>

<h3>What automated decision making and/or profiling we do with user data</h3>

<h3>Industry regulatory disclosure requirements</h3>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>162</wp:post_id>
		<wp:post_date><![CDATA[2018-10-18 15:43:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-18 07:43:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[privacy-policy]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
														<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
		<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				python高级特性		</title>
		<link>https://blog.easysc.cn/?p=298</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=298</guid>
		<description></description>
		<content:encoded>
				<![CDATA[<h2>切片</h2>

<h2>迭代</h2>

<h2>列表生成式</h2>

<h2>生成器</h2>

<h2>迭代器</h2>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>298</wp:post_id>
		<wp:post_date><![CDATA[2018-11-01 15:53:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="various"><![CDATA[杂]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				python IO编程		</title>
		<link>https://blog.easysc.cn/?p=301</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=301</guid>
		<description></description>
		<content:encoded>
				<![CDATA[]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>301</wp:post_id>
		<wp:post_date><![CDATA[2018-11-07 14:40:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="various"><![CDATA[杂]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				首页		</title>
		<link>https://blog.easysc.cn/?p=402</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">https://blog.easysc.cn/?p=402</guid>
		<description></description>
		<content:encoded>
				<![CDATA[]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>402</wp:post_id>
		<wp:post_date><![CDATA[2019-04-04 11:08:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
														<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
		<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[402]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
		<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
		<wp:meta_value><![CDATA[https://blog.easysc.cn/]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_orphaned]]></wp:meta_key>
		<wp:meta_value><![CDATA[1554347308]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
						</title>
		<link>https://blog.easysc.cn/?p=403</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">https://blog.easysc.cn/?p=403</guid>
		<description></description>
		<content:encoded>
				<![CDATA[ ]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>403</wp:post_id>
		<wp:post_date><![CDATA[2019-04-04 11:08:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
														<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
		<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[26]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
		<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_orphaned]]></wp:meta_key>
		<wp:meta_value><![CDATA[1554347308]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				ceshi		</title>
		<link>https://blog.easysc.cn/?p=414</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">https://blog.easysc.cn/?p=414</guid>
		<description></description>
		<content:encoded>
				<![CDATA[<img src="https://imagesbed.oss-cn-shenzhen.aliyuncs.com/picgo/QQ截图20190416145522.png" alt="a" />]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>414</wp:post_id>
		<wp:post_date><![CDATA[2019-04-16 15:17:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				QQ截图20190418095857		</title>
		<link>https://blog.easysc.cn/?attachment_id=419</link>
		<pubDate>Thu, 18 Apr 2019 01:59:12 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">https://blog.easysc.cn/wp-content/uploads/2019/04/QQ截图20190418095857.png</guid>
		<description></description>
		<content:encoded>
				<![CDATA[]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>419</wp:post_id>
		<wp:post_date><![CDATA[2019-04-18 09:59:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-18 01:59:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[qq%e6%88%aa%e5%9b%be20190418095857]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
						<wp:attachment_url><![CDATA[https://blog.easysc.cn/wp-content/uploads/2019/04/QQ截图20190418095857.png]]></wp:attachment_url>
											<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
		<wp:meta_value><![CDATA[2019/04/QQ截图20190418095857.png]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:5:{s:5:"width";i:298;s:6:"height";i:228;s:4:"file";s:34:"2019/04/QQ截图20190418095857.png";s:5:"sizes";a:1:{s:9:"thumbnail";a:4:{s:4:"file";s:34:"QQ截图20190418095857-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				使用jekins部署项目（war包方式）		</title>
		<link>https://blog.easysc.cn/?p=95</link>
		<pubDate>Fri, 19 Oct 2018 00:49:04 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=95</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： Jenkins

<a href="https://jenkins.io/">Jenkins官网</a>

<hr />

<h2>启动Jekins</h2>

到Jenkins官网下载war包，可以直接通过jar包启动，默认端口是8080，war包中自带jetty，可以通过下面方式修改启动的端口

<pre><code>java -jar jenkins.war --httpPort=8020
</code></pre>

也可以将war包放到tomcat下启动

<h2>登录Jekins</h2>

第一次启动的时，Jenkins会自动生成一个密码，在日志文件中，这个密码作为默认账号admin的默认密码，参考
<a href="https://jenkins.io/doc/book/installing/">Jekins官方文档中war包部分</a>，如果没有看到，可以在当前用户文件夹下的<code>.jenkins\secrets</code>下的<code>initialAdminPassword</code>这个文件中查找到（注windows和linux一样，linux中<code>.jenkins</code>可能是隐藏的）

<h2>使用Jenkins构建项目(maven)</h2>

<h3>构建准备</h3>

因为是maven项目，所以要在安装jekin的系统中安装git(如果是git)，maven，jdk并把他们的位置配置到

<pre><code>系统管理---全局工具配置(Globel tools)--将对于工具的路径配置进去，自动配置暂时不知道什么用，点了没效果
</code></pre>

<img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/jenkins/%E5%85%A8%E5%B1%80%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE.png" alt="全局工具配置" />
工具配置好了之后还要准备一些插件
Maven Integration plugin 用于构建maven项目
Git plugin git的插件
通过

<pre><code>系统管理---插件管理---可选插件
</code></pre>

搜索安装，已安装忽略此步

<h3>构建配置</h3>

以上步骤准备好之后

<pre><code>新建---输入项目名---构建一个maven项目
</code></pre>

<h4>源码管理</h4>

这里以git项目构建，svn类似
源码管理部分选择git,填入git的地址，填入之后，会自动测试，如果是报类似无法使用xxx命令，一般是git没装好（注：无法使用https也是，这种把git删了，重新完整的安装之后就可以了），如果提示没有权限
点击下面Credentials旁的add添加身份认证信息，如果有可以直接选，都正确情况下就不会存在红字。

<h4>build</h4>

Goals and options 填入maven构建的命令即可，如clean package

<h4>Post Steps</h4>

这里可以选择构建成功后执行的操作，上面有几个选项，表示执行的时间

<pre><code>Run only if build succeeds 构建成功时执行
Run only if build succeeds or is unstable 构建成功或者不稳定时执行
Run regardless of build result 不管构建结果如何都执行
</code></pre>

add选项中第一个选项是用在windows系统中执行命令的，第二个是用在linux中执行shell命令的，可以将执行的命令单独写在一个可执行文件中，如windos的bat，linux的sh文件（执行前记得先给文件授权(<code>chmod 777 文件</code>)），在这里填写执行命令
<img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/jenkins/postSteps.png" alt="s" />

<h4>开始构建</h4>

配置好之后点击保存,可以在my views中查看新建的项目，点击立即构建，就可以开始构建项目了，点击左边
<code>构建执行状态</code>下的进度条，可以查看输出的控制台信息

<h2>设置构建邮件通知</h2>

用于构建过程中的邮件通知（成功失败都会通知）

<h3>设置发送邮箱信息</h3>

操作之前，要安装一些邮件的插件（一般在安装Jenkins的时候都会安装，如果勾选的话），具体百度

<pre><code>系统管理---系统设置---邮件通知
</code></pre>

填写stmp邮件服务器，如163邮箱的<code>smtp.163.com</code>每个邮件服务器的stmp不同，这个可以在网上查找，另外要实现用stmp服务，要先在对应的邮箱中开启stmp服务并设置密码，填写好之后点击高级，填写开启stmp服务的账户名和密码，最好勾选ssl协议，有些邮箱不用ssl协议不会通过，端口和用户默认后缀可以不填。
填写好之后，可以勾选<code>通过发送测试邮件测试配置</code>，填写发送的邮箱来测试填写的内容是否正确。

<h3>项目中设置要发送的邮箱</h3>

设置需要发送邮件的项目在<code>构建设置</code>中勾选<code>E-mail Notification</code>下面有几个错误的情况通知，根据情况自己选择，填入需要发送的邮箱就可以了

<h2>远程构建</h2>

<h3>构建前配置</h3>

可以参考：<a href="http://blog.csdn.net/russ44/article/details/51694074">使用shell脚本部署到远程服务器</a>
在可选插件中安装<code>publish over ssh</code>插件，安装之后打开系统设置
在publish over ssh部分，展开高级选项配置ssh server

<pre><code>Name 这里可以随便填写
HostName 填写要连接的服务器ip或者名称
UserName 要登录的用户
Remote Directory 远程服务器文件目录
勾选 Use password authentication, or use a different key
Passphrase / Password 填写上方用户名的密码
</code></pre>

其他部分可以不管，具体可以自行研究

<h3>项目设置</h3>

在项目设置的构建环境处勾选

<pre><code>Send files or execute commands over SSH after the build runs
//在构建之后发送文件或执行命令
</code></pre>

点击add Transfers

<pre><code>Source files 要拷贝的文件，这里是可以填相对路径(相对于项目的位置，如target/*.war)，也可以填绝对路径
Remove prefix 移除前缀 可以不填
Remote directory 远程目录，如果填相对的路径是相对于之前系统设置中的路径的
Exec command 要执行的命令，高版本Jenkins会要求填，但是可以不管
</code></pre>

配置好之后保存，重新构建下就可以了

<h2>遇到的问题</h2>

linux构建时tomcat启动随jenkin执行命令的结束而停止，导致tomcat启动不成功解决方法在执行的shell命令前加入

<pre><code>export BUILD_ID=aaaa
//BUILD_ID为任意值
</code></pre>

构建最后报错
Maven JVM terminated unexpectedly with exit code 137
原因：http://blog.csdn.net/mzh1992/article/details/62432330]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>95</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 08:49:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 00:49:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bd%bf%e7%94%a8jekins%e9%83%a8%e7%bd%b2%e9%a1%b9%e7%9b%ae%ef%bc%88war%e5%8c%85%e6%96%b9%e5%bc%8f%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<category domain="post_tag" nicename="%e6%9d%82"><![CDATA[杂]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				JSP		</title>
		<link>https://blog.easysc.cn/?p=97</link>
		<pubDate>Fri, 19 Oct 2018 00:51:00 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=97</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： Jsp
参考：<a href="https://www.runoob.com/jsp/jsp-syntax.html">菜鸟教程</a>

<hr />

<h2>脚本程序</h2>

<pre><code>&lt;% 代码片段 %&gt;
</code></pre>

示例代码

<pre><code class="line-numbers">&lt;html&gt;
&lt;head&gt;&lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
Hello World!&lt;br/&gt;
&lt;%
out.println("Your IP address is " + request.getRemoteAddr());
%&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

中文编码

<pre><code class="line-numbers">&lt;%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%&gt;
</code></pre>

注：脚本程序中不能包含任何的文本，HTML标签，和JSP元素，如if写法

<pre><code class="line-numbers">&lt;% if (day == 1 | day == 7) { %&gt;
      &lt;p&gt;今天是周末&lt;/p&gt;
&lt;% } else { %&gt;
      &lt;p&gt;今天不是周末&lt;/p&gt;
&lt;% } %&gt;
</code></pre>

<h2>JSP声明</h2>

<pre><code>&lt;%! declaration; [ declaration; ]+ ... %&gt;
</code></pre>

示例：

<pre><code class="line-numbers">&lt;%!
    private int initVar=0;
    private int serviceVar=0;
    private int destroyVar=0;
%&gt;

&lt;%!
    public void jspInit(){
        initVar++;
        System.out.println("jspInit(): JSP被初始化了"+initVar+"次");
    }
    public void jspDestroy(){
        destroyVar++;
        System.out.println("jspDestroy(): JSP被销毁了"+destroyVar+"次");
    }
%&gt;

&lt;%
    serviceVar++;
    System.out.println("_jspService(): JSP共响应了"+serviceVar+"次请求");

    String content1="初始化次数 : "+initVar;
    String content2="响应客户请求次数 : "+serviceVar;
    String content3="销毁次数 : "+destroyVar;
%&gt;
</code></pre>

<h2>JSP注释方式及其含义</h2>

<img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/noteimage/jsp%E6%B3%A8%E9%87%8A%E8%AF%AD%E6%B3%95.png" alt="注释" />
##JSP表达式

<blockquote>
  一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。
  由于表达式的值会被转化成String，所以您可以在一个文本行中使用表达式而不用去管它是否是HTML标签。
  表达式元素中可以包含任何符合Java语言规范的表达式，但是不能使用分号来结束表达式。
</blockquote>

<pre><code>&lt;%= 表达式 %&gt;
</code></pre>

示例：

<pre><code>   今天的日期是: &lt;%= (new java.util.Date()).toLocaleString()%&gt;
</code></pre>

<h2>JSP的内置对象</h2>

<img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/noteimage/jsp%E9%9A%90%E5%90%AB%E5%AF%B9%E8%B1%A1.png" alt="" />
注：使用的时候要放在代码块中执行]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>97</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 08:51:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 00:51:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[jsp]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="front"><![CDATA[front]]></category>
		<category domain="post_tag" nicename="front"><![CDATA[front]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				Linux		</title>
		<link>https://blog.easysc.cn/?p=101</link>
		<pubDate>Fri, 19 Oct 2018 01:31:48 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=101</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： Linux
引用：<a href="http://www.cnblogs.com/hafiz/p/6686187.html">Linux知识整理</a>

<hr />

<h2>各文件夹的作用</h2>

<pre><code class="line-numbers">       1)./             所有其他目录的最顶级根目录
　　　　2)./home    系统用户的家目录，每个用户在该文件夹下有一个与登录名同名的目录作为该用户的家目录，但是root用户的家目录就在根目录下。
　　　　3)./root　　root用户的家目录
　　　　4)./boot     系统内核和开机必须文件所在目录
　　　　5)./etc       系统配置文件所在目录
　　　　6)./dev      系统所有设备文件所在的目录
　　　　7)./usr(unix system resource) 保存程序的相关文件
　　　　8)./tmp      临时文件所在的目录
　　　　9)./var　　 主要放置系统执行过程中经常变化的文件，例如缓存（cache）或者是随时更改的登录文件（log file）
　　　　10)./opt　  用于存储第三方软件的目录，不过我们还是习惯放在/usr/local下
　　　　11)./bin、/usr/bin        常用的可执行指令文件目录
　　　　12)./sbin    root用户才有权限执行的指令
　　　　13)./lib、/usr/lib、/usr/local/lib    系统可复用类库目录
　　　　14)./mnt、/media        外部设备的mountpoint,当检测到设备接入时会自动产生挂载点
　　　　15)./lost+found        每个分区都会创建一个该目录，用户系统异常时恢复丢失的东西
　　　　16)./proc        系统进程以及网络状态信息目录，在内存中
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>101</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 09:31:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 01:31:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[linux]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="linux"><![CDATA[linux]]></category>
		<category domain="post_tag" nicename="linux"><![CDATA[linux]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				Java线程池和队列		</title>
		<link>https://blog.easysc.cn/?p=103</link>
		<pubDate>Fri, 19 Oct 2018 01:33:52 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=103</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： ThreadPool Queue 多线程 并发
参考：
<a href="http://www.cnblogs.com/kuoAT/p/6714762.html">Java ThreadPool</a>
<a href="https://www.cnblogs.com/superfj/p/7544971.html">由浅入深理解Java线程池及线程池的如何使用</a>

<hr />

<h2>线程池规则</h2>

线程池的线程执行规则跟任务队列有很大的关系。

下面都假设任务队列没有大小限制：

<ul>
<li>如果线程数量&lt;=核心线程数量，那么直接启动一个核心线程来执行任务，不会放入队列中。</li>
<li>如果线程数量>核心线程数，但&lt;=最大线程数，并且任务队列是LinkedBlockingDeque的时候，超过核心线程数量   的任务会放在任务队列中排队。</li>
<li>如果线程数量>核心线程数，但&lt;=最大线程数，并且任务队列是SynchronousQueue的时候，线程池会创建新线程   执行任务，这些任务也不会被放在任务队列中。这些线程属于非核心线程，在任务完成后，闲置时间达到了超时时间就会被清除。</li>
<li>如果线程数量>核心线程数，并且>最大线程数，当任务队列是LinkedBlockingDeque，会将超过核心线程的任务   放在任务队列中排队。也就是当任务队列是LinkedBlockingDeque并且没有大小限制时，线程池的最大线程数设   置是无效的，他的线程数最多不会超过核心线程数。</li>
<li>如果线程数量>核心线程数，并且>最大线程数，当任务队列是SynchronousQueue的时候，会因为线程池拒绝添加   任务而抛出异常。</li>
</ul>

任务队列大小有限时

<ul>
<li>当LinkedBlockingDeque塞满时，新增的任务会直接创建新线程来执行，当创建的线程数量超过最大线程数量时会抛异常。</li>
<li>SynchronousQueue没有数量限制。因为他根本不保持这些任务，而是直接交给线程池去执行。当任务数量超过最大线程数时会直接抛异常。</li>
</ul>

<hr />

<h2>任务缓存队列</h2>

在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。

workQueue的类型为BlockingQueue<Runnable>，通常可以取下面三种类型：

<ul>
<li><p>有界任务队列ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；</p></li>
<li><p>无界任务队列LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</p></li>
<li><p>直接提交队列synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务</p></li>
</ul>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>103</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 09:33:52]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 01:33:52]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[java%e7%ba%bf%e7%a8%8b%e6%b1%a0%e5%92%8c%e9%98%9f%e5%88%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="various"><![CDATA[杂]]></category>
		<category domain="post_tag" nicename="%e6%9d%82"><![CDATA[杂]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				RESTful风格		</title>
		<link>https://blog.easysc.cn/?p=105</link>
		<pubDate>Fri, 19 Oct 2018 01:34:40 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=105</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： RESTful
参考：<a href="https://www.zhihu.com/question/28557115">怎样用通俗的语言解释REST</a>
　　　<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html">理解RESTful架构</a>
　　　<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">Roy Fielding的毕业论文-REST章节</a>
　　　<a href="https://blog.igevin.info/posts/restful-architecture-in-general/">RESTful 架构风格概述</a>

<hr />

<h2>REST概念</h2>

REST并不是rest的意思，全称是Representational State Transfer(表现层状态转移)
REST的概念里面有几个特征，<code>Resources</code>，<code>Representational</code>，<code>State Transfer</code>
简单理解如下：

<ul>
<li>资源(Resource)
把所有请求当成对资源的操作，每个url地址对应的就是一个资源的地址，对资源的操作不体现在请求的url上，体现在HTTP请求动词上，如<code>GET</code>，<code>POST</code>，<code>PUT</code>，<code>DELETE</code>，url地址本身只是代表资源的位置，故不能包含动词，引用参考中的例子,<code>:</code>后的为注释

<pre><code>BAD
/getProducts
/listOrders
/retrieveClientByOrder?orderId=1
GOOD
GET /products : will return the list of all products
POST /products : will add a product to the collection
GET /products/4 : will retrieve product 4PATCH/
PUT /products/4 : will update product #4
</code></pre></li>
<li>表现层(Representation)</p></li>
</ul>

<blockquote>
  比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。
</blockquote>

<p>资源的表现形式，即这个资源的格式类型，这个资源是图片，网页，文本，或者是其他的表现形式指定也不想原来一样在url中用xxx.png这种方式呈现，而是使用请求中的HTTP协议的ACCEPT和Content-Type来描述表现层。

<ul>
<li>状态转化
这个状态是资源的状态，使用<code>GET</code>，<code>POST</code>，<code>PUT</code>，<code>DELETE</code>等HTTP协议中的动词去改变资源的状态</li>
</ul>

<h2>使用SpringMVC实现RESTful风格</h2>

参考：<a href="http://blog.csdn.net/w605283073/article/details/51338597"></a>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>105</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 09:34:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 01:34:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[restful%e9%a3%8e%e6%a0%bc]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="various"><![CDATA[杂]]></category>
		<category domain="post_tag" nicename="%e6%9d%82"><![CDATA[杂]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				Redis集群		</title>
		<link>https://blog.easysc.cn/?p=107</link>
		<pubDate>Fri, 19 Oct 2018 01:36:25 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=107</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： Redis

<hr />

<a href="https://ruby-china.org/wiki/rvm-guide">ruby1</a>
<a href="http://www.jianshu.com/p/8169f5d7f364">ruby更新</a>

<h2>集群准备</h2>

Redis的安装不赘述，参考Linux下安装Redis
集群的官方参考文档<a href="https://redis.io/topics/cluster-tutorial">Redis cluster</a>
准备一个redis配置文件redis.conf
修改下面的内容

<pre><code>daemonize yes
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes
</code></pre>

<code>time-out</code>为参考
创建一个文件夹，作为Redis集群

<pre><code>mkdir redis_cluster
</code></pre>

创建几个文件夹，作为单个redis文件存放地，这里使用端口7000-7005作为redis的集群端口

<pre><code>mkdir redis_700{0,1,2,3,4,5}
</code></pre>

将上面的配置文件复制到上面单个redis的文件夹，并修改redis.conf中的<code>port</code>为对应端口，不赘述
分别切换到对应的端口文件夹

<pre><code>redis-server redis_7000/1/2/3/4/5.conf
</code></pre>

启动每个redis
使用<code>ps -ef |grep redis</code>查看会看到

<pre><code>root     17703     1  0         00:00:19 redis-server 0.0.0.0:7000 [cluster]
root     17708     1  0         00:00:19 redis-server 0.0.0.0:7001 [cluster]
root     17713     1  0         00:00:19 redis-server 0.0.0.0:7002 [cluster]
root     17720     1  0         00:00:19 redis-server 0.0.0.0:7003 [cluster]
root     17730     1  0         00:00:19 redis-server 0.0.0.0:7004 [cluster]
root     17735     1  0         00:00:19 redis-server 0.0.0.0:7005 [cluster]
</code></pre>

redis都启动起来了
启动集群，切换到redis的安装目录下的<code>src</code>文件夹
执行

<pre><code>./redis-trib.rb  create --replicas 1 127.0.0.1.41:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005
</code></pre>

注：如果是用外网访问redis的话一定要注意下面几点

<ul>
<li>端口开放
除了开放上面集群的端口，外网访问的时候还要开放集群端口+10000端口，如开放了7000端口，还要开放17000端口</li>
<li>创建用的端口最好是服务器的公网ip，如果这里用127.0.0.1创建集群，会出现JedisCluster连接不上的情况，如果使用公网ip不开放+10000端口会出现<code>Waiting for the cluster to join...</code>一直阻塞的情况</li>
<li>配置文件中的bind属性最好注释掉，这个属性是指定可以访问redis的ip的，需要外网访问的时候要注释掉</li>
<li>配置文件中的<code>protected-mode no</code>保护模式可以关掉，不关掉会提示错误，这里如果bind了ip和设置了密码都可以忽略这个选项</li>
</ul>

如果提示需要ruby，执行下面的命令

<pre><code>yum install ruby
yum install rubygems
</code></pre>

<h2>Ruby安装和更新</h2>

使用上面的方式安装之后会发现ruby的版本为1.8.7，执行

<pre><code>gem install  redis
</code></pre>

会提示

提示执行上面的步骤需要ruby2.2.2的版本，这里可以通过ruby的版本管理工具rvm来升级，也可以去官网下gz包去，配置环境变量指定
安装之前先将yum中的ruby卸载

<pre><code>yum remove -y ruby
</code></pre>

访问<a href="https://rvm.io/">rvm官网</a>
执行

<pre><code>gpg --keyserver hkp：//keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB
</code></pre>

这个是官方提供的用来验证的公钥，以保证安全。

<pre><code>\curl -sSL https://get.rvm.io | bash -s stable
</code></pre>

安装稳定版本的rvm，会在看到下面的语句。

<pre><code>* To start using RVM you need to run `source /etc/profile.d/rvm.sh`
    in all your open shell windows, in rare cases you need to reopen all shell windows.
</code></pre>

执行上面的<code>source /etc/profile.d/rvm.sh</code>刷新就可以使用rvm命令了
列出已知版本

<pre><code>rvm list known
</code></pre>

安装ruby2.3

<pre><code>rvm install 2.3
</code></pre>

rvm支持多个版本的ruby同时在一个系统上，使用

<pre><code>rvm use 2.3 或者 rvm use 2.3 --default 后面这个设置为默认
</code></pre>

切换版本
使用

<pre><code>rvm remove 2.3
</code></pre>

卸载对应版本的ruby

使用安装包的形式安装ruby可以参考<a href="http://blog.csdn.net/coming789/article/details/42193531">安装ruby2.2.2</a>

<h2>集群</h2>

安装和升级好ruby之后

<pre><code>gem install  redis
</code></pre>

在gem中安装redis，后面加<code>-v 版本号</code>可以指定安装的版本，使用<code>gem uninstall redis</code>卸载

如果安装很慢可以添加gem仓库

<pre><code>gem sources -a https://ruby.taobao.org/
gem sources -a https://gems.ruby-china.org/
</code></pre>

使用<code>gem source</code>查看仓库，使用<code>gem source -r url</code>移除，<code>gem sources -u</code>更新
然后再执行

<pre><code>./redis-trib.rb  create --replicas 1 127.0.0.1.41:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005
</code></pre>

就可以看到

<pre><code>&gt;&gt;&gt; Creating cluster
</code></pre>

在创建集群了
一些集群的操作参考：<a href="http://www.cnblogs.com/wxd0108/p/5798332.html">集群命令</a>

<hr />

集群删除节点

<pre><code>./redis-trib.rb del-node [node-id] [node-id]
</code></pre>

这个node-id可以在删除的nodes.conf中看到
也可以连接到集群执行<code>cluster nodes</code>查看集群信息，执行
参考<a href="http://blog.csdn.net/xu470438000/article/details/42972123">redis集群动态增加或者删除节点</a>
一些问题的解决方案参考<a href="http://blog.csdn.net/ownfire/article/details/46624005">集群问题</a>
停掉指定端口的redis

<pre><code>redis-cli -p port shutdown  //port为端口号
</code></pre>

<a href="http://www.mamicode.com/info-detail-1225600.html">集群</a>
<a href="http://hot66hot.iteye.com/blog/2050676">集群</a>

<hr />

访问集群要使用

<pre><code>redis-cli -c -p port
</code></pre>

来访问，如果不行的话需要加上ip

<pre><code>redis-cli -c -h ip -p port
</code></pre>

如果一直出现连接问题，要修改<code>/etc/hosts</code>文件，详见<a href="http://blog.csdn.net/xlgen157387/article/details/52702659">内网ip？？</a>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>107</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 09:36:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 01:36:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[redis%e9%9b%86%e7%be%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="redis"><![CDATA[redis]]></category>
		<category domain="post_tag" nicename="redis"><![CDATA[redis]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				未分类		</title>
		<link>https://blog.easysc.cn/?p=110</link>
		<pubDate>Fri, 19 Oct 2018 01:38:08 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=110</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： 未分类 Spring
引用：<a href="http://blog.csdn.net/maclaren001/article/details/37039749">InitializingBean</a>
　　　<a href="http://www.cnblogs.com/ghj1976/p/5383743.html">Spring Bean的生命周期</a>
　　　<a href="http://www.cnblogs.com/winkey4986/p/5424892.html">InitializingBean和ApplicationListener</a>

<hr />

<h2>InitializingBean接口</h2>

<blockquote>
  InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候会执行该方法。
  问题：实现InitializingBean接口与在配置文件中指定init-method有什么不同？
  在spring初始化bean的时候，如果该bean是实现了InitializingBean接口，并且同时在配置文件中指定了init-method，系统则是先调用afterPropertiesSet方法，然后再调用init-method中指定的方法。
  　　在spring 初始化后，执行完所有属性设置方法(即setXxx)将自动调用 afterPropertiesSet(), 在配置文件中无须特别的配置
</blockquote>

注：初始需要依赖的方法时如<code>init()</code>可以使用这个方法，如果在构造方法中调用，根据Spring的加载顺序，依赖可能还没加载好，可能会报<code>NullPointException</code>

<hr />

##ApplicationListener&lt;>接口
这个<code>&lt;&gt;</code>里面的内容是<code>E extends ApplicationEvent</code>是一个继承了ApplicationEvent的类,一般是写<code>ContextRefreshedEvent</code>，在Spring类加载完（不包含依赖）后执行，当一个ApplicationContext被初始化或刷新时触发。

注：初始需要依赖的方法时如<code>init()</code>可以使用这个方法，如果在构造方法中调用，根据Spring的加载顺序，依赖可能还没加载好，可能会报<code>NullPointException</code>

<blockquote>
  如果在上下文中部署一个实现了ApplicationListener接口的bean,  那么每当在一个ApplicationEvent发布到
  ApplicationContext时，  这个bean得到通知
</blockquote>

<pre><code class="language-java line-numbers">@Component
public class InitTestBean implements ApplicationListener&lt;ContextRefreshedEvent&gt;,InitializingBean {
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("afterPropertiesSet 执行");
    }

    public InitTestBean() {
        System.out.println("无参构造方法执行！");
    }

    @Override
    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {
        System.out.println("onApplicationEvent 执行");
    }
}
</code></pre>

结果如下：

<pre><code class="line-numbers">无参构造方法执行！
afterPropertiesSet 执行
onApplicationEvent 执行
</code></pre>

<h2>Spring Bean</h2>

参考：<a href="http://blog.csdn.net/ochangwen/article/details/52556474">Spring Bean详解</a>
　　　<a href="http://www.cnblogs.com/xrq730/p/6285358.html">Spring Bean的加载过程</a>

<h2>JS</h2>

<h3><a href="http://www.w3school.com.cn/jsref/dom_obj_window.asp">Window 对象属性</a></h3>

<table class="dataintable">
  <tbody><tr>
    <th style="width:25%">属性</th>
    <th>描述</th>
  </tr>
  <tr>
    <td><a href="http://www.w3school.com.cn/jsref/prop_win_closed.asp">closed</a></td>
    <td>返回窗口是否已被关闭。</td>
  </tr>
  <tr>
    <td><a href="http://www.w3school.com.cn/jsref/prop_win_defaultstatus.asp">defaultStatus</a></td>
    <td>设置或返回窗口状态栏中的默认文本。</td>
  </tr>
  <tr>
    <td><a href="http://www.w3school.com.cn/jsref/dom_obj_document.asp">document</a></td>
    <td>对 Document 对象的只读引用。请参阅 <a href="dom_obj_document.asp">Document 对象</a>。</td>
  </tr>
  <tr>
    <td><a href="http://www.w3school.com.cn/jsref/dom_obj_history.asp">history</a></td>
    <td>对 History 对象的只读引用。请参数 <a href="dom_obj_history.asp">History 对象</a>。</td>
  </tr>
  <tr>
    <td><a href="http://www.w3school.com.cn/jsref/prop_win_innerheight_innerwidth.asp">innerheight</a></td>
    <td>返回窗口的文档显示区的高度。</td>
  </tr>
  <tr>
    <td><a href="http://www.w3school.com.cn/jsref/prop_win_innerheight_innerwidth.asp">innerwidth</a></td>
    <td>返回窗口的文档显示区的宽度。</td>
  </tr>
  <tr>
    <td>length</td>
    <td>设置或返回窗口中的框架数量。</td>
  </tr>
  <tr>
    <td><a href="http://www.w3school.com.cn/jsref/dom_obj_location.asp">location</a></td>
    <td>用于窗口或框架的 Location 对象。请参阅 <a href="dom_obj_location.asp">Location 对象</a>。</td>
  </tr>
  <tr>
    <td><a href="http://www.w3school.com.cn/jsref/prop_win_name.asp">name</a></td>
    <td>设置或返回窗口的名称。</td>
  </tr>
  <tr>
    <td><a href="http://www.w3school.com.cn/jsref/dom_obj_navigator.asp">Navigator</a></td>
    <td>对 Navigator 对象的只读引用。请参数 <a href="/jsref/dom_obj_navigator.asp">Navigator 对象</a>。</td>
  </tr>
  <tr>
    <td><a href="http://www.w3school.com.cn/jsref/prop_win_opener.asp">opener</a></td>
    <td>返回对创建此窗口的窗口的引用。</td>
  </tr>
  <tr>
    <td><a href="http://www.w3school.com.cn/jsref/prop_win_outerheight.asp">outerheight</a></td>
    <td>返回窗口的外部高度。</td>
  </tr>
  <tr>
    <td><a href="http://www.w3school.com.cn/jsref/prop_win_outerwidth.asp">outerwidth</a></td>
    <td>返回窗口的外部宽度。</td>
  </tr>
  <tr>
    <td>pageXOffset</td>
    <td>设置或返回当前页面相对于窗口显示区左上角的 X 位置。</td>
  </tr>
  <tr>
    <td>pageYOffset</td>
    <td>设置或返回当前页面相对于窗口显示区左上角的 Y 位置。</td>
  </tr>
  <tr>
    <td>parent</td>
    <td>返回父窗口。</td>
  </tr>
  <tr>
    <td><a href="http://www.w3school.com.cn/jsref/dom_obj_screen.asp">Screen</a></td>
    <td>对 Screen 对象的只读引用。请参数 <a href="/jsref/dom_obj_screen.asp">Screen 对象</a>。</td>
  </tr>
  <tr>
    <td><a href="http://www.w3school.com.cn/jsref/prop_win_self.asp">self</a></td>
    <td>返回对当前窗口的引用。等价于 Window 属性。</td>
  </tr>
  <tr>
    <td><a href="http://www.w3school.com.cn/jsref/prop_win_status.asp">status</a></td>
    <td>设置窗口状态栏的文本。</td>
  </tr>
  <tr>
    <td><a href="http://www.w3school.com.cn/jsref/prop_win_top.asp">top</a></td>
    <td>返回最顶层的先辈窗口。</td>
  </tr>
  <tr>
    <td>window</td>
    <td>window 属性等价于 self 属性，它包含了对窗口自身的引用。</td>
  </tr>
  <tr>
    <td>
    <ul>
    <li>screenLeft</li>
    <li>screenTop</li>
    <li>screenX</li>
    <li>screenY</li>
    </ul>
    </td>
    <td>只读整数。声明了窗口的左上角在屏幕上的的 x 坐标和 y 坐标。IE、Safari 和 Opera 支持 screenLeft 和 screenTop，而 Firefox 和 Safari 支持 screenX 和 screenY。</td>
  </tr>
  </tbody></table>

<a href="http://www.jb51.net/article/44078.htm">常用的window</a>

<h3><a href="http://www.w3school.com.cn/jsref/dom_obj_location.asp">location</a></h3>

<pre><code>window.location = "https://www.baidu.com" //跳转到百度
window.location.href = = "https://www.baidu.com" //跳转到百度
window.location.reload();   //重新加载当前页面
window.top.location = "https://www.baidu.com" //跳出框架，最上层window跳转到百度
</code></pre>

<h3><a href="http://www.w3school.com.cn/js/pro_js_object_defining.asp">方法定义</a></h3>

<h3><a href="http://www.cnblogs.com/qixiaoyizhan/p/5864233.html">Spring MVC RESTful风格</a></h3>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>110</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 09:38:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 01:38:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%9c%aa%e5%88%86%e7%b1%bb]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="various"><![CDATA[杂]]></category>
		<category domain="post_tag" nicename="%e6%9d%82"><![CDATA[杂]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				Spring 配置		</title>
		<link>https://blog.easysc.cn/?p=112</link>
		<pubDate>Fri, 19 Oct 2018 01:38:49 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=112</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： Spring 配置
引用：<a href="http://blog.csdn.net/chyohn/article/details/54945777">property-placeholder/override</a>
　　　<a href="http://www.cnblogs.com/hafiz/p/5876243.html">读取property文件的方式</a>

<hr />

<h2>Context</h2>

<pre data-language=XML><code class="language-markup line-numbers">    &lt;!--注解支持--&gt;
    &lt;context:annotation-config /&gt;
    &lt;!--扫描的包--&gt;
    &lt;context:component-scan base-package="cn.ws.test"/&gt;
    &lt;context:component-scan base-package="cn.ws.handle"&gt;
        &lt;context:exclude-filter type="regex" expression=".."/&gt;
        &lt;context:include-filter type="annotation" expression="cn.ws.annotation.AccessCheck"/&gt;
    &lt;/context:component-scan&gt;
</code></pre>

这里<code>component-scan</code>中包含两个属性，一个是<code>exclude-filter</code>不包含
<code>include-filter</code>包含
里面的<code>type</code>属性对应有四种

<ul>
<li><code>annotation</code>
表示过滤方式为注解，含有后面expression注解的都会被过滤掉
expression示例：<code>cn.ws.annotation.AccessCheck</code></li>
<li><code>regex</code>
以正则表达式的方式过滤
expression示例：com.\ws&#92;..*</li>
<li><code>assignable</code>
以继承和实现的方式过滤，所有继承或者实现了后面expression的都会被过滤
expression示例：<code>java.util.HashMap</code></li>
<li><code>aspectj</code>
以Aspectj表达式的方式过滤
expression示例：</li>
<li><code>custom</code>
自定义TypeFilter过滤规则，写一个类，这个类必须实现<code>org.springframework.core.type.TypeFilter</code>接口
expression示例：<code>cn.ws.MyTypeFilter</code></li>
</ul>

<pre data-language=XML><code class="language-markup line-numbers">    &lt;context:property-override file-encoding="utf-8" ignore-unresolvable="true" location="classpath:spring/test.properties"/&gt;
    &lt;context:property-placeholder location="classpath:spring/test.properties" file-encoding="utf-8" ignore-unresolvable="true"/&gt;
</code></pre>

<code>property-placeholder</code>可以读取properties文件
另外通过下面的方式也可以读取

<pre data-language=XML><code class="language-markup line-numbers">&lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
   &lt;property name="ignoreUnresolvablePlaceholders" value="true"/&gt;
   &lt;property name="locations"&gt;
      &lt;list&gt;
         &lt;value&gt;classpath:test.properties&lt;/value&gt;
         &lt;value&gt;classpath:test1.properties&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<blockquote>
  注意：这种方式下，如果你在spring-mvc.xml文件中有如下配置，则一定不能缺少下面的红色部分，<a href="http://www.cnblogs.com/hafiz/p/5875770.html">原因</a>
</blockquote>

详细参考：<a href="http://www.cnblogs.com/hafiz/p/5876243.html">spring获取property</a>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>112</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 09:38:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 01:38:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[spring-%e9%85%8d%e7%bd%ae]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="spring"><![CDATA[spring]]></category>
		<category domain="post_tag" nicename="spring"><![CDATA[spring]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				Tomcat优化		</title>
		<link>https://blog.easysc.cn/?p=114</link>
		<pubDate>Fri, 19 Oct 2018 01:40:27 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=114</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： Tomcat 优化
引用：<a href="http://blog.csdn.net/u012562943/article/details/51441157">Tomcat优化</a>

<hr />

<h2>内存优化</h2>

<h3>优化</h3>

出现下面情况的时候，说明tomcat使用的内存不能支持访问了，需要进行内存优化

<pre><code>严重: Exception invoking periodic operation: java.lang.OutOfMemoryError: Java heap space  
严重: Error processing request java.lang.OutOfMemoryError: GC overhead limit exceeded  
</code></pre>

修改tomcat目录下<code>/bin/catalina.sh(Linux)</code>或者<code>/bin/catalina.bat(Windows)</code>文件
Linux下修改，可以放在CLASSPATH=下面：

<pre><code>JAVA_OPTS="-server -XX:PermSize=512M -XX:MaxPermSize=1024m -Xms2048m -Xmx2048m"
</code></pre>

windows下修改，可以放在set CLASSPATH=下面：

<pre><code>set JAVA_OPTS=-server -XX:PermSize=512M -XX:MaxPermSize=1024m -Xms2048m -Xmx2048m
</code></pre>

参数配置如下：

<pre><code>-server：启用 JDK的 server 版本；
-Xms：Java虚拟机初始化时堆的最小内存，一般与Xmx配置为相同值，这样的好处是GC不必再为扩展内存空间而消耗性能；
-Xmx：Java虚拟机可使用堆的最大内存；
-XX:PermSize：Java虚拟机永久代大小；
-XX:MaxPermSize：Java虚拟机永久代大小最大值；
</code></pre>

除了这些参数外还可以根据具体需要配置其他参数，参数的配置可以参考JVM参数的配置

<h3>验证</h3>

使用JAVA_HOME/bin目录下的两个工具

<pre><code>jps：用来显示本地的java进程，以及进程号，进程启动的路径等。
jmap：观察运行中的JVM 物理内存的占用情况，包括Heap size , Perm size等。
</code></pre>

配置了环境变量可以直接打开cmd输入jps(没有先跳转到JAVA_HOME/bin)，会出现下面的情况

<pre><code class="line-numbers">6112 BootStrap
6640 Jre
856 RemoteMavenServer
</code></pre>

这里的BootStrap对应的就是tomcat,6112是进程号
输入<code>jmap -heap 6112</code>查看
<code>PermSize //永久代大小</code>

<pre><code class="line-numbers">Attaching to process ID 6112, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.131-b11

using thread-local object allocation.
Parallel GC with 4 thread(s)

Heap Configuration:
   MinHeapFreeRatio         = 0
   MaxHeapFreeRatio         = 100
   MaxHeapSize              = 2147483648 (2048.0MB) //最大堆内存
   NewSize                  = 715653120 (682.5MB)
   MaxNewSize               = 715653120 (682.5MB)
   OldSize                  = 1431830528 (1365.5MB)
   NewRatio                 = 2
   SurvivorRatio            = 8
   MetaspaceSize            = 21807104 (20.796875MB)
   CompressedClassSpaceSize = 1073741824 (1024.0MB)
   MaxMetaspaceSize         = 17592186044415 MB
   G1HeapRegionSize         = 0 (0.0MB)

Heap Usage:
PS Young Generation
Eden Space:
   capacity = 537395200 (512.5MB)
   used     = 247226456 (235.77352142333984MB)
   free     = 290168744 (276.72647857666016MB)
   46.00458954601753% used
From Space:
   capacity = 89128960 (85.0MB)
   used     = 0 (0.0MB)
   free     = 89128960 (85.0MB)
   0.0% used
To Space:
   capacity = 89128960 (85.0MB)
   used     = 0 (0.0MB)
   free     = 89128960 (85.0MB)
   0.0% used
PS Old Generation
   capacity = 1431830528 (1365.5MB)
   used     = 0 (0.0MB)
   free     = 1431830528 (1365.5MB)
   0.0% used

12256 interned Strings occupying 1742568 bytes.

</code></pre>

<hr />

<h2>配置优化</h2>

通过<code>server.xml</code>来优化配置

<h3>Connector连接器优化</h3>

<pre data-language=XML><code class="language-markup line-numbers">&lt;Connector port="80" protocol="HTTP/1.1"
               connectionTimeout="20000"
               redirectPort="8443" /&gt;
</code></pre>

设置官方参考<a href="http://tomcat.apache.org/tomcat-8.5-doc/config/http.html">Tomcat8.5配置</a>
常用的一些属性（以下引用自<a href="http://blog.csdn.net/u012562943/article/details/51441157">Tomcat优化</a>）：

<blockquote>
  <code>port</code>：代表Tomcat监听端口，也就是网站的访问端口，默认为8080，可以根据需要改成其他
  <code>protocol</code>：协议类型，可选类型有四种，分别为BIO（阻塞型IO），NIO，NIO2和APR，Tomcat在默认情况下，是以bio模式运行的。遗憾的是，就一般而言，bio模式是三种运行模式中性能最低的一种。BIO配置采用默认即可
  <code>maxThreads</code>：由该连接器创建的处理请求线程的最大数目，也就是可以处理的同时请求的最大数目。如果未配置默认值为200。如果一个执行器与此连接器关联，则忽略此属性，因为该属性将被忽略，所以该连接器将使用执行器而不是一个内部线程池来执行任务。
  <code>minSpareThreads</code>：线程的最小运行数目，这些始终保持运行。如果未指定，默认值为10。
  <code>acceptCount</code>：当所有可能的请求处理线程都在使用时传入连接请求的最大队列长度。如果未指定，默认值为100。一般是设置的跟maxThreads一样或一半，此值设置的过大会导致排队的请求超时而未被处理。所以这个值应该是主要根据应用的访问峰值与平均值来权衡配置。
  <code>maxConnections</code>：在任何给定的时间内，服务器将接受和处理的最大连接数。当这个数字已经达到时，服务器将接受但不处理，等待进一步连接。NIO与NIO2的默认值为10000，APR默认值为8192。
  <code>connectionTimeout</code>：当请求已经被接受，但未被处理，也就是等待中的超时时间。单位为毫秒，默认值为60000。通常情况下设置为30000。
  <code>maxHttpHeaderSize</code>：请求和响应的HTTP头的最大大小，以字节为单位指定。如果没有指定，这个属性被设置为8192（8 KB）。
  <code>tcpNoDelay</code>：如果为true，服务器socket会设置TCP_NO_DELAY选项，在大多数情况下可以提高性能。缺省情况下设为true。
  <code>compression</code>：是否启用gzip压缩，默认为关闭状态。这个参数的可接受值为“off”（不使用压缩），“on”（压缩文本数据），“force”（在所有的情况下强制压缩）。
  <code>compressionMinSize</code>：如果compression="on"，则启用此项。被压缩前数据的最小值，也就是超过这个值后才被压缩。如果没有指定，这个属性默认为“2048”（2K），单位为byte。
  <code>disableUploadTimeout</code>：这个标志允许servletContainer在一个servlet执行的时候，使用一个不同的，更长的连接超时。最终的结果是给servlet更长的时间以便完成其执行，或者在数据上载的时候更长的超时时间。如果没有指定，设为false。
  <code>enableLookups</code>：关闭DNS反向查询。
  <code>URIEncoding</code>：URL编码字符集。
</blockquote>

<pre><code class="line-numbers">&lt;Connector port="8080"   
          protocol="HTTP/1.1"   
          maxThreads="1000"   
          minSpareThreads="100"   
          acceptCount="1000"  
          maxConnections="1000"  
          connectionTimeout="20000"   
          maxHttpHeaderSize="8192"  
          tcpNoDelay="true"  
          compression="on"  
          compressionMinSize="2048"  
          disableUploadTimeout="true"  
          redirectPort="8443"  
      enableLookups="false"  
          URIEncoding="UTF-8" /&gt;
</code></pre>

<pre><code class="line-numbers">compressableMimeType="text/html,text/xml,text/javascript,text/css,text/plain"
</code></pre>

<hr />

<h3>线程池</h3>

<pre><code class="line-numbers">&lt;Executor name="tomcatThreadPool"   
         namePrefix="catalina-exec-"   
         maxThreads="1000"   
         minSpareThreads="100"  
         maxIdleTime="60000"  
         maxQueueSize="Integer.MAX_VALUE"  
         prestartminSpareThreads="false"  
         threadPriority="5"  
         className="org.apache.catalina.core.StandardThreadExecutor"/&gt;
</code></pre>

<blockquote>
  <code>name</code>：线程池名称，用于 Connector中指定。 namePrefix：所创建的每个线程的名称前缀，一个单独的线程名称为
  namePrefix+threadNumber。 
  <code>maxThreads</code>：池中最大线程数。
  <code>minSpareThreads</code>：活跃线程数，也就是核心池线程数，这些线程不会被销毁，会一直存在。
  <code>maxIdleTime</code>：线程空闲时间，超过该时间后，空闲线程会被销毁，默认值为6000（1分钟），单位毫秒。
  <code>maxQueueSize</code>：在被执行前最大线程排队数目，默认为Int的最大值，也就是广义的无限。除非特殊情况，这个值不需要更改，否则会有请求不会被处理的情况发生。
  <code>prestartminSpareThreads</code>：启动线程池时是否启动 minSpareThreads部分线程。默认值为false，即不启动。
  <code>threadPriority</code>：线程池中线程优先级，默认值为5，值从1到10。
  <code>className</code>：线程池实现类，未指定情况下，默认实现类为org.apache.catalina.core.StandardThreadExecutor。如果想使用自定义线程池首先需要实现<code>org.apache.catalina.Executor</code>接口。
</blockquote>

线程池配置完成后需要在 Connector中指定：

<pre><code>&lt;Connector executor="tomcatThreadPool"
...
</code></pre>

<hr />

<h2>组件优化</h2>

<h3>APR</h3>

<blockquote>
  概念:APR(Apache Portable Runtime)是一个高可移植库，它是Apache HTTP Server
  2.x的核心。APR有很多用途，包括访问高级 IO功能(例如sendfile,epoll和OpenSSL)，OS级别功能(随机数生成，系统状态等等)，本地进程管理(共享内存，NT管道和UNIX sockets)。这些功能可以使Tomcat作为一个通常的前台WEB服务器，能更好地和其它本地web技术集成，总体上让Java更有效率作为一个高性能web服务器平台而不是简单作为后台容器。
</blockquote>

下载安装参考引用内容

<h2>性能测试</h2>

使用压力测试工具做性能测试。如：Jmeter]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>114</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 09:40:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 01:40:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[tomcat%e4%bc%98%e5%8c%96]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="various"><![CDATA[杂]]></category>
		<category domain="post_tag" nicename="%e6%9d%82"><![CDATA[杂]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				WebService		</title>
		<link>https://blog.easysc.cn/?p=116</link>
		<pubDate>Fri, 19 Oct 2018 01:42:07 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=116</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： WebService

<hr />

概念：
Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。
<img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/noteimage/webservice%E5%8E%9F%E7%90%86.png" alt="webservice原理" />
webservice用到的技术主要有XML+XSD，SOAP和WSDL，XML Schema(XSD)定义了一套标准的数据类型，并给出了一种语言来扩展这套数据类型
完整的流程如下
客户端——> 阅读WSDL文档 (根据文档生成SOAP请求) ——>发送到Web服务器——>交给WebService请求处理器 （ISAPI Extension）

——>处理SOAP请求——> 调用WebService——>生成SOAP应答 ——> Web服务器通过http的方式交给客户端

<hr />

<h2>了解</h2>

<h3>WSDL</h3>

WSDL(Web Servie Description Language)是一个基于xml的web service描述语言

<blockquote>
  WSDL 是一种使用 XML 编写的文档。这种文档可描述某个 Web service。它可规定服务的位置，以及此服务提供的操作（或方法）。
</blockquote>

WSDL通过下面几个参数描述webservice

| 元素      | 定义                       |
| --------- | -------------------------- |
| <message> | web service 使用的消息     |
| <types>   | web service 使用的数据类型 |
| <binding> | web service 使用的通信协议 |
<img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/noteimage/wsdl.png" alt="wsdl" />

<h3>SOAP协议</h3>

SOAP(Simple Object Access Protocol)基于xml和HTTP的简单对象交换协议

webService三要素

<blockquote>
  SOAP、WSDL(WebServicesDescriptionLanguage)、UDDI(UniversalDescriptionDiscovery
  andIntegration)之一， soap用来描述传递信息的格式， WSDL 用来描述如何访问具体的接口，
  uddi用来管理，分发，查询webService 。具体实现可以搜索 Web Services简单实例 ; SOAP
  可以和现存的许多因特网协议和格式结合使用，包括超文本传输协议（HTTP），简单邮件传输协议（SMTP），多用途网际邮件扩充协议（MIME）。它还支持从消息系统到远程过程调用（RPC）等大量的应用程序。SOAP使用基于XML的数据结构和超文本传输协议(HTTP)的组合定义了一个标准的方法来使用Internet上各种不同操作环境中的分布式对象。
</blockquote>

webservice的开发主要是服务端和客户端，服务端发布服务，客户端调用服务。

<h3>UDDI注册中心</h3>

<blockquote>
  UDDI 是一种目录服务，企业可以使用它对 Web services 进行注册和搜索。 UDDI，英文为 "Universal
  Description, Discovery and Integration"，可译为“通用描述、发现与集成服务”。 UDDI
  是一个独立于平台的框架，用于通过使用 Internet 来描述服务，发现企业，并对企业服务进行集成
</blockquote>

简而言之就是一个webservice的注册中心，当需要一个webservice的服务的时候可以到UDDI去寻找，并调用对应的服务。也可以直接告诉webservice的地址就可以调用了

<hr />

<h2>发布前准备</h2>

一个用于WebService的类

<pre><code class="language-java line-numbers">import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.jws.WebService;
import javax.jws.soap.SOAPBinding;
import javax.xml.ws.BindingType;

@WebService(targetNamespace = Constants.NSPACE)
@BindingType()
public interface HelloCxfInterface {
    //@WebService是必须的；@WebParam不是必须的。
    //如果没有@WebParam的描述，在wsdl文件内描述的方法中，参数名将变为arg0,arg1…以此类推.
    @SOAPBinding(use = SOAPBinding.Use.ENCODED,style = SOAPBinding.Style.RPC,parameterStyle = SOAPBinding.ParameterStyle.BARE)
    @WebMethod(action = "www.baidu.com",operationName = "say")
    public String sayHello(@WebParam(name = "name") String people);

    @SOAPBinding(use = SOAPBinding.Use.ENCODED,style = SOAPBinding.Style.RPC)
    @WebMethod(action = "www.baidu.com",operationName = "getUser")
    public UserDTO getUser(String userId);
}
</code></pre>

<pre><code class="language-java line-numbers">@WebService(endpointInterface = "cn.cases.webservice.beans.HelloCxfInterface",//&lt;wsdl:portType name="HelloCxfInterface"&gt;
        serviceName="HelloService",//&lt;wsdl:portType name="HelloService"&gt;
        targetNamespace = Constants.NSPACE,
        name = "Hello")//&lt;wsdl:port binding="tns:HelloServiceSoapBinding" name="HelloPort"&gt;
public class HelloCxf implements HelloCxfInterface{

    @Override
    public String sayHello(String people){
        return "Hello "+people;
    }

    @Override
    public UserDTO getUser(String userId) {
        UserDTO dto = new UserDTO();
        dto.setId(Long.parseLong("1001"));
        dto.setLoginName("safdas");
        dto.setName("张三");
        dto.setEmail("sdasf@qq.com");
        return dto;
    }

    public String getOne(){
        return "One";
    }
}
</code></pre>

<hr />

<h2>发布WebService</h2>

关于wsdl中的soap消息绑定机制，可以参考：<a href="http://blog.csdn.net/seasky323/article/details/6746174">SOAP消息绑定机制</a>，<a href="https://www.ibm.com/developerworks/cn/xml/x-sisoap/">浅谈SOAP</a>

<h3>使用Java原生的WebService</h3>

参考：<a href="http://www.cnblogs.com/decarl/archive/2012/05/15/2502074.html">Web Service开篇</a>

<pre><code class="language-java line-numbers">public class JaxWsServerListener {
    private static final Log log = LogFactory.getLog(JaxWsServerListener.class);

    public static void main(String[] args) {
        CxfService cxfService = new CxfServiceImpl();
        String address = "http://localhost/hello";

        Endpoint.publish(address,cxfService);
        log.info("暴露成功！");
    }
}
</code></pre>

<h3>使用Axis1.x发布</h3>

参考：<a href="http://www.cnblogs.com/hoojo/archive/2010/12/20/1911363.html">Axis1.x WebService开发指南</a>
Axis有两种方式发布，一种是<code>jws</code>方式，一种是<code>wsdd</code>方式
第一种方式操作简单，但是一般不怎么用，可以参考：<a href="http://www.cnblogs.com/hoojo/archive/2010/12/20/1911357.html">使用jws方式发布</a>
这里介绍wsdd方式
导入pom.xml

<pre data-language=XML><code class="language-markup line-numbers">        &lt;dependency&gt;
            &lt;groupId&gt;axis&lt;/groupId&gt;
            &lt;artifactId&gt;axis&lt;/artifactId&gt;
            &lt;version&gt;1.4&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>

在web.xml中配置

<pre data-language=XML><code class="language-markup line-numbers">    &lt;servlet&gt;
        &lt;display-name&gt;Apache-Axis Servlet&lt;/display-name&gt;
        &lt;servlet-name&gt;AxisServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.apache.axis.transport.http.AxisServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet&gt;
        &lt;display-name&gt;Axis Admin Servlet&lt;/display-name&gt;
        &lt;servlet-name&gt;AdminServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.apache.axis.transport.http.AdminServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;100&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet&gt;
        &lt;display-name&gt;SOAPMonitorService&lt;/display-name&gt;
        &lt;servlet-name&gt;SOAPMonitorService&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.apache.axis.monitor.SOAPMonitorService&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;SOAPMonitorPort&lt;/param-name&gt;
            &lt;param-value&gt;5101&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;100&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;AxisServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/servlet/AxisServlet&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;AxisServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.jws&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;AxisServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/services/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;SOAPMonitorService&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/SOAPMonitor&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;AdminServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/servlet/AdminServlet&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;mime-mapping&gt;
        &lt;extension&gt;wsdl&lt;/extension&gt;
        &lt;mime-type&gt;text/xml&lt;/mime-type&gt;
    &lt;/mime-mapping&gt;
</code></pre>

在<code>WEB-INF</code>目录下创建一个<code>server-config.wsdd</code>文件，里面添加如下内容。

<pre data-language=XML><code class="language-markup line-numbers">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;deployment xmlns="http://xml.apache.org/axis/wsdd/" xmlns:java="http://xml.apache.org/axis/wsdd/providers/java"&gt;
  &lt;globalConfiguration&gt;
    &lt;parameter name="sendMultiRefs" value="true"/&gt;
    &lt;parameter name="disablePrettyXML" value="true"/&gt;
    &lt;parameter name="adminPassword" value="admin"/&gt;

    &lt;parameter name="dotNetSoapEncFix" value="true"/&gt;
    &lt;parameter name="enableNamespacePrefixOptimization" value="false"/&gt;
    &lt;parameter name="sendXMLDeclaration" value="true"/&gt;
    &lt;parameter name="sendXsiTypes" value="true"/&gt;
    &lt;parameter name="attachments.implementation" value="org.apache.axis.attachments.AttachmentsImpl"/&gt;
    &lt;requestFlow&gt;
      &lt;handler type="java:org.apache.axis.handlers.JWSHandler"&gt;
        &lt;parameter name="scope" value="session"/&gt;
      &lt;/handler&gt;
      &lt;handler type="java:org.apache.axis.handlers.JWSHandler"&gt;
        &lt;parameter name="scope" value="request"/&gt;
        &lt;parameter name="extension" value=".jwr"/&gt;
      &lt;/handler&gt;
    &lt;/requestFlow&gt;
  &lt;/globalConfiguration&gt;

  &lt;handler name="LocalResponder" type="java:org.apache.axis.transport.local.LocalResponder"/&gt;
  &lt;handler name="URLMapper" type="java:org.apache.axis.handlers.http.URLMapper"/&gt;
  &lt;handler name="Authenticate" type="java:org.apache.axis.handlers.SimpleAuthenticationHandler"/&gt;
  &lt;service name="AdminService" provider="java:MSG"&gt;
    &lt;parameter name="allowedMethods" value="AdminService"/&gt;
    &lt;parameter name="enableRemoteAdmin" value="false"/&gt;
    &lt;parameter name="className" value="org.apache.axis.utils.Admin"/&gt;
    &lt;namespace&gt;http://xml.apache.org/axis/wsdd/&lt;/namespace&gt;
  &lt;/service&gt;

  &lt;service name="Version" provider="java:RPC"&gt;
    &lt;parameter name="allowedMethods" value="getVersion"/&gt;
    &lt;parameter name="className" value="org.apache.axis.Version"/&gt;
  &lt;/service&gt;
  &lt;service name="SOAPMonitorService" provider="java:RPC"&gt;
    &lt;parameter name="allowedMethods" value="publishMessage"/&gt;
    &lt;parameter name="scope" value="Application"/&gt;
    &lt;parameter name="className" value="org.apache.axis.monitor.SOAPMonitorService"/&gt;
  &lt;/service&gt;
  &lt;!--自己的webservice--&gt;
  &lt;service name="MyCService" provider="java:RPC" style="RPC" use="encoded"&gt;
    &lt;parameter name="className" value="cn.ws.webservice.InfoService"/&gt;
    &lt;!--设置发布的方法，以空格分隔--&gt;
    &lt;parameter name="allowedMethods" value="Method1 Method2"/&gt;
    &lt;!--设置--&gt;
    &lt;parameter name="scope" value="request"/&gt;
    &lt;namespace&gt;http://case.cn&lt;/namespace&gt;
  &lt;/service&gt;

  &lt;handler name="soapmonitor" type="java:org.apache.axis.handlers.SOAPMonitorHandler"&gt;
    &lt;parameter name="wsdlURL" value="/axis/SOAPMonitorService-impl.wsdl"/&gt;
    &lt;parameter name="serviceName" value="SOAPMonitorService"/&gt;
    &lt;parameter name="namespace" value="http://tempuri.org/wsdl/2001/12/SOAPMonitorService-impl.wsdl"/&gt;
    &lt;parameter name="portName" value="Demo"/&gt;
 &lt;/handler&gt;
  &lt;transport name="http"&gt;
    &lt;requestFlow&gt;
      &lt;handler type="URLMapper"/&gt;
      &lt;handler type="java:org.apache.axis.handlers.http.HTTPAuthHandler"/&gt;

      &lt;!--comment following line for REMOVING wsdl spying via SOAPMonitor--&gt;
      &lt;handler type="soapmonitor"/&gt;
    &lt;/requestFlow&gt;
    &lt;responseFlow&gt;
      &lt;!--comment following line for REMOVING wsdl spying via SOAPMonitor--&gt;
      &lt;handler type="soapmonitor"/&gt;
    &lt;/responseFlow&gt;
    &lt;parameter name="qs:list" value="org.apache.axis.transport.http.QSListHandler"/&gt;
    &lt;parameter name="qs:wsdl" value="org.apache.axis.transport.http.QSWSDLHandler"/&gt;
    &lt;parameter name="qs.list" value="org.apache.axis.transport.http.QSListHandler"/&gt;
    &lt;parameter name="qs.method" value="org.apache.axis.transport.http.QSMethodHandler"/&gt;
    &lt;parameter name="qs:method" value="org.apache.axis.transport.http.QSMethodHandler"/&gt;
    &lt;parameter name="qs.wsdl" value="org.apache.axis.transport.http.QSWSDLHandler"/&gt;
  &lt;/transport&gt;
  &lt;transport name="local"&gt;
    &lt;responseFlow&gt;
      &lt;handler type="LocalResponder"/&gt;
    &lt;/responseFlow&gt;
  &lt;/transport&gt;
&lt;/deployment&gt;
</code></pre>

上面这一步也可以使用axis提供的工具生成，具体操作可参考:<a href="http://blog.csdn.net/qq_14852397/article/details/46385713">定制发布</a>
需要将项目编译之后在WEB-INF下面打开命令行窗口，执行下面的命令

<pre><code>java -Djava.ext.dirs=lib org.apache.axis.client.AdminClient deploy.wsdd
</code></pre>

如果执行上面的命令出现404的错误，就使用下面的命令，这里的端口号根据tomcat启动的端口号行，如果有上下文路径要加入上下文路径

<pre><code>java -Djava.ext.dirs=lib org.apache.axis.client.AdminClient -lhttp://localhost:8080/services/AdminService deploy.wsdd
</code></pre>

执行了之后会在目录中生成一个叫<code>server-config.wsdd</code>的文件，将这个文件复制项目中的<code>WEB-INF</code>下面就可以了。

deploy.wsdd需要自己编写放在<code>WEB-INF</code>下内容如下

<pre data-language=XML><code class="language-markup line-numbers">&lt;deployment name="test" xmlns="http://xml.apache.org/axis/wsdd/"
            xmlns:java="http://xml.apache.org/axis/wsdd/providers/java"&gt;
    &lt;!-- provider=”java:RPC”是服务类型，除了RPC方式以外，还有Document、Wrapped和Message方式 --&gt;
    &lt;service name="MyService" provider="java:RPC"&gt;
        &lt;!-- 告诉服务应该调用的类 --&gt;
        &lt;parameter name="className" value="cn.ws.webservice.InfoService" /&gt;
        &lt;!-- * 代表所有的方法都暴露 --&gt;
        &lt;parameter name="allowedMethods" value="Method1 Method2" /&gt;
        &lt;!-- 当前WebService的作用域，分别是：request、session、application --&gt;
        &lt;parameter name="scope" value="application" /&gt;
    &lt;/service&gt;
&lt;/deployment&gt;
</code></pre>

wsdd的一些详细配置可以参考:<a href="http://blog.csdn.net/u011063151/article/details/52590282">最详细的WSDD配置文件注释</a>
使用idea可以快速的创建<code>Axis</code>的项目文件,其他IDE工具应该都有这个功能，这里没有试过。
发布好的webservice访问界面如下
<img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/noteimage/axis%E5%8F%91%E5%B8%83%E6%88%90%E5%8A%9F.png" alt="axis发布成功" />

这里的MyService就是自己部署Service下面对应发布的方法，其他的几个Service是axis自带的一些Service。
注：发布的时候如果出现异常<code>ClassNotFound</code>+发布类的权限定名，是因为要发布的类没有编译导致的，重新编译项目即可。

<h3>使用CXF发布(和Spring集成)</h3>

导入pom.xml

<pre data-language=XML><code class="language-markup line-numbers">        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
            &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt;
            &lt;version&gt;3.1.8&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
            &lt;artifactId&gt;cxf-rt-transports-http&lt;/artifactId&gt;
            &lt;version&gt;3.1.8&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>

注：Spring版本使用4.2.0以上的，CXF的版本必须在3.0以上，要不然会报下面这个错

<pre><code class="language-java line-numbers">java.lang.NoSuchMethodError:org.springframework.aop.support.AopUtils.isCglibProxyClass(Ljava/lang/Class;)
</code></pre>

在web.xml中加入Servlet

<pre data-language=XML><code class="language-markup line-numbers">    &lt;servlet&gt;
        &lt;servlet-name&gt;cxf&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;cxf&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/services/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>

在Spring的配置文件中加入下面的内容

<pre data-language=XML><code class="language-markup line-numbers">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:jaxws="http://cxf.apache.org/jaxws"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://cxf.apache.org/jaxws
        http://cxf.apache.org/schemas/jaxws.xsd"&gt;

    &lt;!--  Cxf WebService 服务端示例,这里的implementor是Service的实现类，address是发布的地址的上下文路径 --&gt;
    &lt;jaxws:endpoint id="DemoWebservice" implementor="cn.cases.webservice.beans.HelloCxf" address="/demo"/&gt;

&lt;/beans&gt;
</code></pre>

注：使用的时候要加入<code>xmlns:jaxws="http://cxf.apache.org/jaxws"</code>等内容

<pre><code class="language-java line-numbers"><br />import java.io.Serializable;

@XmlRootElement
@XmlType(name = "User", namespace = Constants.NSPACE)
public class UserDTO implements Serializable {
    private Long id;
    private String loginName;
    private String name;
    private String email;

    //略去getter/setter
}
</code></pre>

暴露在外的接口

<pre><code class="language-java line-numbers">import javax.jws.WebParam;
import javax.jws.WebService;

@WebService(targetNamespace = Constants.NSPACE)
@SOAPBinding(use = SOAPBinding.Use.ENCODED,style = SOAPBinding.Style.RPC,parameterStyle = SOAPBinding.ParameterStyle.WRAPPED)
public interface HelloCxfInterface {
    //@WebService是必须的；@WebParam不是必须的。
    //如果没有@WebParam的描述，在wsdl文件内描述的方法中，参数名将变为arg0,arg1…以此类推.
    @WebMethod(action = "www.baidu.com",operationName = "say")
    public String sayHello(@WebParam(name = "name") String people);
    @WebMethod(action = "www.baidu.com",operationName = "getUser")
    public UserDTO getUser(String userId);
}
</code></pre>

这里的action对应的是生成的wsdl中的soapAction，soapAction是用来定义请求的地址的，可以为空，但是，SOAPBinding对应的是发送的SOAP消息中包含的内容，有几种模式，可以参考：<a href="http://blog.csdn.net/etttttss/article/details/17412081">WSDL样式详解</a> <a href="http://blog.csdn.net/seasky323/article/details/6746174">SOAP的消息绑定机制</a>
接口实现类

<pre><code class="language-java line-numbers">@WebService(endpointInterface = "cn.cases.webservice.beans.HelloCxfInterface",//&lt;wsdl:portType name="HelloCxfInterface"&gt;
        serviceName="HelloService",//&lt;wsdl:portType name="HelloService"&gt;
        targetNamespace = Constants.NSPACE,
        name = "Hello")//&lt;wsdl:port binding="tns:HelloServiceSoapBinding" name="HelloPort"&gt;
public class HelloCxf implements HelloCxfInterface{

    @Override
    public String sayHello(String people){
        return "Hello "+people;
    }

    @Override
    public UserDTO getUser(String userId) {
        UserDTO dto = new UserDTO();
        dto.setId(Long.parseLong("1001"));
        dto.setLoginName("safdas");
        dto.setName("张三");
        dto.setEmail("sdasf@qq.com");
        return dto;
    }

    public String getOne(){
        return "One";
    }
}
</code></pre>

这里的接口和实现类都要加<code>@WebService</code>的标签，暴露在外的方法是以接口的方法来定的。如这里暴露在外的方法只有<code>sayHello()</code>和<code>getUser()</code>而没有<code>getOne()</code>

<hr />

<h2>客户端</h2>

<pre><code class="language-java line-numbers">import org.apache.axis.client.Call;
import org.apache.axis.client.Service;
import javax.xml.namespace.QName;
import java.net.MalformedURLException;
-------------------------------------------------------------------------
      Call call = (Call) service.createCall();
      //设置地址
      call.setTargetEndpointAddress(new java.net.URL("http://localhost:8080/services/hello?wsdl"));
      //设置要执行的方法
      call.setOperationName(new QName("http://case.cn","getUser"));
      //设置要传入参数,如果没有要传入的参数，则不要写这个
      call.addParameter("arg0", org.apache.axis.Constants.XSD_STRING,javax.xml.rpc.ParameterMode.IN);
      //设置返回的类型
      call.setReturnType(new javax.xml.namespace.QName("http://case.cn", "User"));
      call.setReturnClass(User.class);
      String name = "获得对象";
      //执行，调用webservice
      User result = (User) call.invoke(new Object[]{name});
      System.out.println("返回结果"+result.getEmail());
</code></pre>

请求的SOAP消息

<pre data-language=XML><code class="language-markup line-numbers">&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;soapenv:Body&gt;
    &lt;ns1:getUser xmlns:ns1="http://case.cn" soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;
      &lt;arg0 xsi:type="xsd:string"&gt;获得对象&lt;/arg0&gt;
    &lt;/ns1:getUser&gt;
  &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
</code></pre>

响应的SOAP消息

<pre data-language=XML><code class="language-markup line-numbers">&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt;
  &lt;soap:Body&gt;
    &lt;ns2:getUserResponse xmlns:ns2="http://case.cn"&gt;
      &lt;return&gt;
        &lt;email&gt;sdasf@qq.com&lt;/email&gt;
        &lt;id&gt;1001&lt;/id&gt;
        &lt;loginName&gt;safdas&lt;/loginName&gt;
        &lt;name&gt;张三&lt;/name&gt;
      &lt;/return&gt;
    &lt;/ns2:getUserResponse&gt;
  &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;
</code></pre>

注：这个客户端是axis的客户端，类都是axis包中的

<hr />

<h2>Idea生成webservice（以axis1.x为例）</h2>

IDE工具(如eclipse)应该都有这个功能，这里以idea为例

<hr />

<h3>服务端</h3>

<h4>新建的工程</h4>

<img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/webservice-idea/servernew1.png" alt="" />
这里会下载一些jar包，需要有网络才可以
生成项目如下：
  <img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/webservice-idea/servernew2.png" alt="" />
这里的server-config.wsdd就是axis1.x的配置文件，web.xml中加入了一些axis的servlet，如果要发布自己的webservice，需要在wsdd中加入<service></service>标签，如：
  <img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/webservice-idea/servernew3.png" alt="" />
配置一下tomcat就可以发布了访问地址为
项目访问地址+/services/+webservice名称?wsdl
可以用
项目访问地址+/services
查看axis发布的所有service
####已有的工程
  <img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/webservice-idea/serverlocation1.png" alt="" />

<img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/webservice-idea/serverlocation2.png" alt="" />
idea会自动在项目的WEB-INF下生成server-confg.wsdd，发布的服务也是配置service
web.xml也会自动加入axix的内容

<hr />

<h3>客户端</h3>

<h4>新建的工程</h4>

<img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/webservice-idea/clientnew1.png" alt="" />

<img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/webservice-idea/clientnew2.png" alt="" />
生成的main方法会有错误，这里需要手都更改一下第一行不用改导入包就可以了,locator.get+调用的类名
 <img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/webservice-idea/clientnew3.png" alt="" />

<img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/webservice-idea/clientnew4.png" alt="" />

<img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/webservice-idea/clientnew5.png" alt="" />

就可以通过service调用对应的方法了。
这里还需要导入junit的包

<h4>已有的工程</h4>

<img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/webservice-idea/clientlocation1.png" alt="" />

<img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/webservice-idea/clientlocation2.png" alt="" />
点击OK，这个时候在一个包上点击右键New的时候就会出现webclient选项
<img src="http://imageu.oss-cn-shenzhen.aliyuncs.com/webservice-idea/clientlocation3.png" alt="" />
点击按照上面介绍的操作即可
注：使用axis1.x生成的客户端也可以调用cxf生成的webservice]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>116</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 09:42:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 01:42:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[116]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="spring"><![CDATA[spring]]></category>
		<category domain="post_tag" nicename="%e6%9d%82"><![CDATA[杂]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_8fa8dba9a48a9e497c57a3bd1e11b1f1]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_b906c460c895bb96a81fb12ecb893c99]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_9cc38d6bf5ca9ea031d9161491fa0f74]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_5180afc8fe5c64f2f9b19fcddaf59759]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				css-选择器		</title>
		<link>https://blog.easysc.cn/?p=118</link>
		<pubDate>Fri, 19 Oct 2018 01:44:05 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=118</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： css

<hr />

<pre><code>[]:属性选择器
#id:id选择器
.class:class选择器
</code></pre>

[att*=val]：属性中包含val
[att^=val]：属性以val开头
[att$=val]：属性以val结尾]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>118</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 09:44:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 01:44:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[css-%e9%80%89%e6%8b%a9%e5%99%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="front"><![CDATA[front]]></category>
		<category domain="post_tag" nicename="front"><![CDATA[front]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				docker使用		</title>
		<link>https://blog.easysc.cn/?p=121</link>
		<pubDate>Fri, 19 Oct 2018 01:45:53 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=121</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： docker

<hr />

跳过安装教程

<hr />

命令
<a href="https://blog.csdn.net/permike/article/details/51879578">参考</a>
<a href="https://blog.csdn.net/one_clouder/article/details/39224767">run命令详解</a>

<pre><code>docker version // docker的版本信息，包含server和client 
docker info //docker的基本信息
docker images //查看镜像
docker ps //查看运行中的容器 -a包括停止的容器
docker start [容器名称或id] //启动容器
docker stop [容器名称或id] //停止容器
docker exec -it [容器名称或id] /bin/bash 进入容器并运行bash，后台容器exit后可以不退出
docker rm [容器名称或id] //删除容器 ，删除镜像是rmi
docker commit [命令] [容器名称或id] repo:tag(可以不写)  //将容器变为镜像
  -a 作者
  -m 提交的说明文字
  -p 提交时暂停容器
docker inspect [容器或者镜像的名称，id] //查看容器或镜像的详细信息
docker run [命令及命令信息] [容器名称或id] [启动后要执行的命令(如：/bin/bash)]
  -i 以交互模式运行容器
  -v 挂载数据卷 [主机地址]:[容器中地址] 主机地址可以不用
  -d 在后台运行容器
  -p 将主机端口和容器端口做映射 [主机端口]:[容器端口]
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>121</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 09:45:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 01:45:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[docker%e4%bd%bf%e7%94%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="docker"><![CDATA[docker]]></category>
		<category domain="post_tag" nicename="docker"><![CDATA[docker]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				简单dubbox项目搭建和应用		</title>
		<link>https://blog.easysc.cn/?p=123</link>
		<pubDate>Fri, 19 Oct 2018 01:47:21 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=123</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： dubbo

<hr />

<h2>了解</h2>

认识dubbo和dubbox可以参考：
<a href="http://shiyanjun.cn/archives/325.html">Dubbo架构设计详解</a>
<a href="http://blog.csdn.net/xlgen157387/article/details/51865289">Dubbo详细介绍与安装使用过程</a>
<a href="http://blog.csdn.net/noaman_wgs/article/details/70214612">Dubbo入门</a>

dubbo服务管理中心
用来管理，查询发布的服务，和dubbo本身的业务逻辑没有关系，是用来管理消费者和服务方的
dubbo

<hr />

<h2>下载安装dubbox</h2>

到<a href="https://github.com/dangdangdotcom/dubbox">githug</a>下载dubbox的源码，

<blockquote>
  在checkout出来的dubbox目录执行mvn install
     -Dmaven.test.skip=true来尝试编译一下dubbo（并将dubbo的jar安装到本地maven库）
      在checkout出来的dubbox根目录执行mvn idea:idea或者mvn eclipse:eclipse，来创建IDE工程文件
</blockquote>

具体可以参考：<a href="https://dangdangdotcom.github.io/dubbox/demo.html">demo</a>

上面引用至dubbox的github，除此之外可以将项目同步到本地，用ide工具的maven项目执行Install根项目（parent项目）来实现第二步，idea和eclipse都有这个功能
将jar包安装到本地之后就可以在项目中引用了

<hr />

<h2>使用dubbo搭建RPC项目</h2>

RPC的目的就是为了远程调用服务，所以dubbo在使用的时候有两个角色，一个是服务的提供方，一个是服务的消费方，提供方提供接口和接口的实现，消费方通过接口消费服务。

<h3>准备</h3>

一个web server作为服务的提供者（也可以不是web项目，通过main方法也可以）,
一个项目作为服务的消费者
一个定义接口的项目打成jar包供消费者和提供者调用
下载<a href="http://zookeeper.apache.org/releases.html">zookper</a>作为服务的注册中心

<h3>启动zookeeper</h3>

<h4>window</h4>

下载下来之后可以在<code>/conf</code>下将<code>zoo_sample.cfg</code>复制一份，然后更改名字为<code>zoo.cfg</code>（也可以根据需要去配置zookeeper，配置参照<a href="https://www.baidu.com">百度</a>）然后在<code>/bin</code>目录下点击<code>zkServer.cmd</code>启动zookeeper。
注：<code>conf</code>目录下没有<code>zoo.cfg</code>启动的时候会出现闪退。

<h4>Linux</h4>

<h3>在项目中使用</h3>

下载完install后导入

<pre data-language=XML><code class="language-markup line-numbers">        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
            &lt;version&gt;2.8.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--这个是zookeeper的东西，如果不引入会报错：
        java.lang.NoClassDefFoundError: org/I0Itec/zkclient/IZkStateListener
        --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.101tec&lt;/groupId&gt;
            &lt;artifactId&gt;zkclient&lt;/artifactId&gt;
            &lt;version&gt;0.4&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>

如果需要RESTFul风格的可以参照<a href="https://github.com/dangdangdotcom/dubbox">githug</a>查看需要导入的包
除此之外还要导入spring的包，这里不赘述
公共接口类(这里取名remote-api)中的接口

<pre><code class="language-java line-numbers">public interface RemoteService {

    String sayHello(String word);
}
</code></pre>

提供方的实现类

<pre><code class="language-java line-numbers">public class RemoteServiceImpl implements RemoteService{

    @Override
    public String sayHello(String word){
        return "Helllo"+word;
    }
}
</code></pre>

消费方只需要引入接口就行了

<h4>spring配置文件</h4>

配置文件可以参考：<a href="http://www.cnblogs.com/chanshuyi/p/5144288.html">Dubbo配置方式详解</a>
　　　　　　　　　<a href="http://www.cnblogs.com/linjiqin/p/5859153.html">Dubboo配置方式详解</a>
提供方

<pre data-language=XML><code class="language-markup line-numbers">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans.xsd
   http://code.alibabatech.com/schema/dubbo
   http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt;
    &lt;!--定义了提供方应用信息，用于计算依赖关系；在 dubbo-admin 或 dubbo-monitor 会显示这个名字，方便辨识--&gt;
    &lt;dubbo:application name="provider" owner="programmer" organization="dubbox"/&gt;
    &lt;!--使用 zookeeper 注册中心暴露服务，注意要先开启 zookeeper--&gt;
    &lt;dubbo:registry address="zookeeper://localhost:2181"/&gt;
    &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;
    &lt;dubbo:protocol name="dubbo" port="20880" /&gt;
    &lt;!--使用 dubbo 协议实现定义好的 api.PermissionService 接口--&gt;
    &lt;dubbo:service interface="cn.cases.remote.RemoteService" ref="remoteService" protocol="dubbo" /&gt;
    &lt;!--具体实现该接口的 bean--&gt;
    &lt;bean id="remoteService" class="RemoteServiceImpl"/&gt;
&lt;/beans&gt;
</code></pre>

消费方

<pre data-language=XML><code class="language-markup line-numbers">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt;

    &lt;dubbo:application name="consumer" owner="programmer" organization="dubbox"/&gt;
    &lt;!--向 zookeeper 订阅 provider 的地址，由 zookeeper 定时推送--&gt;
    &lt;dubbo:registry address="zookeeper://localhost:2181"/&gt;
    &lt;!--使用 dubbo 协议调用定义好的 Service 接口--&gt;
    &lt;dubbo:reference id="remoteService" interface="cn.cases.remote.RemoteService"/&gt;
&lt;/beans&gt;
</code></pre>

<h4>调用</h4>

消费方和服务方我都是起的web项目，在web.xml引入spring的Listener之后，分别在不同的端口启动，在消费方执行下面的测试用例

<pre><code class="language-java line-numbers">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:spring/spring-dubbo.xml")
public class RemoteTest {
    @Autowired
    RemoteService remoteService;

    @Test
    public void test1 (){
        String word = remoteService.sayHello("张三");
        System.out.println(word);
    }
}
--------------------------------------------------------------------
//也可以
public class RemoteTest {

    @Test
    public void test1 (){
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("spring/spring-dubbo.xml");
        RemoteService remoteService = (RemoteService)context.getBean("remoteService");
        String word = remoteService.sayHello("张三");
        System.out.println(word);
    }
}
</code></pre>

调用成功

<pre><code>Helllo张三
</code></pre>

用main方法调用，不用servlet容器，启动之后就可以在客户端调用

<pre><code class="language-java line-numbers">public static void main(String[] args) throws IOException {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("spring/spring-dubbo.xml");
        context.start();
        System.in.read();
    }
</code></pre>

注：如果使用外网连接<code>zookeeper</code>出现一直超时的问题，可以更改<code>&lt;dubbo:registry protocol="zookeeper" address="zookeeper://127.0.0.1:2181" timeout="10000"/&gt;</code>将超时时间设置长点就可以了，如果依旧超时，参考<a href="http://blog.csdn.net/xlgen157387/article/details/52702659">内网ip问题</a>

至此基本的dubbo使用就完了。

<hr />

<h2>Dubbo client</h2>

Dubbo client是用来管理和查看服务的消费和提供情况的，将下载下来的dubbo项目install后，在dubbo-admin下将war拷贝到tomcat的webapps下，启动tomcat，访问localhost+端口号+项目名就可以登录了（默认密码用户名都是root）。]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>123</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 09:47:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 01:47:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%ae%80%e5%8d%95dubbox%e9%a1%b9%e7%9b%ae%e6%90%ad%e5%bb%ba%e5%92%8c%e5%ba%94%e7%94%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="various"><![CDATA[杂]]></category>
		<category domain="post_tag" nicename="%e6%9d%82"><![CDATA[杂]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_8fa8dba9a48a9e497c57a3bd1e11b1f1]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_bae0d1d090348456b73df05efd8f2343]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_9cc38d6bf5ca9ea031d9161491fa0f74]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_d77fd6975036caacd3c0e9f8a7828273]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				使用poi生成和导入Excel		</title>
		<link>https://blog.easysc.cn/?p=125</link>
		<pubDate>Fri, 19 Oct 2018 01:48:46 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=125</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： excel
参考：<a href="http://blog.csdn.net/houxuehan/article/details/50960259">POI通用导出Excel</a>

<hr />

<h2>POI的导出Excel的方式和性能</h2>

POI操作EXCEL对象 
HSSF：操作Excel 97(.xls)格式 
XSSF：操作Excel 2007 OOXML (.xlsx)格式，操作EXCEL内存占用高于HSSF 
SXSSF:从POI3.8 beta3开始支持，基于XSSF，低内存占用。

使用POI的HSSF对象，生成Excel 97(.xls)格式，生成的EXCEL不经过压缩直接导出。 
线上问题：负载服务器转发请求到应用服务器阻塞,以及内存溢出 。 
如果系统存在大数据量报表导出，则考虑使用POI的SXSSF进行EXCEL操作。

HSSF生成的Excel 97(.xls)格式本身就有每个sheet页不能超过65536条的限制。 
XSSF生成Excel 2007 OOXML (.xlsx)格式，条数增加了，但是导出过程中，内存占用率却高于HSSF. 
SXSSF是自3.8-beta3版本后，基于XSSF提供的低内存占用的操作EXCEL对象。其原理是可以设置或者手动将内存中的EXCEL行写到硬盘中，这样内存中只保存了少量的EXCEL行进行操作。

EXCEL的压缩率特别高，能达到80%，12M的文件压缩后才2M左右。 如果未经过压缩、不仅会占用用户带宽，且会导致负载服务器（apache）和应用服务器之间，长时间占用连接(二进制流转发)，导致负载服务器请求阻塞，不能提供服务。

一定要注意文件流的关闭

防止前台（页面）连续触发导出EXCEL

<hr />

<h2>代码实现</h2>

<pre><code class="language-java line-numbers">import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import org.apache.poi.xssf.usermodel.XSSFRichTextString;
------------------------------------------------------------------------------------
Workbook workbook = new SXSSFWorkbook(-1); //参数为大小，-1时为不限制，不写默认是120
Sheet sheet = workbook.createSheet(fileName); //filname为sheet的名字
Row row = sheet.createRow(0); //创建第0行
Cell cell = row.createCell(0); //在第0行中创建第0列,确定一个单元格
cell.setCellValue("单元格的值");//给上面创建的单元格设置值
---------------------------------------------------------------------------------
sheet.setColumnWidth(j,length);//设置列的宽度，j为第几列，length为长度，中文一般是用列标题的长度.getBytes().length*256
sheet.autoSizeColumn(int i,boolean a); //自动设置列宽度。这个对中文的支持不是很好
---------------------------------------------------------------------------------
//将生成的Excel通过response返回，这里一定要记得关闭workbook这个流资源
OutputStream os = response.getOutputStream();
            response.setContentType("application/msexcel");
            response.setHeader("Content-Disposition", "attachment;"
                    + " filename="
                    + new String(fileName.getBytes(), "ISO-8859-1")+".xls");
            workbook.write(os);
        } catch (IOException e)
</code></pre>

自动调整列宽度，中文（仅供参考）

<pre><code class="language-java line-numbers">    //自动调整列宽度
    private static void autoSetColumWidth(Sheet sheet){
        //获取第1列和第0列比较
        Row row1 = sheet.getRow(sheet.getFirstRowNum()+1);
        for (int j = 0; j &lt; sheet.getRow(sheet.getFirstRowNum()).getLastCellNum(); j++) {
            Cell cell = row1.getCell(j);
            String stringCellValue = cell.getStringCellValue();
            if(sheet.getColumnWidth(j)&lt;stringCellValue.getBytes().length*SIZE_VALUE){
                sheet.setColumnWidth(j,stringCellValue.getBytes().length*SIZE_VALUE);
            }
        }
    }
-----------------------------------------------------------------------------
    //自动调整列宽度
    private static void autoSetColumWidth(Sheet sheet,int[] len){
        for (int i = 0; i &lt; len.length; i++) {
            sheet.setColumnWidth(i,len[i]);
        }
    }

</code></pre>

<h2>POI设置样式</h2>

参考：<a href="http://blog.csdn.net/npp616/article/details/8546737">POI设置Excel样式</a>
　　　<a href="http://blog.csdn.net/spp_1987/article/details/13769043">POI设置Excel单元格样式</a>

<pre><code class="language-java line-numbers">CellStyle cellStyle = workbook.createCellStyle();
Font font = workbook.createFont();
font.setBold(true);
font.setFontName("黑体");
font.setFontHeightInPoints((short)11);  //设置字体大小
cellStyle.setFont(font);

CellStyle bodyStyle = workbook.createCellStyle();
bodyStyle.setBorderBottom(BorderStyle.THIN);
bodyStyle.setBorderLeft(BorderStyle.THIN);
bodyStyle.setBorderRight(BorderStyle.THIN);
bodyStyle.setBorderTop(BorderStyle.THIN);
</code></pre>

<h2>使用POI导入Excel</h2>

参考：<a href="http://blog.csdn.net/lp1791803611/article/details/52351333">Java+poi Excel导入</a>
　　　<a href="http://blog.csdn.net/slience_perseverance/article/details/8228157">使用POI读取Excel文件</a>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>125</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 09:48:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 01:48:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bd%bf%e7%94%a8poi%e7%94%9f%e6%88%90%e5%92%8c%e5%af%bc%e5%85%a5excel]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="various"><![CDATA[杂]]></category>
		<category domain="post_tag" nicename="%e6%9d%82"><![CDATA[杂]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				Mysql触发器		</title>
		<link>https://blog.easysc.cn/?p=127</link>
		<pubDate>Fri, 19 Oct 2018 01:49:37 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=127</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags :mysql

<hr />

<pre><code class="language-sql line-numbers">DROP TRIGGER IF EXISTS `before_insert_log`;
CREATE TRIGGER `before_insert_log` 
BEFORE INSERT ON `cc_log`
FOR EACH ROW BEGIN
    SELECT a,b,c
  INTO @_a,@_b,@_c
    FROM abc aa
    WHERE aa.d = new.e;
    SET new.e=@_e,new.f=@_f,new.g=@_g;
END
</code></pre>

触发器可以设置给某表插入数据之前或者之后，

<pre><code>BEFORE INSERT ON `cc_log`
</code></pre>

由before或者after决定，触发器中的变量不用事先声明，
注:每一个sql都必须结尾;
##给单个变量设置值
set a = (可以是单个结果的sql，也可以直接是个值)
##给多个变量设置值
如：

<pre><code>  SELECT a,b,c
  INTO @_a,@_b,@_c
</code></pre>

用into来给多个变量赋值，变量前最好加个@，两边不能加括号

<h2>其他的语法</h2>

<pre><code>IF a &gt; 0 THEN b=1
</code></pre>

注：有IF开头，必有END IF结尾]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>127</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 09:49:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 01:49:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[mysql%e8%a7%a6%e5%8f%91%e5%99%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="mysql"><![CDATA[mysql]]></category>
		<category domain="post_tag" nicename="mysql"><![CDATA[mysql]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				获取properties配置文件		</title>
		<link>https://blog.easysc.cn/?p=129</link>
		<pubDate>Fri, 19 Oct 2018 01:51:00 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=129</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： properties stream 配置

<hr />

<h2>通过FileInputStream获取</h2>

注：FileInputStream是InputStream的子类

<pre><code>File file = new File("src/main/resources/spring/test.properties");
Properties p = new Properties();
p.load(new FileInputStream(file));
String word = p.getProperty("word");
</code></pre>

上面第三步也可以直接

<pre><code>p.load(new FileInputStream("src/main/resources/spring/test.properties"));
</code></pre>

路径问题：
这里的<code>src/main/resources/spring/test.properties</code>是相对路径，相对于工程的路径，也可以写绝对路径（加上盘符等等）。
如果写<code>/src/main/resources/spring/test.properties</code>表示工程所在盘符的下的这个路径，而不是工程路径下的
如下:

<pre><code class="language-java line-numbers">    File file = new File("src/main/resources/spring/test.properties");
    System.out.println(file.getAbsolutePath());
    File file1 = new File("/src/main/resources/spring/test.properties");
    System.out.println(file1.getAbsoluteFile());
</code></pre>

结果为：

<pre><code>C:\Users\Administrator\IdeaProjects\project\src\main\resources\spring\test.properties
C:\src\main\resources\spring\test.properties
</code></pre>

注:

<pre><code>p.load()可以传入的参数是Reader和InputStream
</code></pre>

<hr />

<h2>通过ClassLoader类加载器获取</h2>

<pre><code>InputStream resourceAsStream = a.getClass().getClassLoader().getResourceAsStream("spring/test.properties");
Properties p = new Properties();
p.load(resourceAsStream);
String word = p.getProperty("word");
</code></pre>

这个方法是从classpath目录下加载的文件，比较方便

<hr />

<h2>通过currentThread当前线程获取</h2>

<pre><code>InputStream resourceAsStream1 = Thread.currentThread().getContextClassLoader().getResourceAsStream("spring/test.properties");
    Properties p = new Properties();
    p.load(resourceAsStream1);
    String word = p.getProperty("word");
</code></pre>

这个也是通过classpath拿到的文件

<hr />

注：获取之后一定要<code>try catch finally</code> 关闭流资源]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>129</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 09:51:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 01:51:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%8e%b7%e5%8f%96properties%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="about-config"><![CDATA[配置相关]]></category>
		<category domain="post_tag" nicename="about-config"><![CDATA[配置相关]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				Java反射		</title>
		<link>https://blog.easysc.cn/?p=131</link>
		<pubDate>Fri, 19 Oct 2018 01:52:39 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=131</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： 反射 reflect
参考：<a href="http://www.journaldev.com/1789/java-reflection-example-tutorial#get-set-private-field">反射</a> <a href="http://blog.csdn.net/liujiahan629629/article/details/18013523">字段</a>
引用：<a href="http://www.jianshu.com/p/5001b2add70b">方法</a> <a href="http://www.cnblogs.com/LZL-student/p/5965991.html">构造方法</a>

<hr />

<pre><code class="language-java line-numbers">    @Test
    public void checkTest(){
        AppResult a = new AppResult();
        Field[] fields = a.getClass().getDeclaredFields();//拿到私有的字段
        for (Field f : fields){
            System.out.println(f.getName());
            AccessCheck annotation = f.getAnnotation(AccessCheck.class);
            if (annotation!=null){
                if (annotation.level().equals("1")){

                    try {
                        f.setAccessible(true);  //允许访问私有字段
                        System.out.println(f.get(a)); //拿到a对象中f字段的值
                        f.set(a, "3");              //设置a对象中f字段的值
                        System.out.println(f.get(a));
                    } catch (IllegalAccessException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
</code></pre>

对象：

<pre><code class="language-java line-numbers">    @AccessCheck(level = "1")
    private String levle = "2";
</code></pre>

自定义注解

<pre><code class="language-java line-numbers">@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface AccessCheck {
    String value() default "";
    String level() default "1";
}
</code></pre>

结果：

<pre><code class="language-java line-numbers">initReturnCode
initReturnMsg
initDetails
levle
2
3
</code></pre>

<hr />

<h2>反射详解</h2>

拿到对象的Class
- 通过forName
  <code>Class&lt;?&gt; aClass = Class.forName("cn.ws.test.AppResult");</code>
- 通过.class
   <code>AppResult.class</code>
- 通过.getClass
   这个是每个对象有的属性
    通过Class文件创建对象

<pre><code class="language-java line-numbers">    @Test
    public void caseTest(){
        try {
            Class&lt;?&gt; aClass = Class.forName("cn.ws.test.AppResult");
            System.out.println(aClass.getCanonicalName());//拿到全限定名
            Object o = aClass.newInstance();    //创建对象（无参构造方法）
            System.out.println(o);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        }
    }
</code></pre>

<h3>私有和公有</h3>

获取私有的字段，方法的值时需要先将允许访问私有设置为true，如下：
<code>f.setAccessible(true);  //允许访问私有字段</code>

<h3>获取修饰符</h3>

通过反射可以获取字段的修饰符
<code>f.getModifiers()；</code>
返回的是一个int类型，对应修饰符代表数字的和
如<code>private static String a</code>;
返回的值为10

<pre><code class="language-java line-numbers">PUBLIC: 1
PRIVATE: 2
PROTECTED: 4
STATIC: 8
FINAL: 16
SYNCHRONIZED: 32
VOLATILE: 64
TRANSIENT: 128
NATIVE: 256
INTERFACE: 512
ABSTRACT: 1024
STRICT: 2048
</code></pre>

这个方法在获取方法，类的修饰符也有效
字段的一些方法如下

<h2>字段（Field/s）</h2>

<h3>获取字段</h3>

<pre><code class="language-java line-numbers">Field[] fields = a.getClass().getDeclaredFields();//获取对象中所有私有字段，加Declared的都是获取私有的
    try {
            Field initReturnMsg = a.getClass().getField("initReturnMsg");
            //获取指定的公共的字段，如这里的initReturnMsg
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
</code></pre>

<h3>代码</h3>

<pre><code class="language-java line-numbers">for (Field field : fields){
            AccessCheck annotation = field.getAnnotation(AccessCheck.class);
            System.out.println(field.getModifiers());;//获取字段的修饰符
            System.out.println(field.getName()); //获取字段名
            if (annotation!=null){
                if (annotation.level().equals("1")){
                    try {
                        Class&lt;?&gt; type = field.getType();    //获取字段类型
                        System.out.println("是否相等："+type.equals(String.class)); //这个字段为String,输出为true
                        field.setAccessible(true);  //允许访问私有字段
                        System.out.println(field.get(a)); //拿到a对象中f字段的值
                        field.set(a, "zasjfdals");              //设置a对象中f字段的值
                        System.out.println(field.get(a));
                    } catch (IllegalAccessException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
</code></pre>

<hr />

<h2>方法（Method/s）</h2>

<h3>获取方法</h3>

<blockquote>
  只有通过方法签名才能找到唯一的方法，方法签名=方法名+参数列表（参数类型、参数个数、参数顺序）。
</blockquote>

<pre><code class="language-java line-numbers">    try {
            Class&lt;?&gt; appClass = Class.forName("cn.ws.test.AppResult");
            Method[] methods = appClass.getDeclaredMethods();   //获取所有的方法(私有和公有)
            Method[] methods1 = appClass.getMethods();  //获取所有公共方法，包括父类的
            Object o = appClass.newInstance();
            for (Method method : methods){
                method.getAnnotation(AccessCheck.class);//获取方法上的注解
                method.getModifiers();//获取修饰符
                System.out.println( method.getGenericReturnType());
                System.out.println(method.getReturnType());
                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); //拿到参数的类型
                System.out.println("method name : "+method.getName() //获取方法名
                        +" returnType : "+method.getReturnType()
                        +" ParameterTypes : "+Arrays.toString(parameterTypes)
                        +""
                );//获取返回类型
            }
            System.out.println("------------------ln----------------");
            for (Method method : methods1){
                System.out.println("method name : "+method.getName()+" returnType : "+method.getReturnType());
            }
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (InstantiationException e) {
                e.printStackTrace();
        }
</code></pre>

结果：

<pre><code class="language-java line-numbers">class java.lang.String
class java.lang.String
method name : testPrivateMethod returnType : class java.lang.String ParameterTypes : [class java.lang.String]
void
void
method name : setDetails returnType : void ParameterTypes : [class java.lang.Object]
void
void
method name : setReturnCode returnType : void ParameterTypes : [class java.lang.Object]
void
void
method name : setReturnMsg returnType : void ParameterTypes : [class java.lang.Object]
class java.lang.Object
class java.lang.Object
method name : getDetails returnType : class java.lang.Object ParameterTypes : []
class java.lang.Object
class java.lang.Object
method name : getReturnCode returnType : class java.lang.Object ParameterTypes : []
class java.lang.Object
class java.lang.Object
method name : getReturnMsg returnType : class java.lang.Object ParameterTypes : []
class java.lang.String
class java.lang.String
method name : testPublicMethod returnType : class java.lang.String ParameterTypes : []
------------------ln----------------
method name : setDetails returnType : void
method name : setReturnCode returnType : void
method name : setReturnMsg returnType : void
method name : getDetails returnType : class java.lang.Object
method name : getReturnCode returnType : class java.lang.Object
method name : getReturnMsg returnType : class java.lang.Object
method name : testPublicMethod returnType : class java.lang.String
method name : remove returnType : class java.lang.Object
method name : remove returnType : boolean
method name : get returnType : class java.lang.Object
method name : put returnType : class java.lang.Object
method name : values returnType : interface java.util.Collection
method name : clone returnType : class java.lang.Object
method name : clear returnType : void
method name : isEmpty returnType : boolean
method name : replace returnType : boolean
method name : replace returnType : class java.lang.Object
method name : replaceAll returnType : void
method name : size returnType : int
method name : entrySet returnType : interface java.util.Set
method name : putAll returnType : void
method name : putIfAbsent returnType : class java.lang.Object
method name : keySet returnType : interface java.util.Set
method name : compute returnType : class java.lang.Object
method name : computeIfAbsent returnType : class java.lang.Object
method name : computeIfPresent returnType : class java.lang.Object
method name : containsKey returnType : boolean
method name : containsValue returnType : boolean
method name : forEach returnType : void
method name : getOrDefault returnType : class java.lang.Object
method name : merge returnType : class java.lang.Object
method name : equals returnType : boolean
method name : toString returnType : class java.lang.String
method name : hashCode returnType : int
method name : wait returnType : void
method name : wait returnType : void
method name : wait returnType : void
method name : getClass returnType : class java.lang.Class
method name : notify returnType : void
method name : notifyAll returnType : void
</code></pre>

<h3>获取指定的方法，并执行</h3>

<pre><code class="language-java line-numbers">    @Test
    public void methodTest1() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
        Class&lt;?&gt; appClass = Class.forName("cn.ws.test.AppResult");
        Object o = appClass.newInstance();
        Method testPrivateMethod = appClass.getDeclaredMethod("testPrivateMethod",String.class);//拿到指定名称的方法,后面可以传参数类型，来指定拿哪个方法
        testPrivateMethod.setAccessible(true);
        Object invoke = testPrivateMethod.invoke(o, "1345"); //重新传入参数，并执行方法
        System.out.println(invoke);
    }
</code></pre>

结果：

<pre><code class="language-java line-numbers">传入的参数为1345
1345
</code></pre>

<h3>调用静态方法和可变参数方法</h3>

<blockquote>
  使用反射调用静态方法: public Object invoke(Object obj,Object... args);
  如果底层方法是静态的，那么可以忽略指定的 obj参数。将obj参数设置为null即可。
  
  使用反射调用可变参数的方法:
  对于数组类型的引用类型的参数,底层会自动解包,为了解决该问题,我们使用Object的一维数组把实际参数包装起来.
  
  (牢记)以后使用反射调用invoke方法,在传递实际参数的时候,无论是基本数据类型还是引用数据类型,也无论是可变参数类型,反正就是一切实际参数都包装在newObject[]{}中,就没问题。
  
  <code>m.invoke(方法底层所属对象,newObject[]{实际参数});通用</code>
</blockquote>

<hr />

<h2>构造方法（Constructor/s）</h2>

<h3>获取构造方法</h3>

<pre><code class="language-java line-numbers">    @Test
    public void constructorTest() throws ClassNotFoundException, NoSuchMethodException {
        Class&lt;?&gt; appClass = Class.forName("cn.ws.test.AppResult");
        Constructor&lt;?&gt; constructor = appClass.getConstructor(String.class);//获取单个构造方法，非私有,不写默认是无参
        Constructor&lt;?&gt;[] constructors = appClass.getConstructors();//获取多个构造方法，非私有
        Constructor&lt;?&gt; declaredConstructor = appClass.getDeclaredConstructor(); //获取单个构造方法，可以获取私有的
        Constructor&lt;?&gt;[] declaredConstructors = appClass.getDeclaredConstructors();//获取所有的构造方法,包括私有
        }
</code></pre>

<h3>使用构造器创建对象</h3>

<pre><code class="language-java line-numbers">    try {
        /**
        对应上面获取构造方法
        */
            AppResult o = (AppResult)declaredConstructor.newInstance(); //使用无参构造器创建对象
            AppResult o1 = (AppResult) constructor.newInstance("使用参数为String的构成器创建的对象");
            System.out.println(o);
            System.out.println(o1);
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
</code></pre>

私有的构造器创建对象

<pre><code class="language-java line-numbers">try {
            Constructor&lt;?&gt; privateConstrctor = appClass.getDeclaredConstructor(String.class, Object.class);
            privateConstrctor.setAccessible(true);
            AppResult o = (AppResult) privateConstrctor.newInstance("通过私有的构造器创建对象","12356");
            System.out.println(o);
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
</code></pre>

构造器也可以实现方法中的一些东西，诸如拿到参数的类型等，还可以拿到构造器所在类的Class对象

<hr />

<h2>其他</h2>

<pre><code class="language-java line-numbers">        Class&lt;?&gt; appClass = Class.forName("cn.ws.test.AppResult");
        Class&lt;?&gt; superclass = appClass.getSuperclass().getSuperclass();//拿到的是父类
        Type genericSuperclass = appClass.getSuperclass().getGenericSuperclass(); //得到的是泛型的父类
        System.out.println(genericSuperclass instanceof ParameterizedTypeImpl);
        System.out.println(superclass);
        System.out.println(genericSuperclass);
</code></pre>

结果如下：

<pre><code class="language-java line-numbers">true
class java.util.AbstractMap
java.util.AbstractMap&lt;K, V&gt;
</code></pre>

AppResult类

<pre><code class="language-java line-numbers">package cn.ws.test;

import cn.ws.annotation.AccessCheck;
import org.springframework.stereotype.Component;

import java.util.HashMap;

public class AppResult&lt;K,V&gt; extends HashMap implements AppResultInterface{
    private static String initReturnCode = "1";
    private static String initReturnMsg = "成功！";
    private static Object initDetails = "";

    @AccessCheck(level = "1")
    private String levle ;

    public AppResult() {
        super.put("returnCode",initReturnCode);
        super.put("returnMsg",initReturnMsg);
        super.put("details",initDetails);
    }

    public AppResult(String returnCode,String returnMsg,Object details){
        super.put("returnCode",returnCode);
        super.put("returnMsg",returnMsg);
        super.put("details",details);
    }

    private AppResult(String successMsg,Object successDetails){
        super.put("returnCode",initReturnCode);
        super.put("returnMsg",successMsg);
        super.put("details",successDetails);
    }

    public AppResult(String successMsg){
        super.put("returnCode",initReturnCode);
        super.put("returnMsg",successMsg);
        super.put("details",initDetails);
    }

    public void setDetails(Object details){
        super.put("details",details);
    }

    public void setReturnCode(Object returnCode){
        super.put("returnCode",returnCode);
    }

    public void setReturnMsg(Object returnMsg){
        super.put("returnMsg",returnMsg);
    }

    public Object getDetails(){
        return super.get("details");
    }

    public Object getReturnCode(){
        return super.get("returnCode");
    }

    public Object getReturnMsg(){
        return super.get("returnMsg");
    }

    private String testPrivateMethod(String arg){
        System.out.println("传入的参数为"+arg);
        return arg;
    }

    public String testPublicMethod(){
        return "654321";
    }
}
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>131</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 09:52:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 01:52:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[java%e5%8f%8d%e5%b0%84]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="java"><![CDATA[java]]></category>
		<category domain="post_tag" nicename="%e5%8f%8d%e5%b0%84"><![CDATA[反射]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				Vue		</title>
		<link>https://blog.easysc.cn/?p=136</link>
		<pubDate>Fri, 19 Oct 2018 02:18:32 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=136</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： web vue
<a href="https://cn.vuejs.org/v2/guide/">官网教程</a>

<hr />

<h2>基础</h2>

挂载成功后通过$el来获取挂载的元素，

<pre><code>var app = new Vue({
    el:'#app',
    data:{}
})
</code></pre>

数据为双向绑定，即绑定的双方数据任何一方数据发生变化，另外一边会发生同样的变化
<code>{{}}</code>为最基本的文本插值方式，可以使用元运算，做简单的运算
如：<code>{{'123,123'.split(',')}}</code>,<code>{{isSuccess?'成功':'失败'}}</code>

<pre><code>vue只支持单个表达式，不支持语句和流控制，另外，在表达式中，不能使用用户自定义的全局变量，只能使用vue白名单的全局变量，如Math和Date
</code></pre>

<h3>过滤器</h3>

可以在<code>{{}}</code>加入管道对数据进行过滤(filters,methods)

<pre><code>{{select}}
el:'#element',
data:{},
filters{
    select:function(value){.....}
}
</code></pre>

过滤器可以串联也可以接收参数
串联 <code>{{message |filterA|filterB}}</code>
接收参数 <code>{{message |filterA('arg1','arg2')}}</code>

<h3>事件绑定</h3>

使用<code>v-on:绑定的事件</code>，如<code>v-on:click</code>，可以简写为语法糖<code>@click</code>

<pre><code>&lt;div id="app"&gt;
    &lt;p v-if="show"&gt;这是一段文字&lt;/p&gt;
    &lt;button @click="toggle"&gt;点击隐藏&lt;/button&gt;
&lt;/div&gt;
new Vue({
    el:'#app',
    data:{
        show:true
    },
    methods:{
        toggle:function () {
            this.show = !this.show;
        }
        //methods中的方法可以互相调用，使用this.方法名称
    }
})
</code></pre>

<h3>计算属性</h3>

需要对{{}}中的数据进行复杂处理的可以使用计算属性(computed)

<pre><code>&lt;p&gt;{{split1}}&lt;/p&gt;
new Vue({
    el:'element',
    data:{},
    computed:{
        split1:function(){....}
    }
})
</code></pre>

两个vue示例的计算实例可以互相调用，使用实例名称.计算属性

<h4>计算属性缓存</h4>

<pre><code>计算属性是基于它的依赖缓存的，一个计算属性所依赖的数据发生变化时，它才会重新取值，所以只要text不改变，计算属性就不更新
</code></pre>

<h3>其他</h3>

vue在渲染元素的时候，处于效率考虑，会尽可能的复用已有的元素而非从新渲染。如果要重新渲染，加上属性<code>key=""</code>

<h2>生命周期</h2>

<ul>
<li>create : 实例创建完成后调用，此阶段完成了数据的观测，但尚未挂载，$el还不可用，一般用于初始化数据</li>
<li>mounted : el挂载到实例上后调用，一般业务逻辑从这开始</li>
<li>beforeDestroy : 实例销毁之前调用，主要解绑使用addEventListerner监听的事件</li>
</ul>

<h2>内置语法</h2>

<pre><code>v-html 插入html代码，而不是当做文本处理
v-pre 如果想要显示{{}}使用这个标签跳过编译
v-if 
v-bind 语法糖 :class 绑定元素的属性
    例：&lt;div :class="{'active':isActive}"&gt;&lt;/div&gt;
    当isActive为true时,这个div拥有类名active，反之没有，也可以
    一般绑定一个计算属性或者写在data中，也可以绑定一个Object类型的数据，或者methods
    需要多个class的时候可以使用数组语法，还可以使用三元表达式切换
    例：&lt;div :class"[arg1,arg2]"&gt;&lt;/div&gt;,data中写arg1和arg2的值
    一般也应该使用计算属性，methods，等
    :style 使用方法和:class类似，CSS属性名称使用驼峰命名或者短横分隔命名
    使用:style时，vue会自动给特殊的CSS属性名称增加前缀，如transform
v-cloak 不需要表达式，会在结束编译时从绑定的html上移除，常和CSS的display:none使用，用得较少
v-once 不需要表达式，定义它的元素或组件只渲染一次，包括元素或组件的所有子节点，首次渲染后，不再随数据的变化重新渲染，一般很少用到
v-if,v-if-else,v-else,根据表达式的值在DOM中渲染或销毁元素/组件
    v-if-else要紧跟v-if,v-else要紧跟v-else-if或v-if,表达式的值为真时，当前元素/组件及所有子节点将被渲染，为假时被移除
    例：
    &lt;p v-if="status==1"&gt;这是第一行&lt;/p&gt;
    &lt;p v-else-if="status==2"&gt;这是第二行&lt;/p&gt;
    &lt;p v-else=""&gt;这是第三行&lt;/p&gt;
    var app = new Vue({
    el:'#app',
    data:{
        status:2,
    }})//这里会显示第二行
    v-if可以配合&lt;template&gt;&lt;/template&gt;使用
v-show 用法与v-if基本一致，v-show是改变CSS属性display,v-show值为false时，元素会隐藏，v-show不能在template上使用
v-for 需要循环显示的时候用到v-for，需结合in/of使用
    例：&lt;temple v-for="item in list"&gt;{{item}}&lt;/temple&gt;
        还可以带一个参数表示元素位置
        &lt;template v-for="(item,index) in list"&gt;{{index}}-{{item}}&lt;/template&gt;
    对象的属性也是可以遍历的，有两个可选参数key,value,如：(value,key,index) in user
    也可以用来迭代整数，item in 10
    修改数组时，渲染的视图也会更新（双向绑定）
        数组的一些操作方法：
            push()
            pop()
            shift()
            unshift()
            splice()
            sort()
            reverse()
        以上方法会改变原数组,以下方法不会
            filter()
            concat()
            slice()
    以下变动的数组中，vue是不能检测到的，也不会更新视图
    - 通过索引直接设置项，如app.books[3]={..}
    - 修改数组长度，如app.books.length=1
    第一个可以使用set方法，Vue.set(app.books,3,{....}),在webpack里写为this.$set(app.books,3,{...}),另一个方法，app.books.splice(3,1,{...})，第二个问题也可以用splice
    如果不想改变原数组，如过滤和排序，可以使用计算属性来返回过滤或排序后的数组
    例：&lt;template v-for="item in filterSort"&gt;&lt;/template&gt;//这里的filterSort表示计算属性
v-on 语法糖 @click 绑定元素的事件
    例：&lt;a href="..." @click="login()"&gt;
    click后的方法可以不写()，vue会按照默认的JavaScript处理，vue还提供了一个特殊的变量$event，用于访问原生的DOM事件
    例：&lt;a href="..." @click="login('登录成功',$event)"&gt;可以在方法中调用事件如：preventDefult()
    可以使用修饰符来指定事件,vue支持一下修饰符
    - .stop
    - .prevent
    - .capture
    - .self
    - .once
    如：&lt;a href="..." @click.stop=""&gt;
    如果是键盘事件时，vue支持按键修饰符，和一些快捷名称如.enter .tab可以组合使用
</code></pre>

​<br />
​

<h3>其他</h3>

<ul>
<li>v-if和v-show的选择
具有相似的功能，但是v-if才是真的条件渲染，它会根据表达式适当的销毁或重建元素及绑定的事件或子组件，若表达式初始值为false,则元素一开始不会渲染，只有当条件第一次变为真的时候才会开始编译
而v-show只是简单的CSS属性切换，无论条件是否是真都会被编译，相比之下，v-if适合条件经常不变的场景，v-show适合频繁切换的条件

<p>​</p></li>
</ul>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>136</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 10:18:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 02:18:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[vue]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="front"><![CDATA[front]]></category>
		<category domain="post_tag" nicename="vue"><![CDATA[vue]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				搭建webpack环境		</title>
		<link>https://blog.easysc.cn/?p=138</link>
		<pubDate>Fri, 19 Oct 2018 02:19:26 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=138</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： webpack

<hr />

webpack安装，可以参考<a href="https://blog.csdn.net/qq_36407748/article/details/80968300">webpack4.0安装</a>
最好是本地安装

<pre><code>npm/cnpm install --save-dev webpack
//如果是4.x还要安装webpack-cli
npm/cnpm install --save-dev webpack-cli
</code></pre>

安装webpack-dev-server

<pre><code>npm/cnpm install --save-dev webpack-dev-server
</code></pre>

在package.json里的scripts里面添加

<pre><code>"dev":"webpack-dev-server --open --config webpack.config.js"
</code></pre>

<code>--open</code>表示启动之后打开浏览器
<code>--config</code>表示配置文件的地址
在当前目录下新建<code>webpack.config.js</code>
写入如下内容

<pre><code>var config = {};
moudule.exports = config;
</code></pre>

使用命令行执行<code>npm run dev</code>就会启动本地服务器

webpack配置最重要也是必选的两项是入口(entry)和出口(output)，入口是告诉webpack从哪里开始寻找依赖，并且编译，出口则是用来配置编译后的文件存储位置和文件名
在目录下新建一个空的main.js作为入口文件，然后在webpack.config.js中进行配置

<pre><code>var path = require('path');
var config = {
    entry: {
        main: './main'
    },
    output: {
        path: path.join(__dirname,'./dist'),
        publicPath: '/dist/',
        filename: 'main.js'
    }
};
module.exports = config;
</code></pre>

<ul>
<li>entry中的main是配置的单入口，webpack会从main.js开始工作</li>
<li>output中的path选项用来存放打包文件的输出目录（必填）</li>
<li>publicPath指定资源文件引用的目录，可以填CDN的网址</li>
<li>filename指定输出文件的名称</li>
</ul>

然后在根目录下新建一个index.html

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        这是一个主页
    &lt;/div&gt;
    &lt;script type="text/javascript" src="/dist/main.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

执行<code>npm run dev</code>将本地服务器跑起来，会看到这是一个主页
然后在main.js中加入

<pre><code>document.getElementById('app').innerHTML = 'Hello webpack';
</code></pre>

再到网页上看，页面显示已经变成了 webpack，修改了main.js中的内容之后，webpack会自动编译并刷新浏览器
webpack通过一个websocket来实时响应代码的修改
没有编译之前，代码是存在于内存中的，可以使用下面的代码，按照之前的配置输出到目录

<pre><code>webpack --progress --hide-modules
</code></pre>

<h2>完善配置</h2>

webpack可以通过按照不同的加载器对不同后缀名的文件进行处理，如写css就要用到css-loader和style-loader
可以通过下面了命令安装

<pre><code>cnpm/npm insatll --save-dev css-loader
cnpm/npm insatll --save-dev style-loader
</code></pre>

然后在配置文件里配置loader

<pre><code>var path = require('path');

var config = {
    entry: {
        main: './main'
    },
    output: {
        path: path.join(__dirname,'./dist'),
        publicPath: '/dist/',
        filename: 'main.js'
    },
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                    'style-loader',
                    'css-loader'
                ]
            }
        ]
    }
};
module.exports = config;
</code></pre>

moudule的rules属性可以指定一系列的loaders，每个loader都必须包含test和use两个选项

npm i ..... 批量安装
-D 等同于 --save-dev
-S 等同于 --save]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>138</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 10:19:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 02:19:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%90%ad%e5%bb%bawebpack%e7%8e%af%e5%a2%83]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="front"><![CDATA[front]]></category>
		<category domain="post_tag" nicename="webpack"><![CDATA[webpack]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				Java对象和Xml的互相转换		</title>
		<link>https://blog.easysc.cn/?p=140</link>
		<pubDate>Fri, 19 Oct 2018 02:20:16 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=140</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： xml

<hr />

<pre><code class="language-java line-numbers">import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementWrapper;
import javax.xml.bind.annotation.XmlRootElement;
</code></pre>

<code>@XmlRootElement(name = "ROOT")</code>定义根元素的名字
<code>@XmlElement(name = "NAME")</code>定义根元素下面元素的名字，一般写在getter/setter上
<code>@XmlElementWrapper(name = "HABITLIST")</code>可以遍历ListT和Set，但是对于map的支持不是很好
实体类

<pre><code class="language-java line-numbers">import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementWrapper;
import javax.xml.bind.annotation.XmlRootElement;
import java.util.List;


@XmlRootElement(name = "ROOT")
public class XmlBean {
    private String name ;

    private int age;

    private List&lt;Habit&gt; list;

    @XmlElement(name = "NAME")
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @XmlElement(name = "AGE")
    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @XmlElementWrapper(name = "HABITLIST")
    @XmlElement(name = "HABIT")
    public List&lt;Habit&gt; getList() {
        return list;
    }

    public void setList(List&lt;Habit&gt; list) {
        this.list = list;
    }
}
---------------------------------------------------------------------------------
public class Habit {

    private String aboutLife;
    private String aboutLern;

    @XmlElement(name = "ABOUTLEARN")
    public String getAboutLern() {
        return aboutLern;
    }

    public void setAboutLern(String aboutLern) {
        this.aboutLern = aboutLern;
    }

    public String getAboutLife() {
        return aboutLife;
    }

    @XmlElement(name = "ABOUTLIFE")
    public void setAboutLife(String aboutLife) {
        this.aboutLife = aboutLife;
    }
}
</code></pre>

测试代码

<pre><code class="language-java line-numbers">    @Test
    public void test1(){
        XmlBean xmlBean = new XmlBean();
        xmlBean.setAge(15);
        xmlBean.setName("张三");

        Habit habit = new Habit();
        habit.setAboutLern("学习");
        habit.setAboutLife("生活");

        Habit habit1 = new Habit();
        habit1.setAboutLern("学习1");
        habit1.setAboutLife("生活1");

        List&lt;Habit&gt; list = new ArrayList&lt;&gt;();
        list.add(habit);
        list.add(habit1);

        xmlBean.setList(list);
        try {
            String s = beanToXml(xmlBean, XmlBean.class);
            System.out.println(s);
        } catch (JAXBException e) {
            e.printStackTrace();
        }
    }
</code></pre>

生成的结果

<pre data-language=XML><code class="language-markup line-numbers">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;ROOT&gt;
    &lt;AGE&gt;15&lt;/AGE&gt;
    &lt;HABITLIST&gt;
        &lt;HABIT&gt;
            &lt;ABOUTLEARN&gt;学习&lt;/ABOUTLEARN&gt;
            &lt;ABOUTLIFE&gt;生活&lt;/ABOUTLIFE&gt;
        &lt;/HABIT&gt;
        &lt;HABIT&gt;
            &lt;ABOUTLEARN&gt;学习1&lt;/ABOUTLEARN&gt;
            &lt;ABOUTLIFE&gt;生活1&lt;/ABOUTLIFE&gt;
        &lt;/HABIT&gt;
    &lt;/HABITLIST&gt;
    &lt;NAME&gt;张三&lt;/NAME&gt;
&lt;/ROOT&gt;
</code></pre>

xml和Java对象的互相转换

<pre><code class="language-java line-numbers">public static String beanToXml(Object obj,Class&lt;?&gt; load) throws JAXBException{
        JAXBContext context = JAXBContext.newInstance(load);
        Marshaller marshaller = context.createMarshaller();
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);//格式化xml
        marshaller.setProperty(Marshaller.JAXB_ENCODING, "UTF-8");
        StringWriter writer = new StringWriter();
        marshaller.marshal(obj,writer);
        return writer.toString();
    }

    public static Object xmlToBean(String xml,Class&lt;?&gt; load) throws JAXBException, IOException {
        JAXBContext context = JAXBContext.newInstance(load);
        Unmarshaller unmarshaller = context.createUnmarshaller();
        Object unmarshal = unmarshaller.unmarshal(new StringReader(xml));
        return unmarshal;
    }
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>140</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 10:20:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 02:20:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[java%e5%af%b9%e8%b1%a1%e5%92%8cxml%e7%9a%84%e4%ba%92%e7%9b%b8%e8%bd%ac%e6%8d%a2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="xml"><![CDATA[xml]]></category>
		<category domain="category" nicename="various"><![CDATA[杂]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				代理模式		</title>
		<link>https://blog.easysc.cn/?p=142</link>
		<pubDate>Fri, 19 Oct 2018 02:22:01 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=142</guid>
		<description></description>
		<content:encoded>
				<![CDATA[tags： 设计模式

<hr />

<h2>Java原生代理模式</h2>

测试类：

<pre><code class="language-java line-numbers">public class ProxyBean implements ProxyInterface{
    private String filed = "This is a word for test!!";

    @Override
    public String proxyMethod(String word){
        return "这是一句话："+word;
    }

    @Override
    public String proxyMethod1(String word) {
        return "这是一句话："+word;
    }

    public String getFiled() {
        return filed;
    }

    public void setFiled(String filed) {
        this.filed = filed;
    }

}
</code></pre>

接口：

<pre><code class="line-numbers">public interface ProxyInterface {
    public String proxyMethod(String word);
    public String proxyMethod1(String word);
}
</code></pre>

代理类：

<pre><code class="line-numbers">public class ProxyHandler&lt;T&gt; implements InvocationHandler{
    //被代理的对象
    private T target;

    public ProxyHandler(T target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("invoke执行");
        System.out.println(method.getName());
        System.out.println("参数："+ Arrays.toString(args));
        return method.invoke(target, args);
    }

    public T getProxy(){
        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();    //获取类加载器
        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();                          //获取类的父接口
        Object o = Proxy.newProxyInstance(contextClassLoader,interfaces,this)
        System.out.println(o instanceof ProxyBean); //false
        System.out.println(o instanceof ProxyInterface); //true
        return (T)o;
    }
}
</code></pre>

测试类：

<pre><code class="line-numbers">/**
 * Java原生动态代理
 * 目标对象必须实现一个接口，转换的时候，只能以接口的形式转化，需要实现InvocationHandler接口
 */
public class ProxyTest {
    @Test
    public void testProxy() throws ClassNotFoundException, IllegalAccessException, InstantiationException {
        Class&lt;?&gt; aClass = Thread.currentThread().getContextClassLoader().loadClass("cn.ws.proxy.ProxyBean");
        ProxyBean proxyBean = (ProxyBean) aClass.newInstance();
        ProxyHandler&lt;ProxyInterface&gt; proxyHandler = new ProxyHandler(proxyBean);
        ProxyInterface proxy = proxyHandler.getProxy();
        System.out.println(proxy.proxyMethod("测试"));
    }
}
</code></pre>

注：使用Java原生代理的时候，被代理的对象必须是实现一个接口，代理对象强转的时候只能被转换为被代理对象的接口形式。
结果：

<pre><code>invoke执行
proxyMethod
参数：[测试]
这是一句话：测试
</code></pre>

<hr />

<h2>Cglib代理</h2>

测试对象：

<pre><code class="line-numbers">public class TestBean {
    private String filed = "This is a word for test!!";

    public String proxyMethod(String word){
        return "这是一句话："+word;
    }
}
</code></pre>

代理对象：

<pre><code class="line-numbers">import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;
import java.util.Arrays;

/**
 * Cglib代理
 * 代理的对象（目标对象）可以不用实现接口，Spring里面集成了这个代理，代理类实现MethodInterceptor使用的时候直接使用Spring的包就可以了
 * Java原生的代理类需要实现InvocationHandler这个接口，而且目标对象必须要实现一个接口才可以使用代理模式
 * @param &lt;T&gt;
 */
public class ProxyFactory&lt;T&gt; implements MethodInterceptor {
    //代理的目标对象
    private T target;

    public ProxyFactory(T target) {
        this.target = target;
    }

    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        String superName = methodProxy.getSuperName();
        System.out.println("代理执行！");
        System.out.println("执行方法："+method.getName()+" 代理方法："+methodProxy.getSuperName()+" 参数："+ Arrays.toString(args));
        return method.invoke(target,args);
    }

    public T getProxyInstance(){
        //1.工具类
        Enhancer en = new Enhancer();
        //2.设置父类
        en.setSuperclass(target.getClass());
        //3.设置回调函数
        en.setCallback(this);
        //4.创建子类(代理对象)
        return (T)en.create();
    }
}
</code></pre>

测试方法：

<pre><code class="line-numbers">public class ProxyTest {
    @Test
    public void testProxy() throws ClassNotFoundException, IllegalAccessException, InstantiationException {
            Class&lt;?&gt; aClass = Thread.currentThread().getContextClassLoader().loadClass("cn.ws.Cglib.TestBean");
            TestBean o = (TestBean)aClass.newInstance();
            ProxyFactory&lt;TestBean&gt; proxyFactory = new ProxyFactory(o);
            TestBean proxyInstance = proxyFactory.getProxyInstance();
            System.out.println(proxyInstance.proxyMethod("测试"));
            System.out.println(proxyInstance.getClass());
    }
}
</code></pre>

结果：

<pre><code>代理执行！
执行方法：proxyMethod 代理方法：CGLIB$proxyMethod$0 参数：[测试]
这是一句话：测试
class cn.ws.Cglib.TestBean$$EnhancerByCGLIB$$1d1cb9da
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>142</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 10:22:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 02:22:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="various"><![CDATA[杂]]></category>
		<category domain="post_tag" nicename="%e6%9d%82"><![CDATA[杂]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				log4j配置		</title>
		<link>https://blog.easysc.cn/?p=144</link>
		<pubDate>Fri, 19 Oct 2018 02:23:08 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=144</guid>
		<description></description>
		<content:encoded>
				<![CDATA[[hermit autoplay="false" mode="circulation" preload="auto"]remote#:1[/hermit]
tags： 配置
引用：<a href="http://www.cnblogs.com/ITtangtang/p/3926665.html">log4j配置</a>
参考：<a href="http://www.cnblogs.com/shenliang123/archive/2012/05/02/2479286.html">玩转log4j</a>

<hr />

<h2>组成部分</h2>

log4j由三个部分组成

<pre><code>Loggers(记录器)，Appenders (输出源)和Layouts(布局)
</code></pre>

log4j的日志被分为了几个级别，对应的级别及关系：

<pre><code>DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL
</code></pre>

注：log4j输出日志的时候，只会输出和设定等级相等和比设定等级高的Log

<h3>常用的Logger</h3>

<pre><code>org.apache.log4j.ConsoleAppender（控制台）
org.apache.log4j.FileAppender（文件）
org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）
org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）
org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）
</code></pre>

<h3>常用的Layout</h3>

<pre><code>org.apache.log4j.HTMLLayout（以HTML表格形式布局）
org.apache.log4j.PatternLayout（可以灵活地指定布局模式）
org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）
org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）
</code></pre>

<hr />

<h2>配置及语法</h2>

Log4j支持两种配置文件格式，一种是XML格式的文件，一种是properties属性文件，这里使用properites

<h3>配置根Logger</h3>

<pre><code>log4j.rootLogger = [ level ] , appenderName1, appenderName2, …
log4j.additivity.org.apache=false：表示Logger不会在父Logger的appender里输出，默认为true。
</code></pre>

这里的appenderName可以自己定义，但是要在后面的配置中也使用
level表示输出日志的等级，log4j只建议使用ERROR、WARN、INFO、DEBUG（从高到低）
使用范例：

<pre><code>lo4j.rootLoger = DEBUG,a,b,c
</code></pre>

<h3>配置日志输出位置(appender)</h3>

<pre><code>log4j.appender.appenderName = className
</code></pre>

<code>className对应上面几种常用的Logger,appenderName对应根Logger的appenderName,以下不赘述</code>
范例：

<pre><code>log4j.appender.a = org.apache.log4j.ConsoleAppender
</code></pre>

几种Logger都有的属性

<pre><code>Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG。
ImmediateFlush=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。
</code></pre>

FileAppender，DailyRollingFileAppender，RollingFileAppender都有的属性

<pre><code>Append=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。
File=D:/logs/logging.log4j：指定消息输出到logging.log4j文件中。
</code></pre>

特有属性：

<ul>
<li><code>ConsoleAppender</code>
Target=System.err：默认值是System.out</li>
<li><code>DailyRollingFileAppender</code>
DatePattern='.'yyyy-MM：每月滚动一次日志文件，即每月产生一个新的日志文件。当前月的日志文件名为logging.log4j，前一个月的日志文件名为logging.log4j.yyyy-MM。
另外，也可以指定按周、天、时、分等来滚动日志文件，对应的格式如下：
1)'.'yyyy-MM：每月
2)'.'yyyy-ww：每周
3)'.'yyyy-MM-dd：每天
4)'.'yyyy-MM-dd-a：每天两次
5)'.'yyyy-MM-dd-HH：每小时
6)'.'yyyy-MM-dd-HH-mm：每分钟</li>
<li><code>RollingFileAppender</code>
MaxFileSize=100KB：后缀可以是KB,MB或者GB。在日志文件到达该大小时，将会自动滚动，即将原来的内容移到logging.log4j.1文件中。
MaxBackupIndex=2：指定可以产生的滚动文件的最大数，例如，设为2则可以产生logging.log4j.1，logging.log4j.2两个滚动文件和一个logging.log4j文件。</li>
</ul>

范例：

<pre><code>log4j.appender.a.Target = System.err
log4j.appender.a.Threshold = DEBUG
</code></pre>

<h3>配置输出的形式/格式（Layout）</h3>

<pre><code>log4j.appender.appenderName.layout=className
</code></pre>

这里的className指的是上面常用的Layout，以下不赘述
参数设置：

<ul>
<li><code>HTMLLayout</code>
LocationInfo=true：输出java文件名称和行号，默认值是false。
 Title=My Logging： 默认值是Log4J Log Messages。</li>
<li><code>PatternLayout</code>
ConversionPattern=%m%n：设定以怎样的格式显示消息。</li>
</ul>

<pre><code class="line-numbers">格式化符号说明：

%p：输出日志信息的优先级，即DEBUG，INFO，WARN，ERROR，FATAL。
%d：输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，如：%d{yyyy/MM/dd HH:mm:ss,SSS}。
%r：输出自应用程序启动到输出该log信息耗费的毫秒数。
%t：输出产生该日志事件的线程名。
%l：输出日志事件的发生位置，相当于%c.%M(%F:%L)的组合，包括类全名、方法、文件名以及在代码中的行数。例如：test.TestLog4j.main(TestLog4j.java:10)。
%c：输出日志信息所属的类目，通常就是所在类的全名。
%M：输出产生日志信息的方法名。
%F：输出日志消息产生时所在的文件名称。
%L:：输出代码中的行号。
%m:：输出代码中指定的具体日志信息。
%n：输出一个回车换行符，Windows平台为"rn"，Unix平台为"n"。
%x：输出和当前线程相关联的NDC(嵌套诊断环境)，尤其用到像java servlets这样的多客户多线程的应用中。
%%：输出一个"%"字符。
另外，还可以在%与格式字符之间加上修饰符来控制其最小长度、最大长度、和文本的对齐方式。如：
1) c：指定输出category的名称，最小的长度是20，如果category的名称长度小于20的话，默认的情况下右对齐。
2)%-20c："-"号表示左对齐。
3)%.30c：指定输出category的名称，最大的长度是30，如果category的名称长度大于30的话，就会将左边多出的字符截掉，但小于30的话也不会补空格。
</code></pre>

范例:

<pre><code>log4j.appender.c.layout=org.apache.log4j.PatternLayout
log4j.appender.c.layout.ConversionPattern=[%-5p] [%d{yyyy-MM-dd HH:mm:ss}][%t] %c - %x %m%n
</code></pre>

<h2>其他</h2>

<h3>特定类输出不同个log</h3>

在Java类中说明

<pre><code>private static Log logger = LogFactory.getLog(Test.class);
</code></pre>

说明：这里的LogFactory是<code>commons-logging</code>包中的，这个包不是Log4j的，是一个日志通用包，Log4j实现了其中的接口，这里通过LogFactory来获得日志对象，以后更改的时候会比较方便
然后在log4j.properties中加入:

<pre><code>log4j.logger.cn.com.Test= DEBUG, test
log4j.appender.test=org.apache.log4j.FileAppender
log4j.appender.test.File=${myweb.root}/WEB-INF/log/test.log
log4j.appender.test.layout=org.apache.log4j.PatternLayout
log4j.appender.test.layout.ConversionPattern=%d %p [%c] - %m%n
</code></pre>

<h3>同一个类输出多个log</h3>

Java类中：

<pre><code>private static Log logger = LogFactory.getLog("test");
private static Log logger = LogFactory.getLog("test1");
</code></pre>

log4j.properties中加入:

<pre><code>log4j.logger.test= DEBUG, test
...配置信息略去

log4j.logger.test1= DEBUG, test1
...配置信息略去
</code></pre>

<blockquote>
  这些自定义的日志默认是同时输出到log4j.rootLogger所配置的日志中的，通过设置下面的属性可以更改
  log4j.additivity.test1 = false
  　　它用来设置是否同时输出到log4j.rootLogger所配置的日志中，设为false就不会输出到其它地方啦注意这里的"test1"是在程序中给logger起的那个自定义的名字！
  如果你说，我只是不想同时输出这个日志到log4j.rootLogger所配置的logfile中，stdout里我还想同时输出呢！那也好办，把你的log4j.logger.myTest1 = DEBUG, test1改为下式就OK啦！ log4j.logger.test1=DEBUG, test1
</blockquote>

<h2>使用</h2>

在<code>src</code>等级的目录下新建文件<code>log4j.properties</code>将配置写入就可以使用了

<hr />

<pre><code class="line-numbers">#设置根级别
#a为控制台输出。b为日志输出。c为错误日志
#DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL
log4j.rootLogger = DEBUG,a,c
################################
#设置每个日志输出的等级
log4j.appender.a.Threshold = DEBUG
#log4j.appender.b.Threshold = INFO
log4j.appender.c.Threshold = ERROR
################################
#设置spring的log级别
log4j.logger.org.springframework=ERROR
################################
#输出
log4j.appender.a = org.apache.log4j.ConsoleAppender
#Target输出的格式。可以写System.err和System.out(默认)
log4j.appender.a.Target = System.out
#指定输出的格式
log4j.appender.a.layout =org.apache.log4j.PatternLayout
log4j.appender.a.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n
###############################
#输出到日志（文件）
log4j.appender.c = org.apache.log4j.DailyRollingFileAppender
log4j.appender.c.File = ${log.dir}/error.log
#指定输出的格式
log4j.appender.c.layout =org.apache.log4j.PatternLayout
log4j.appender.c.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n
##################################
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>144</wp:post_id>
		<wp:post_date><![CDATA[2018-10-19 10:23:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-19 02:23:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[log4j%e9%85%8d%e7%bd%ae]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="about-config"><![CDATA[配置相关]]></category>
		<category domain="post_tag" nicename="about-config"><![CDATA[配置相关]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				DockerFile		</title>
		<link>https://blog.easysc.cn/?p=203</link>
		<pubDate>Mon, 22 Oct 2018 09:07:52 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=203</guid>
		<description></description>
		<content:encoded>
				<![CDATA[参考及引用：<a href="http://itmuch.com/docker/07-docker-docker-file/">Dockerfile指令详解</a>

<h2>FROM 指定基础镜像</h2>

使用FROM指令指定基础镜像，FROM指令有点像Java里面的“extends”关键字。需要注意的是，FROM指令必须指定且需要写在其他指令之前。FROM指令后的所有指令都依赖于该指令所指定的镜像。
支持三种格式：
- <code>FROM &lt;image&gt;</code>
- <code>FROM &lt;image&gt;:&lt;tag&gt;</code>
- <code>FROM &lt;image&gt;@&lt;digest&gt;</code>

<h2>ADD 复制文件</h2>

ADD指令用于复制文件，格式为：
- <code>ADD &lt;src&gt;... &lt;dest&gt;</code>
- <code>ADD ["&lt;src&gt;",... "&lt;dest&gt;"]</code>
  从src目录复制文件到容器的dest。其中src可以是Dockerfile所在目录的相对路径，也可以是一个URL，还可以是一个压缩包
  注：
1. 如果src是一个url，以/会被视为一个目录，不以/结尾视为文件
2. 如果src是一个目录，那么整个目录下的内容将会被拷贝，包括文件系统元数据。
3. 如果文件是可识别的压缩包格式，则docker会自动解压。
4. src必须在构建的上下文内，不能使用例如：ADD ../somethine /something 这样的命令，因为docker build 命令首先会将上下文路径和其子目录发送到docker daemon。

<pre><code class="language-shell line-numbers">ADD abc.jar def.jar
</code></pre>

<h2>COPY 复制文件</h2>

复制文件，格式为：
- <code>COPY &lt;src&gt;... &lt;dest&gt;</code>
- <code>COPY ["&lt;src&gt;",... "&lt;dest&gt;"]</code>
  复制本地端的src到容器的dest。COPY指令和ADD指令类似，COPY不支持URL和压缩包。

<h2>ARG 设置构建参数</h2>

ARG指令用于设置构建参数，类似于ENV。和ARG不同的是，ARG设置的是构建时的环境变量，在容器运行时是不会存在这些变量的。

格式为：
- <code>ARG &lt;name&gt;[=&lt;default value&gt;]</code>

<h2>ENV 设置环境变量</h2>

ENV指令用于设置环境变量，格式为：
- <code>ENV &lt;key&gt; &lt;value&gt;</code>
- <code>ENV &lt;key&gt;=&lt;value&gt; ...</code>
  示例：

<pre><code class="language-shell line-numbers">ENV JAVA_HOME /path/to/java
</code></pre>

<h3>ENV 和 ARG区别</h3>

参考：<a href="http://scmroad.com/topics/39188">http://scmroad.com/topics/39188</a>
- <code>The ARG instruction defines a variable that users can pass at build-time to the builder with the docker build command using the --build-arg = flag.</code>
  ARG指令定义了用户可以在编译时或者运行时传递的变量，如使用如下命令： <code>--build-arg &lt;varname&gt;=&lt;value&gt;</code>
- <code>The ENV instruction sets the environment variable to the value .</code>
  The environment variables set using ENV will persist when a container is run from the resulting image.
  ENV指令是在dockerfile里面设置环境变量，不能在编译时或运行时传递。
  有效结合：

<pre><code class="language-shell line-numbers">ARG var
ENV var=${var}
</code></pre>

You can then either build an image with a specific var value at build-time (docker build --build-arg var=xxx), or run a container with a specific runtime value (docker run -e var=yyy)

<h2>ENTRYPOINT 入口点</h2>

格式为：
- <code>ENTRYPOINT ["executable", "param1", "param2"]</code>
- <code>ENTRYPOINT command param1 param2</code>
  ENTRYPOINT和CMD指令的目的一样，都是指定Docker容器启动时执行的命令，可多次设置，但只有最后一个有效。ENTRYPOINT不可被重写覆盖。

<h2>CMD 容器启动命令</h2>

CMD指令用于为执行容器提供默认值。每个Dockerfile只有一个CMD命令，如果指定了多个CMD命令，那么只有最后一条会被执行，如果启动容器的时候指定了运行的命令，则会覆盖掉CMD指定的命令。
支持三种格式：
- <code>CMD ["executable","param1","param2"] (推荐使用)</code>
- <code>CMD ["param1","param2"] (为ENTRYPOINT指令提供预设参数)</code>
- <code>CMD command param1 param2 (在shell中执行)</code>
  示例：

<pre><code class="language-shell line-numbers">CMD echo "This is a test." | wc -
</code></pre>

<h2>RUN 执行命令</h2>

该指令支持两种格式：
- <code>RUN &lt;command&gt;</code>
- <code>RUN ["executable", "param1", "param2"]</code>
  <code>RUN &lt;command&gt;</code>在shell终端中运行，在Linux中默认是/bin/sh -c ，在Windows中是 cmd /s /c ，使用这种格式，就像直接在命令行中输入命令一样。
  <code>RUN ["executable", "param1", "param2"]</code> 使用exec执行，这种方式类似于函数调用。指定其他终端可以通过该方式操作，例如：RUN ["/bin/bash", "-c", "echo hello"] ，该方式必须使用双引号[“]而不能使用单引号[‘]，因为该方式会被转换成一个JSON 数组。

<h3>CMD/ENTRYPOINT/RUN区别</h3>

参考:<a href="https://segmentfault.com/q/1010000000417103">https://segmentfault.com/q/1010000000417103</a>
个人理解：
ENTRYPOINT 相当于设置初始值
CMD 相当于覆盖初始值

<blockquote>
  RUN是在Build时运行的，先于CMD和ENTRYPOINT。Build完成了，RUN也运行完成后，再运行CMD或者ENTRYPOINT
</blockquote>

<h2>EXPOSE 声明暴露的端口</h2>

EXPOSE指令用于声明在运行时容器提供服务的端口，格式为：
- <code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code>
  需要注意的是，这只是一个声明，运行时并不会因为该声明就打开相应端口。该指令的作用主要是帮助镜像使用者理解该镜像服务的守护端口；其次是当运行时使用随机映射时，会自动映射EXPOSE的端口。示例：

<pre><code class="language-shell line-numbers"># 声明暴露一个端口示例
EXPOSE port1
# 相应的运行容器使用的命令
docker run -p port1 image
# 也可使用-P选项启动
docker run -P image

# 声明暴露多个端口示例
EXPOSE port1 port2 port3
# 相应的运行容器使用的命令
docker run -p port1 -p port2 -p port3 image
# 也可指定需要映射到宿主机器上的端口号  
docker run -p host_port1:port1 -p host_port2:port2 -p host_port3:port3 image
</code></pre>

<h2>USER 设置用户</h2>

该指令用于设置启动镜像时的用户或者UID，写在该指令后的RUN、CMD以及ENTRYPOINT指令都将使用该用户执行命令。
格式为：
- <code>USER 用户名</code>

<h2>VOLUME 指定挂载点</h2>

该指令使容器中的一个目录具有持久化存储的功能，该目录可被容器本身使用，也可共享给其他容器。当容器中的应用有持久化数据的需求时可以在Dockerfile中使用该指令。格式为
- <code>VOLUME ["/data"]</code>
  使用示例：

<pre><code class="language-shell line-numbers">FROM nginx
VOLUME /tmp
</code></pre>

当该Dockerfile被构建成镜像后，/tmp目录中的数据即使容器关闭也依然存在。如果另一个容器也有持久化的需求，并且想使用以上容器/tmp目录中的内容，则可使用如下命令启动容器：

<pre><code class="language-shell line-numbers">docker run -volume-from 容器ID 镜像名称  # 容器ID是di一个容器的ID，镜像是第二个容器所使用的镜像。
</code></pre>

<h2>WORKDIR 指定工作目录</h2>

格式为：
- <code>WORKDIR /path/to/workdir</code>
  切换目录指令，类似于cd命令，写在该指令后的RUN，CMD以及ENTRYPOINT指令都将该目录作为当前目录，并执行相应的命令。
  Dockerfile还有一些其他的指令，例如STOPSINGAL、HEALTHCHECK、SHELL等。由于并不是很常用，本书不作赘述。有兴趣的读者可前往<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a> 扩展阅读。

<h2>LABEL 为镜像添加元数据</h2>

LABEL指令用于为镜像添加元数据。
格式为：
- <code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code>
  使用 ""和"\"转换命令行，示例：

<pre><code class="language-shell line-numbers">LABEL "com.example.vendor"="ACME Incorporated"
LABEL com.example.label-with-value="foo"
LABEL version="1.0"
LABEL description="This text illustrates \
that label-values can span multiple lines."
</code></pre>

<h2>MAINTAINER 指定维护者的信息（已过时）</h2>

MAINTAINER指令用于指定维护者的信息，用于为Dockerfile署名
格式为：
- <code>MAINTAINER &lt;name&gt;</code>
  该指令已过时，建议使用如下形式：
  <code>LABEL maintainer="SvenDowideit@home.org.au"</code>

<h2>拓展阅读</h2>

<ul>
<li>Dockerfile官方文档：<a href="https://docs.docker.com/engine/reference/builder/#dockerfile-reference">https://docs.docker.com/engine/reference/builder/#dockerfile-reference</a></li>
<li>Dockerfile最佳实践：<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#build-cache">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#build-cache</a></li>
<li>例子参考
<a href="http://blog.51cto.com/zero01/2069879">http://blog.51cto.com/zero01/2069879</a>
<a href="https://blog.csdn.net/qq_34409701/article/details/79949401">https://blog.csdn.net/qq_34409701/article/details/79949401</a></li>
</ul>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>203</wp:post_id>
		<wp:post_date><![CDATA[2018-10-22 17:07:52]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-22 09:07:52]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[dockerfile]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="docker"><![CDATA[docker]]></category>
		<category domain="post_tag" nicename="docker"><![CDATA[docker]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_e3daaf844981db1246ff6b963268b25f]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				docker 容器常用命令		</title>
		<link>https://blog.easysc.cn/?p=212</link>
		<pubDate>Tue, 23 Oct 2018 07:57:52 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=212</guid>
		<description></description>
		<content:encoded>
				<![CDATA[参考和引用：<a href="http://itmuch.com/docker/05-docker-command-containers/">容器常用命令</a>

<h2>新建并启动容器[重要]</h2>

一些常用的选项
- -d：表示后台运行
- -P：随机映射一个容器的端口(如果EXPOSE有声明，就是声明的端口)
- -p：指定端口映射
1. ip:hostPort:containerPort
2. ip::containerPort
3. hostPort:containerPort
4. containerPort
- –network选项：指定网络模式，该选项有以下可选参数：
1. –network=bridge： 默认选项，表示连接到默认的网桥。
2. –network=host：容器使用宿主机的网络。
3. –network=container:NAME_or_ID：告诉Docker让新建的容器使用已有容器的网络配置。
4. –network=none：不配置该容器的网络，用户可自定义网络配置。
- --name: 指定启动容器的名称
- -v 挂载主机的目录到容器
  -v /usr:/abc
  将主机的/abc目录挂载到容器的/usr
  eg：

<pre><code class="language-java line-numbers">docker run -d -p 91:80 nginx
</code></pre>

注：
需要注意的是，使用docker run命令创建容器时，会先检查本地是否存在指定镜像。如果本地不存在该名称的镜像，Docker就会自动从Docker Hub下载镜像并启动一个Docker容器。

<h2>列出容器[重要]</h2>

使用docker ps 命令即可列出运行中的容器。执行该命令后，可看到类似于如下的表格。

<pre><code class="language-java line-numbers">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES
784fd3b294d7        nginx               "nginx -g 'daemon off"   20 minutes ago      Up 2 seconds        443/tcp, 0.0.0.0:91-&gt;80/tcp   backstabbing_archimedes
</code></pre>

如需列出所有容器（包括已停止的容器），可使用-a参数。

该表格包含了七列，含义如下：

① CONTAINER_ID：表示容器ID。

② IMAGE：表示镜像名称。

③ COMMAND：表示启动容器时运行的命令。

④ CREATED：表示容器的创建时间。

⑤ STATUS：表示容器运行的状态。Up表示运行中，Exited表示已停止。

⑥ PORTS：表示容器对外的端口号。

⑦ NAMES：表示容器名称。该名称默认由Docker自动生成，也可使用docker run命令的–name选项自行指定。

命令格式：

<pre><code class="language-java line-numbers">docker ps [OPTIONS]
</code></pre>

参数：

<table>
<thead>
<tr>
  <th>Name, shorthand</th>
  <th>Default</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>--all, -a</code></td>
  <td><code>false</code></td>
  <td>列出所有容器，包括未运行的容器，默认只展示运行的容器</td>
</tr>
<tr>
  <td><code>--filter, -f</code></td>
  <td></td>
  <td>根据条件过滤显示内容</td>
</tr>
<tr>
  <td><code>--format</code></td>
  <td></td>
  <td>通过Go语言模板文件展示镜像</td>
</tr>
<tr>
  <td><code>--last, -n</code></td>
  <td><code>-1</code></td>
  <td>显示最近创建n个容器（包含所有状态）</td>
</tr>
<tr>
  <td><code>--latest, -l</code></td>
  <td><code>false</code></td>
  <td>显示最近创建的容器（包含所有状态）</td>
</tr>
<tr>
  <td><code>--no-trunc</code></td>
  <td><code>false</code></td>
  <td>不截断输出</td>
</tr>
<tr>
  <td><code>--quiet, -q</code></td>
  <td><code>false</code></td>
  <td>静默模式，只展示容器的编号</td>
</tr>
<tr>
  <td><code>--size, -s</code></td>
  <td><code>false</code></td>
  <td>显示总文件大小</td>
</tr>
</tbody>
</table>

<h2>停止容器[重要]</h2>

使用<code>docker stop</code> 命令，即可停止容器
命令格式：

<pre><code class="language-java line-numbers">docker stop [OPTIONS] CONTAINER [CONTAINER...]
</code></pre>

参数：

<table>
<thead>
<tr>
  <th>Name, shorthand</th>
  <th>Default</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>--time, -t</code></td>
  <td><code>10</code></td>
  <td>强制杀死容器前等待的时间，单位是秒</td>
</tr>
</tbody>
</table>

eg:

<pre><code class="language-java line-numbers">docker stop 784fd3b294d7
</code></pre>

其中784fd3b294d7 是容器ID，当然也可使用docker stop 容器名称 来停止指定容器
强制停止容器[重要]
可使用<code>docker kill</code> 命令停止一个或更多运行着的容器
命令格式：

<pre><code class="language-java line-numbers">docker kill [OPTIONS] CONTAINER [CONTAINER...]
</code></pre>

参数：

<table>
<thead>
<tr>
  <th>Name, shorthand</th>
  <th>Default</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>--signal, -s</code></td>
  <td><code>KILL</code></td>
  <td>向容器发送一个信号</td>
</tr>
</tbody>
</table>

<h2>启动已停止的容器[重要]</h2>

使用<code>docker run</code>命令，即可新建并启动一个容器。对于已停止的容器，可使用<code>docker start</code> 命令来启动。
命令格式：

<pre><code class="language-java line-numbers">docker start [OPTIONS] CONTAINER [CONTAINER...]
</code></pre>

参数：

<table>
<thead>
<tr>
  <th>Name, shorthand</th>
  <th>Default</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>--attach, -a</code></td>
  <td><code>false</code></td>
  <td>连接STDOUT/STDERR并转发信号</td>
</tr>
<tr>
  <td><code>--checkpoint</code></td>
  <td></td>
  <td>从该检查点还原</td>
</tr>
<tr>
  <td><code>--checkpoint-dir</code></td>
  <td></td>
  <td>使用自定义的检查点存储目录</td>
</tr>
<tr>
  <td><code>--detach-keys</code></td>
  <td></td>
  <td>覆盖断开容器的关键顺序</td>
</tr>
<tr>
  <td><code>--interactive, -i</code></td>
  <td><code>false</code></td>
  <td>连接容器的STDIN</td>
</tr>
</tbody>
</table>

<h2>重启容器[重要]</h2>

可使用<code>docker restart</code>命令来重启容器。该命令实际上是先执行了<code>docker stop</code>命令，然后执行了<code>docker start</code>命令。
命令格式：

<pre><code class="language-java line-numbers">docker restart [OPTIONS] CONTAINER [CONTAINER...]
</code></pre>

参数：

<table>
<thead>
<tr>
  <th>Name, shorthand</th>
  <th>Default</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>--time, -t</code></td>
  <td><code>10</code></td>
  <td>关闭容器前等待的时间，单位是秒</td>
</tr>
</tbody>
</table>

<h2>进入容器[重要]</h2>

某场景下，我们可能需要进入运行中的容器。

① 使用docker attach 命令进入容器。

例如：

<pre><code class="language-java line-numbers">docker attach 784fd3b294d7
</code></pre>

很多场景下，使用<code>docker attach</code>命令并不方便。当多个窗口同时attach到同一个容器时，所有窗口都会同步显示。同理，如果某个窗口发生阻塞，其他窗口也无法执行操作。
② 使用<code>nsenter</code>进入容器
nsenter工具包含在util-linux 2.23或更高版本中。为了连接到容器，我们需要找到容器第一个进程的PID，可通过以下命令获取

<pre><code class="language-shell line-numbers">docker inspect --format "{{.State.Pid}}" $CONTAINER_ID
</code></pre>

获得PID后，就可使用nsenter命令进入容器了：

<pre><code class="language-shell line-numbers">nsenter --target "$PID" --mount --uts --ipc --net --pid
</code></pre>

读者也可将以上两条命令封装成一个Shell，从而简化进入容器的过程
③ docker exec

<pre><code class="language-shell line-numbers">docker exec -it 容器id /bin/bash
</code></pre>

<h3>退出容器</h3>

①在容器中输入<code>exit;</code>
②ctrl+p+q

<h2>删除容器[重要]</h2>

使用<code>docker rm</code>命令即可删除指定容器。
命令格式

<pre><code class="language-shell line-numbers">docker rm [OPTIONS] CONTAINER [CONTAINER...]
</code></pre>

参数：

<table>
<thead>
<tr>
  <th>Name, shorthand</th>
  <th>Default</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>--force, -f</code></td>
  <td><code>false</code></td>
  <td>通过SIGKILL信号强制删除正在运行中的容器</td>
</tr>
<tr>
  <td><code>--link, -l</code></td>
  <td><code>false</code></td>
  <td>删除容器间的网络连接</td>
</tr>
<tr>
  <td><code>--volumes, -v</code></td>
  <td><code>false</code></td>
  <td>删除与容器关联的卷</td>
</tr>
</tbody>
</table>

例1：删除指定容器。

<pre><code class="language-shell line-numbers">docker rm 784fd3b294d7
</code></pre>

该命令只能删除已停止的容器，如需删除正在运行的容器，可使用-f参数。
例2：删除所有的容器。

<pre><code class="language-shell line-numbers">docker rm -f $(docker ps -a -q)
</code></pre>

<h2>导出容器</h2>

将容器导出成一个压缩包文件。
命令格式：

<pre><code class="language-shell line-numbers">docker export [OPTIONS] CONTAINER
</code></pre>

参数：

<table>
<thead>
<tr>
  <th>Name, shorthand</th>
  <th>Default</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>--output, -o</code></td>
  <td></td>
  <td>将内容写到文件而非STDOUT</td>
</tr>
</tbody>
</table>

示例：

<pre><code class="language-shell line-numbers">docker export red_panda &gt; latest.tar
docker export --output="latest.tar" red_panda
</code></pre>

<h2>导入容器</h2>

使用<code>docker import</code>命令即可从归档文件导入内容并创建镜像。
命令格式：

<pre><code class="language-shell line-numbers">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]
</code></pre>

参数：

<table>
<thead>
<tr>
  <th>Name, shorthand</th>
  <th>Default</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>--change, -c</code></td>
  <td></td>
  <td>将Dockerfile指令应用到创建的镜像</td>
</tr>
<tr>
  <td><code>--message, -m</code></td>
  <td></td>
  <td>为导入的镜像设置提交信息</td>
</tr>
</tbody>
</table>

示例：

<pre><code class="language-shell line-numbers">docker import nginx2.tar nginx
</code></pre>

拓展阅读

<ul>
<li>Docker的网络：<a href="https://docs.docker.com/engine/userguide/networking/">https://docs.docker.com/engine/userguide/networking/</a></li>
<li>Docker命令：<a href="https://docs.docker.com/engine/reference/commandline/docker/">https://docs.docker.com/engine/reference/commandline/docker/</a></li>
</ul>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>212</wp:post_id>
		<wp:post_date><![CDATA[2018-10-23 15:57:52]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-23 07:57:52]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[docker-%e5%ae%b9%e5%99%a8%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="docker"><![CDATA[docker]]></category>
		<category domain="post_tag" nicename="docker"><![CDATA[docker]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				docker 镜像常用命令		</title>
		<link>https://blog.easysc.cn/?p=227</link>
		<pubDate>Tue, 23 Oct 2018 09:00:47 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=227</guid>
		<description></description>
		<content:encoded>
				<![CDATA[参考和引用<a href="http://itmuch.com/docker/04-docker-command-images/">Docker镜像常用命令</a>

<h2>搜索镜像</h2>

可使用<code>docker search</code>命令搜索存放在Docker Hub中的镜像。

命令格式：

<pre><code class="language-shell line-numbers">docker search [OPTIONS] TERM
</code></pre>

参数：

<table>
<thead>
<tr>
  <th>Name, shorthand</th>
  <th>Default</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>--automated</code></td>
  <td><code>false</code></td>
  <td>只列出自动构建的镜像</td>
</tr>
<tr>
  <td><code>--filter, -f</code></td>
  <td></td>
  <td>根据指定条件过滤结果</td>
</tr>
<tr>
  <td><code>--limit</code></td>
  <td><code>25</code></td>
  <td>搜索结果的最大条数</td>
</tr>
<tr>
  <td><code>--no-trunc</code></td>
  <td><code>false</code></td>
  <td>不截断输出，显示完整的输出</td>
</tr>
<tr>
  <td><code>--stars, -s</code></td>
  <td><code>0</code></td>
  <td>只展示Star不低于该数值的结果</td>
</tr>
</tbody>
</table>

示例1：

<pre><code class="language-shell line-numbers">docker search java
</code></pre>

执行该命令后，Docker就会在Docker Hub中搜索含有“java”这个关键词的镜像仓库。执行该命令后，可看到类似于如下的表格：

<pre><code class="language-shell line-numbers">NAME                    DESCRIPTION                STARS     OFFICIAL   AUTOMATED
java                    Java is a concurrent, ...   1281      [OK]       
anapsix/alpine-java     Oracle Java 8 (and 7) ...   190                  [OK]
isuper/java-oracle      This repository conta ...   48                   [OK]
lwieske/java-8          Oracle Java 8 Contain ...   32                   [OK]
nimmis/java-centos      This is docker images ...   23                   [OK]
...
</code></pre>

该表格包含五列，含义如下：

① NAME：镜像仓库名称。

② DESCRIPTION：镜像仓库描述。

③ STARS：镜像仓库收藏数，表示该镜像仓库的受欢迎程度，类似于GitHub的Stars。

④ OFFICAL：表示是否为官方仓库，该列标记为[OK]的镜像均由各软件的官方项目组创建和维护。由结果可知，java这个镜像仓库是官方仓库，而其他的仓库都不是镜像仓库。

⑤ AUTOMATED：表示是否是自动构建的镜像仓库。

示例2：

<pre><code class="language-shell line-numbers">docker search -s 10 java
</code></pre>

<h2>下载镜像[重要]</h2>

使用命令<code>docker pull</code>命令即可从Docker Registry上下载镜像
命令格式：

<pre><code class="language-shell line-numbers">docker pull [OPTIONS] NAME[:TAG|@DIGEST]
</code></pre>

参数：

<table>
<thead>
<tr>
  <th>Name, shorthand</th>
  <th>Default</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>--all-tags, -a</code></td>
  <td><code>false</code></td>
  <td>下载所有标签的镜像</td>
</tr>
<tr>
  <td><code>--disable-content-trust</code></td>
  <td><code>true</code></td>
  <td>忽略镜像的校验</td>
</tr>
</tbody>
</table>

示例1：

<pre><code class="language-shell line-numbers">docker pull java
</code></pre>

执行该命令后，Docker会从Docker Hub中的java仓库下载最新版本的Java镜像。

示例2：

该命令还可指定想要下载的镜像标签以及Docker Registry地址，例如：

<pre><code class="language-shell line-numbers">docker pull reg.itmuch.com/java:7
</code></pre>

这样就可以从指定的Docker Registry中下载标签为7的Java镜像。

<h2>列出镜像[重要]</h2>

使用<code>docker images</code>命令即可列出已下载的镜像。

执行该命令后，将会看到类似于如下的表格：

<pre><code class="language-shell line-numbers">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
java                latest              861e95c114d6        4 weeks ago         643.1 MB
hello-world         latest              c54a2cc56cbb        5 months ago        1.848 kB
</code></pre>

该表格包含了5列，含义如下：

① REPOSITORY：镜像所属仓库名称。

② TAG：镜像标签。默认是latest，表示最新。

③ IMAGE ID：镜像ID，表示镜像唯一标识。

④ CREATED：镜像创建时间。

⑤ SIZE：镜像大小。

命令格式：

<pre><code class="language-shell line-numbers">docker images [OPTIONS] [REPOSITORY[:TAG]]
</code></pre>

参数：

<table>
<thead>
<tr>
  <th>Name, shorthand</th>
  <th>Default</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>--all, -a</code></td>
  <td><code>false</code></td>
  <td>列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）</td>
</tr>
<tr>
  <td><code>--digests</code></td>
  <td><code>false</code></td>
  <td>显示摘要信息</td>
</tr>
<tr>
  <td><code>--filter, -f</code></td>
  <td></td>
  <td>显示满足条件的镜像</td>
</tr>
<tr>
  <td><code>--format</code></td>
  <td><code>false</code></td>
  <td>通过Go语言模板文件展示镜像</td>
</tr>
<tr>
  <td><code>--no-trunc</code></td>
  <td><code>false</code></td>
  <td>不截断输出，显示完整的镜像信息</td>
</tr>
<tr>
  <td><code>--quiet, -q</code></td>
  <td><code>false</code></td>
  <td>只显示镜像ID</td>
</tr>
</tbody>
</table>

示例：

<pre><code class="language-shell line-numbers">docker images
docker images java
docker images java:8
docker images --digests
docker images --filter "dangling=true"   # 展示虚悬镜像
</code></pre>

<h2>删除本地镜像[重要]</h2>

使用<code>docker rmi</code>命令即可删除指定镜像。
命令格式：

<pre><code class="language-shell line-numbers">docker rmi [OPTIONS] IMAGE [IMAGE...]
</code></pre>

参数：

<table>
<thead>
<tr>
  <th>Name, shorthand</th>
  <th>Default</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>--force, -f</code></td>
  <td><code>false</code></td>
  <td>强制删除</td>
</tr>
<tr>
  <td><code>--no-prune</code></td>
  <td><code>false</code></td>
  <td>不移除该镜像的过程镜像，默认移除</td>
</tr>
</tbody>
</table>

例1：删除指定名称的镜像。

<pre><code class="language-shell line-numbers">docker rmi hello-world
</code></pre>

表示删除hello-world这个镜像。
例2：删除所有镜像。

<pre><code class="language-shell line-numbers">docker rmi -f $(docker images)
</code></pre>

-f参数表示强制删除。

<h2>保存镜像</h2>

使用<code>docker save</code>即可保存镜像。
命令格式：

<pre><code class="language-shell line-numbers">docker save [OPTIONS] IMAGE [IMAGE...]
</code></pre>

参数：

<table>
<thead>
<tr>
  <th>Name, shorthand</th>
  <th>Default</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>--output, -o</code></td>
  <td></td>
  <td>Write to a file, instead of STDOUT</td>
</tr>
</tbody>
</table>

例1：

<pre><code class="language-shell line-numbers">docker save busybox &gt; busybox.tar
docker save --output busybox.tar busybox
</code></pre>

<h2>加载镜像</h2>

使用<code>docer load</code>命令即可加载镜像。
命令格式：

<pre><code class="language-shell line-numbers">docker load [OPTIONS]
</code></pre>

参数：

<table>
<thead>
<tr>
  <th>Name, shorthand</th>
  <th>Default</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>--input, -i</code></td>
  <td></td>
  <td>从文件加载而非STDIN</td>
</tr>
<tr>
  <td><code>--quiet, -q</code></td>
  <td><code>false</code></td>
  <td>静默加载</td>
</tr>
</tbody>
</table>

例1：

<pre><code class="language-shell line-numbers">docker load &lt; busybox.tar.gz
docker load --input fedora.tar
</code></pre>

<h2>构建镜像[重要]</h2>

通过Dockerfile构建镜像。
命令格式：

<pre><code class="language-shell line-numbers">docker build [OPTIONS] PATH | URL | -
</code></pre>

参数：

<table>
<thead>
<tr>
<th>Name, shorthand</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--add-host</code></td>
<td></td>
<td>添加自定义从host到IP的映射，格式为（host:ip）</td>
</tr>
<tr>
<td><code>--build-arg</code></td>
<td></td>
<td>设置构建时的变量</td>
</tr>
<tr>
<td><code>--cache-from</code></td>
<td></td>
<td>作为缓存源的镜像</td>
</tr>
<tr>
<td><code>--cgroup-parent</code></td>
<td></td>
<td>容器可选的父cgroup</td>
</tr>
<tr>
<td><code>--compress</code></td>
<td><code>false</code></td>
<td>使用gzip压缩构建上下文</td>
</tr>
<tr>
<td><code>--cpu-period</code></td>
<td><code>0</code></td>
<td>限制CPU CFS (Completely Fair Scheduler) 周期</td>
</tr>
<tr>
<td><code>--cpu-quota</code></td>
<td><code>0</code></td>
<td>限制CPU CFS (Completely Fair Scheduler) 配额</td>
</tr>
<tr>
<td><code>--cpu-shares, -c</code></td>
<td><code>0</code></td>
<td>CPU使用权重（相对权重）</td>
</tr>
<tr>
<td><code>--cpuset-cpus</code></td>
<td></td>
<td>指定允许执行的CPU</td>
</tr>
<tr>
<td><code>--cpuset-mems</code></td>
<td></td>
<td>指定允许执行的内存</td>
</tr>
<tr>
<td><code>--disable-content-trust</code></td>
<td><code>true</code></td>
<td>忽略校验</td>
</tr>
<tr>
<td><code>--file, -f</code></td>
<td></td>
<td>指定Dockerfile的名称，默认是‘PATH/Dockerfile’</td>
</tr>
<tr>
<td><code>--force-rm</code></td>
<td><code>false</code></td>
<td>删除中间容器</td>
</tr>
<tr>
<td><code>--iidfile</code></td>
<td></td>
<td>将镜像ID写到文件中</td>
</tr>
<tr>
<td><code>--isolation</code></td>
<td></td>
<td>容器隔离技术</td>
</tr>
<tr>
<td><code>--label</code></td>
<td></td>
<td>设置镜像使用的元数据</td>
</tr>
<tr>
<td><code>--memory, -m</code></td>
<td><code>0</code></td>
<td>设置内存限制</td>
</tr>
<tr>
<td><code>--memory-swap</code></td>
<td><code>0</code></td>
<td>设置Swap的最大值为内存+swap，如果设置为-1表示不限swap</td>
</tr>
<tr>
<td><code>--network</code></td>
<td><code>default</code></td>
<td>在构建期间设置RUN指令的网络模式</td>
</tr>
<tr>
<td><code>--no-cache</code></td>
<td><code>false</code></td>
<td>构建镜像过程中不使用缓存</td>
</tr>
<tr>
<td><code>--pull</code></td>
<td><code>false</code></td>
<td>总是尝试去更新镜像的新版本</td>
</tr>
<tr>
<td><code>--quiet, -q</code></td>
<td><code>false</code></td>
<td>静默模式，构建成功后只输出镜像ID</td>
</tr>
<tr>
<td><code>--rm</code></td>
<td><code>true</code></td>
<td>构建成功后立即删除中间容器</td>
</tr>
<tr>
<td><code>--security-opt</code></td>
<td></td>
<td>安全选项</td>
</tr>
<tr>
<td><code>--shm-size</code></td>
<td><code>0</code></td>
<td>指定<code>/dev/shm</code> 目录的大小</td>
</tr>
<tr>
<td><code>--squash</code></td>
<td><code>false</code></td>
<td>将构建的层压缩成一个新的层</td>
</tr>
<tr>
<td><code>--tag, -t</code></td>
<td></td>
<td>设置标签，格式：name:tag，tag可选</td>
</tr>
<tr>
<td><code>--target</code></td>
<td></td>
<td>设置构建时的目标构建阶段</td>
</tr>
<tr>
<td><code>--ulimit</code></td>
<td></td>
<td>Ulimit 选项</td>
</tr>
</tbody>
</table>

拓展阅读

Docker命令：<a href="https://docs.docker.com/engine/reference/commandline/docker/">https://docs.docker.com/engine/reference/commandline/docker/</a>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>227</wp:post_id>
		<wp:post_date><![CDATA[2018-10-23 17:00:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-23 09:00:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[docker-%e9%95%9c%e5%83%8f%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="docker"><![CDATA[docker]]></category>
		<category domain="post_tag" nicename="docker"><![CDATA[docker]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				python函数式编程		</title>
		<link>https://blog.easysc.cn/?p=286</link>
		<pubDate>Mon, 29 Oct 2018 03:59:50 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=286</guid>
		<description></description>
		<content:encoded>
				<![CDATA[参考引用：<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317848428125ae6aa24068b4c50a7e71501ab275d52000">函数式编程</a>

<h2>高阶函数</h2>

<h3>map/reduce</h3>

<h4>map</h4>

map接收两个参数，一个是函数，另一个是Iterable,map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回
map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。
eg:

<pre><code class="language-python line-numbers">def add_one(x):
    return x + 1


print(list(map(add_one, [1, 2, 3, 4, 5, 6, 7])))
--------------
结果：
[2, 3, 4, 5, 6, 7, 8]
</code></pre>

<h4>reduce</h4>

reduce 也接收两个参数，一个是有<code>两个参数的函数</code>，一个是Iterable,他会把Iterable中的两个数传入函数，并将结果和第三个数再传入函数，以此循环，直到Iterable中没有数
eg:

<pre><code class="language-python line-numbers"># 求和的例子
# 导入reduce
from functools import reduce
def total(x, y):
    return x + y

# rang左闭右开
print(reduce(total, range(1, 10)))
-------
结果：
45
</code></pre>

<h3>filter</h3>

如字面理解的那样，过滤
接收两个参数，一个是函数，一个是Iterable
通过函数返回的布尔类型来决定是否保留或者丢弃元素
True:保留，False:丢弃
eg:

<pre><code class="language-python line-numbers">def even_num(x):
    return x % 2 == 0


print(list(filter(even_num, range(1, 100))))
----
结果：
[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48]
</code></pre>

<h3>sorted</h3>

使用sorted可以对dict,list等进行排序，接收一个key参数，如果传了key参数，那么，会先按照key参数进行排序，然后再把原本的参数按照这个排序来排列
eg:

<pre><code class="language-python line-numbers"># list
li = [1,5,8,3,26,7]

# dict
L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]


def by_name(t):
    return t[0]


def by_score(t):
    return -t[1]


print(sorted(L, key=by_name))
print(sorted(L, key=by_score))
print(sorted(li))
---
结果：
[('Adam', 92), ('Bart', 66), ('Bob', 75), ('Lisa', 88)]
[('Adam', 92), ('Lisa', 88), ('Bob', 75), ('Bart', 66)]
[1, 3, 5, 7, 8, 26]
</code></pre>

<hr />

<h2>返回函数</h2>

高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
注：返回函数是惰性调用，返回的只是一个函数，只有调用这个函数的时候才会真正计算值
而且调用创建函数的时候返回的函数都是一个新的函数，即使传入的值是一样的

<pre><code class="language-python line-numbers">def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum

f1 = lazy_sum(1, 3, 5, 7, 9)
f2 = lazy_sum(1, 3, 5, 7, 9)
print(f1==f2)
-----
结果：False
</code></pre>

<h3>闭包</h3>

函数中写函数，内层函数可以调用外层函数的参数
eg:

<pre><code class="language-python line-numbers">def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
</code></pre>

函数的作用域可参考:<a href="https://www.cnblogs.com/saintdingspage/p/7788958.html">https://www.cnblogs.com/saintdingspage/p/7788958.html</a>

<h2>匿名函数</h2>

没有名字的函数，可以简化代码
用法:lambda [参数名称][:][表达式]

<pre><code class="language-python line-numbers"># 如上面map的例子可以简化为
print(list(map(lambda x: x+1, [1, 2, 3, 4, 5, 6, 7])))
# 可以通过赋值给变量调用
f = lambda x: x+1
print(list(map(f, [1, 2, 3, 4, 5, 6, 7])))
</code></pre>

注：匿名函数只是一个表达式，后面只能包含<code>一个</code>语句

<h2>装饰器</h2>

可参考:<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650705784&amp;idx=2&amp;sn=bfbc2f5a5d4cfd6a079a8efe13c00936&amp;chksm=bea6feab89d177bdc46685c1466c6331b9437d5d4db91c0e0eb576cbcafe316893cbfee08d21&amp;mpshare=1&amp;scene=23&amp;srcid=1101xtaCKdJmxLSnoYIsmfws#rd">作为程序员，起码要知道的 Python 修饰器！</a>
个人感觉类似于Java中spring的aop+注解，当不想修改一个函数，又想在调用这个函数之前或者之后加入其它代码的时候可以用
eg:

<pre><code class="language-python line-numbers">def log(text):
    def decorator(func):
        def wapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)

        return wapper

    return decorator


@log('execute')
def now():
    print('2015-3-25')
---
结果：
execute now():
2015-3-25
</code></pre>

相当于增强原函数的功能，加了装饰器之后，实际调用的是装饰器中返回的内容，具体可参考上面的url

<h3>偏函数</h3>

functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。
eg:

<pre><code class="language-python line-numbers">from functools import partial
int2 = partial(int, base=2)

print(int2('1010'))
</code></pre>

这里相当于将int()函数的第二个参数base默认为2，变为一个新的函数int2()，调用起来更方便

<pre><code class="language-python line-numbers"># 上面的方法等同于
def int2(x, base=2):
    return int(x, base)
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>286</wp:post_id>
		<wp:post_date><![CDATA[2018-10-29 11:59:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-29 03:59:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[python%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="python"><![CDATA[python]]></category>
		<category domain="post_tag" nicename="python"><![CDATA[python]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				DruidDataSource配置		</title>
		<link>https://blog.easysc.cn/?p=307</link>
		<pubDate>Thu, 22 Nov 2018 06:53:30 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=307</guid>
		<description></description>
		<content:encoded>
				<![CDATA[DruidDataSource配置兼容DBCP，但个别配置的语意有所区别。
<a href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8">参考地址</a>

<table>
<thead>
<tr>
  <th>配置</th>
  <th>缺省值</th>
  <th>说明</th>
</tr>
</thead>
<tbody>
<tr>
  <td>name</td>
  <td></td>
  <td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。如果没有配置，将会生成一个名字，格式是："DataSource-" + System.identityHashCode(this). 另外配置此属性至少在1.0.5版本中是不起作用的，强行设置name会出错。<a href="http://blog.csdn.net/lanmo555/article/details/41248763">详情-点此处</a>。</td>
</tr>
<tr>
  <td>url</td>
  <td></td>
  <td>连接数据库的url，不同数据库不一样。例如：<br />mysql : jdbc:mysql://10.20.153.104:3306/druid2<br /> oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td>
</tr>
<tr>
  <td>username</td>
  <td></td>
  <td>连接数据库的用户名</td>
</tr>
<tr>
  <td>password</td>
  <td></td>
  <td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">详细看这里</a></td>
</tr>
<tr>
  <td>driverClassName</td>
  <td>根据url自动识别</td>
  <td>这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName</td>
</tr>
<tr>
  <td>initialSize</td>
  <td>0</td>
  <td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td>
</tr>
<tr>
  <td>maxActive</td>
  <td>8</td>
  <td>最大连接池数量</td>
</tr>
<tr>
  <td>maxIdle</td>
  <td>8</td>
  <td>已经不再使用，配置了也没效果</td>
</tr>
<tr>
  <td>minIdle</td>
  <td></td>
  <td>最小连接池数量</td>
</tr>
<tr>
  <td>maxWait</td>
  <td></td>
  <td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td>
</tr>
<tr>
  <td>poolPreparedStatements</td>
  <td>false</td>
  <td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td>
</tr>
<tr>
  <td>maxPoolPreparedStatementPerConnectionSize</td>
  <td>-1</td>
  <td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td>
</tr>
<tr>
  <td>validationQuery</td>
  <td></td>
  <td>用来检测连接是否有效的sql，要求是一个查询语句，常用select 'x'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。</td>
</tr>
<tr>
  <td>validationQueryTimeout</td>
  <td></td>
  <td>单位：秒，检测连接是否有效的超时时间。底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法</td>
</tr>
<tr>
  <td>testOnBorrow</td>
  <td>true</td>
  <td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td>
</tr>
<tr>
  <td>testOnReturn</td>
  <td>false</td>
  <td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td>
</tr>
<tr>
  <td>testWhileIdle</td>
  <td>false</td>
  <td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td>
</tr>
<tr>
  <td>keepAlive</td>
  <td>false<br/>（1.0.28）</td>
  <td>连接池中的minIdle数量以内的连接，空闲时间超过minEvictableIdleTimeMillis，则会执行keepAlive操作。</td>
</tr>
<tr>
  <td>timeBetweenEvictionRunsMillis</td>
  <td>1分钟（1.0.14）</td>
  <td>有两个含义：<br />1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。<br />2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td>
</tr>
<tr>
  <td>numTestsPerEvictionRun</td>
  <td>30分钟（1.0.14）</td>
  <td>不再使用，一个DruidDataSource只支持一个EvictionRun</td>
</tr>
<tr>
  <td>minEvictableIdleTimeMillis</td>
  <td></td>
  <td>连接保持空闲而不被驱逐的最小时间</td>
</tr>
<tr>
  <td>connectionInitSqls</td>
  <td></td>
  <td>物理连接初始化的时候执行的sql</td>
</tr>
<tr>
  <td>exceptionSorter</td>
  <td>根据dbType自动识别</td>
  <td>当数据库抛出一些不可恢复的异常时，抛弃连接</td>
</tr>
<tr>
  <td>filters</td>
  <td></td>
  <td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：<br />监控统计用的filter:stat<br />日志用的filter:log4j<br />防御sql注入的filter:wall</td>
</tr>
<tr>
  <td>proxyFilters</td>
  <td></td>
  <td>类型是List&lt;com.alibaba.druid.filter.Filter>，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td>
</tr>
</tbody>
</table>

<h1>1. 通用配置</h1>

DruidDataSource大部分属性都是参考DBCP的，如果你原来就是使用DBCP，迁移是十分方便的。

<pre data-language=XML><code class="language-markup line-numbers"> &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; 
     &lt;property name="url" value="${jdbc_url}" /&gt;
     &lt;property name="username" value="${jdbc_user}" /&gt;
     &lt;property name="password" value="${jdbc_password}" /&gt;

     &lt;property name="filters" value="stat" /&gt;

     &lt;property name="maxActive" value="20" /&gt;
     &lt;property name="initialSize" value="1" /&gt;
     &lt;property name="maxWait" value="60000" /&gt;
     &lt;property name="minIdle" value="1" /&gt;

     &lt;property name="timeBetweenEvictionRunsMillis" value="60000" /&gt;
     &lt;property name="minEvictableIdleTimeMillis" value="300000" /&gt;

     &lt;property name="testWhileIdle" value="true" /&gt;
     &lt;property name="testOnBorrow" value="false" /&gt;
     &lt;property name="testOnReturn" value="false" /&gt;

     &lt;property name="poolPreparedStatements" value="true" /&gt;
     &lt;property name="maxOpenPreparedStatements" value="20" /&gt;

     &lt;property name="asyncInit" value="true" /&gt;
 &lt;/bean&gt;
</code></pre>

<ul>
<li>在上面的配置中，通常你需要配置url、username、password，maxActive这三项。</li>
<li>Druid会自动跟url识别驱动类名，如果连接的数据库非常见数据库，配置属性driverClassName</li>
<li>asyncInit是1.1.4中新增加的配置，如果有initialSize数量较多时，打开会加快应用启动时间</li>
</ul>

<h1>2. 连接阿里云AnalyticDB参考配置</h1>

使用Druid连接池连接阿里云<a href="https://www.alibabacloud.com/zh/product/analytic-db">AnalyticDB</a> 建议配置<a href="https://github.com/alibaba/druid/wiki/KeepAlive_cn">keepAlive=true</a> ，并使用<a href="http://repo.maven.apache.org/maven2/com/alibaba/druid/1.1.12/">1.1.12</a> 之后的版本

<pre data-language=XML><code class="language-markup line-numbers">  &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; 
     &lt;!-- 基本属性 url、user、password --&gt;
     &lt;property name="url" value="${jdbc_url}" /&gt;
     &lt;property name="username" value="${jdbc_user}" /&gt;
     &lt;property name="password" value="${jdbc_password}" /&gt;

     &lt;!-- 配置初始化大小、最小、最大 --&gt;
     &lt;property name="initialSize" value="5" /&gt;
     &lt;property name="minIdle" value="10" /&gt; 
     &lt;property name="maxActive" value="20" /&gt;

     &lt;!-- 配置获取连接等待超时的时间 --&gt;
     &lt;property name="maxWait" value="60000" /&gt;

     &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;
     &lt;property name="timeBetweenEvictionRunsMillis" value="2000" /&gt;

     &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;
     &lt;property name="minEvictableIdleTimeMillis" value="600000" /&gt;
     &lt;property name="maxEvictableIdleTimeMillis" value="900000" /&gt;

     &lt;property name="validationQuery" value="show status like '%Service_Status%'" /&gt;
     &lt;property name="testWhileIdle" value="true" /&gt;
     &lt;property name="testOnBorrow" value="false" /&gt;
     &lt;property name="testOnReturn" value="false" /&gt;

     &lt;property name="keepAlive" value="true" /&gt;
     &lt;property name="phyMaxUseCount" value="100000" /&gt;

     &lt;!-- 配置监控统计拦截的filters --&gt;
     &lt;property name="filters" value="stat" /&gt; 
 &lt;/bean&gt;
</code></pre>

<h2>2.1 注意事项</h2>

<ul>
<li>validationQuery是show status like '%Service_Status%'</li>
</ul>

<h1>3. 连接阿里云Data Lake Analytics参考配置</h1>

使用Druid连接池连接阿里云<a href="https://www.aliyun.com/product/datalakeanalytics">Data Lake Analytics</a> 建议配置<a href="https://github.com/alibaba/druid/wiki/KeepAlive_cn">keepAlive=true</a>，并使用<a href="http://repo.maven.apache.org/maven2/com/alibaba/druid/1.1.12/">1.1.12</a> 之后的版本

<pre data-language=XML><code class="language-markup line-numbers">  &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; 
     &lt;!-- 基本属性 url、user、password --&gt;
     &lt;property name="url" value="${jdbc_url}" /&gt;
     &lt;property name="username" value="${jdbc_user}" /&gt;
     &lt;property name="password" value="${jdbc_password}" /&gt;

     &lt;!-- 配置初始化大小、最小、最大 --&gt;
     &lt;property name="initialSize" value="1" /&gt;
     &lt;property name="minIdle" value="1" /&gt; 
     &lt;property name="maxActive" value="10" /&gt;

     &lt;!-- 配置获取连接等待超时的时间 --&gt;
     &lt;property name="maxWait" value="60000" /&gt;

     &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;
     &lt;property name="timeBetweenEvictionRunsMillis" value="2000" /&gt;

     &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;
     &lt;property name="minEvictableIdleTimeMillis" value="600000" /&gt;
     &lt;property name="maxEvictableIdleTimeMillis" value="900000" /&gt;

     &lt;property name="validationQuery" value="select 1" /&gt;
     &lt;property name="testWhileIdle" value="true" /&gt;
     &lt;property name="testOnBorrow" value="false" /&gt;
     &lt;property name="testOnReturn" value="false" /&gt;

     &lt;property name="keepAlive" value="true" /&gt;
     &lt;property name="phyMaxUseCount" value="100000" /&gt;

     &lt;!-- 配置监控统计拦截的filters --&gt;
     &lt;property name="filters" value="stat" /&gt; 
 &lt;/bean&gt;
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>307</wp:post_id>
		<wp:post_date><![CDATA[2018-11-22 14:53:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-22 06:53:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[druiddatasource%e9%85%8d%e7%bd%ae]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e5%ba%93"><![CDATA[数据库]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e5%ba%93"><![CDATA[数据库]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				Java设计模式		</title>
		<link>https://blog.easysc.cn/?p=313</link>
		<pubDate>Wed, 03 Apr 2019 01:16:57 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=313</guid>
		<description></description>
		<content:encoded>
				<![CDATA[<h2>策略模式</h2>

<h2>观察者模式</h2>

<h2>装饰模式</h2>

<h2>单例模式</h2>

<h2>命令模式</h2>

<h2>模板模式</h2>

<h2>工厂模式（抽象工厂，工厂方法）</h2>

<h2>适配器模式和外观模式</h2>

<h2>迭代器和组合模式</h2>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>313</wp:post_id>
		<wp:post_date><![CDATA[2019-04-03 09:16:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-03 01:16:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[java%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="java"><![CDATA[java]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_old_date]]></wp:meta_key>
		<wp:meta_value><![CDATA[2018-11-28]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				docker安装（centos）		</title>
		<link>https://blog.easysc.cn/?p=314</link>
		<pubDate>Wed, 26 Dec 2018 06:19:04 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://106.12.110.168:9000/?p=314</guid>
		<description></description>
		<content:encoded>
				<![CDATA[参考：<a href="http://itmuch.com/docker/02-docker-install/">docker安装</a>

<h2>系统要求</h2>

CentOS 7或更高版本（内核3.1以上）
centos-extras 仓库必须处于启用状态，该仓库默认启用，但如果您禁用了该仓库，请按照https://wiki.centos.org/AdditionalResources/Repositories 中的描述重新启用。
建议使用overlay2 存储驱动

<h2>yum安装</h2>

<h3>卸载老版本</h3>

在CentOS中，老版本Docker名称是docker 或docker-engine ，而Docker CE的软件包名称是docker-ce 。因此，如已安装过老版本的Docker，需使用如下命令卸载。

<pre><code class="language-bash line-numbers">sudo yum remove docker \
                  docker-common \
                  docker-selinux \
                  docker-engine
</code></pre>

需要注意的是，执行该命令只会卸载Docker本身，而不会删除Docker存储的文件，例如镜像、容器、卷以及网络文件等。这些文件保存在/var/lib/docker 目录中，需要手动删除。

<h3>安装仓库</h3>

执行以下命令，安装Docker所需的包。其中，yum-utils 提供了yum-config-manager 工具；device-mapper-persistent-data 及 lvm2 则是devicemapper 存储驱动所需的包。

<pre><code class="language-bash line-numbers">//在此之前最好yum clean all,yum update
sudo yum install -y yum-utils device-mapper-persistent-data lvm2
</code></pre>

执行如下命令，安装stable 仓库。必须安装stable 仓库，即使你想安装edge 或test 仓库中的Docker构建版本。

<pre><code class="language-bash line-numbers">sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
</code></pre>

<h3>安装Docker ce</h3>

执行以下命令，更新yum的包索引

<pre><code class="language-bash line-numbers">sudo yum makecache fast
</code></pre>

安装最新版的docker-ce

<pre><code class="language-bash line-numbers">sudo yum install docker-ce
</code></pre>

指定安装版本

<pre><code class="line-numbers">yum list docker-ce.x86_64  --showduplicates | sort -r
sudo yum install docker-ce-&lt;VERSION&gt;
</code></pre>

启动docker

<pre><code class="line-numbers">sudo systemctl start docker
</code></pre>

ps:如果启动不起来可尝试更换docker版本，自测用最新版本可能会出现问题，可尝试降一个版本
验证安装是否正确

<pre><code class="line-numbers">sudo docker run hello-world
</code></pre>

<h3>参考文档</h3>

CentOS 7安装Docker官方文档：<a href="https://docs.docker.com/engine/installation/linux/docker-ce/centos/">https://docs.docker.com/engine/installation/linux/docker-ce/centos/</a> ，文档中还讲解了在CentOS 7中安装Docker CE的其他方式

<h3>升级Docker CE</h3>

如需升级Docker CE，只需执行如下命令：

<pre><code class="language-bash line-numbers">sudo yum makecache fast
</code></pre>

按照安装Docker的步骤，即可升级Docker

<h3>shell一键安装</h3>

curl -fsSL get.docker.com -o get-docker.sh
sudo sh get-docker.sh]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>314</wp:post_id>
		<wp:post_date><![CDATA[2018-12-26 14:19:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-26 06:19:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[docker%e5%ae%89%e8%a3%85%ef%bc%88centos%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="docker"><![CDATA[docker]]></category>
		<category domain="post_tag" nicename="docker"><![CDATA[docker]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-disabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-insert]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-heading-levels]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-alttext]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_ez-toc-exclude]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_f06ed77a35a99beec3b6ca6f5309d999]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_d5049a1286f9b7cc9140b9e98920e2e6]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_180b33b5212e813f38ae1f1d11ec5738]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_5c5f83a54643c312810bcc4dc322c7f4]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				elasticsearch部署和采集		</title>
		<link>https://blog.easysc.cn/?p=321</link>
		<pubDate>Tue, 15 Jan 2019 03:23:15 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://120.77.81.112:9000/?p=321</guid>
		<description></description>
		<content:encoded>
				<![CDATA[部署分为几个部分
1.Elasticsearch
2.Logstash
3.Kibanna
4.Filebeats(可选)
注：本文使用版本为5.3.3，以上内容均为此版本，<a href="https://www.elastic.co/">官网传送门</a>

<h2>elasticsearch安装</h2>

安装之前，先建一个linux账号，因为elasticsearch不允许用root账号启动

创建用户组

<pre><code class="language-bash line-numbers">groupadd es
</code></pre>

创建用户并分配到用户组

<pre><code class="language-bash line-numbers">useradd es -g es
</code></pre>

以下elasticsearch简称es
将elasticsearch的文件夹授权给新建的用户es(需要root权限)

<pre><code class="language-bash line-numbers">chown -R es:es elasticsearch-5.5.3
</code></pre>

启动(-d表示后台运行。第一次启动建议不加-d，没问题之后加上-d)

<pre><code class="language-bash line-numbers">./bin/elasticsearch -d
</code></pre>

可能遇到的问题
<a href="https://www.cnblogs.com/xxoome/p/6663993.html">https://www.cnblogs.com/xxoome/p/6663993.html</a>
<a href="https://www.cnblogs.com/sunsky303/p/9676646.html">https://www.cnblogs.com/sunsky303/p/9676646.html</a>
验证启动
方式一：

<pre><code class="language-bash line-numbers">//es绑定到本地（默认）的时候使用
curl -XGET 'http://localhost:9200'
</code></pre>

方式二：
浏览器访问 [服务器ip]:9200
返回如下信息

<pre><code class="language-json line-numbers">{
  "name" : "node-1",
  "cluster_name" : "elasticsearch",
  "cluster_uuid" : "riaWrZzvSJOzk3no7gJb8w",
  "version" : {
    "number" : "5.5.3",
    "build_hash" : "9305a5e",
    "build_date" : "2017-09-07T15:56:59.599Z",
    "build_snapshot" : false,
    "lucene_version" : "6.6.0"
  },
  "tagline" : "You Know, for Search"
}
</code></pre>

<h2>kibana安装</h2>

编辑 config/kibana.yml
修改server.host为服务器ip
填上能够访问的es的地址elasticsearch.url（默认为本地）
将kibana所在文件夹授权给es(需要root权限)

<pre><code class="language-bash line-numbers">chown -R es:es [kibana文件夹]
</code></pre>

后台启动

<pre><code class="language-bash line-numbers">nohup ./bin/kibana &amp;
</code></pre>

验证安装
访问 [服务器ip]:5601

<h2>logstash安装</h2>

解压之后
在config目录下新建log.conf
将logstash所在文件夹授权给es(需要root权限)

<pre><code class="line-numbers">chown -R es:es [logstash文件夹]
</code></pre>

<h3>配置数据库采集</h3>

最好是在数据库中新建一个只有要采集数据表的查看权限的用户来读取日志
CREATE USER 'es'@'localhost' IDENTIFIED BY '密码';
GRANT SELECT ON [数据库名].[日志表名称] to 'es'@'localhost';
将mysql的连接jar包放到logstash的根目录下
这里以mysql-connector-java-5.1.13-bin.jar为例
编辑log.conf，加入如下内容

<pre><code class="line-numbers">input {
#filebeat采集入口
  beats {
    port =&gt; 5000
  }
 jdbc {
      #clean_run =&gt; true #表示是否重新采集
      jdbc_driver_library =&gt; "mysql-connector-java-5.1.13-bin.jar"
      jdbc_driver_class =&gt; "com.mysql.jdbc.Driver"
      jdbc_user =&gt; "es"
      jdbc_password=&gt; "密码"
      jdbc_connection_string =&gt; "jdbc:mysql://localhost:3306/数据库?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull"
      jdbc_validate_connection =&gt; true
      schedule =&gt; "* * * * *"
      use_column_value =&gt; true
      tracking_column =&gt; "id"
      statement =&gt; "要执行的sql"
      jdbc_paging_enabled =&gt; true
      jdbc_page_size =&gt; 5000
      type =&gt; "es中的type"
    }
}
output{
elasticsearch {
      hosts =&gt; "[es的地址]"
      index =&gt; "es中的index"
      #将id作为es中的id
      document_id =&gt; "%{id}"
    }
    stdout {
      codec =&gt; json_lines
    }
}
</code></pre>

<code>:sql_last_value</code>表示字段上次执行的值，可用tracking_column配置，可以用在要执行的sql中
eg:

<pre><code class="line-numbers">select * from table_user where id &gt; :sql_last_value
</code></pre>

后台启动logstash

<pre><code class="line-numbers">nohup bin/logstash -f config/log.conf &amp;
</code></pre>

jdbc部分的配置可以查看<a href="https://www.elastic.co/guide/en/logstash/5.3/input-plugins.html">input插件</a>中的jdbc部分
<a href="https://www.elastic.co/guide/en/logstash/5.3/output-plugins.html">output插件</a>
<a href="https://www.elastic.co/guide/en/logstash/5.3/filter-plugins.html">filter插件</a>

<h3>采集Tomcat日志（例子）</h3>

编辑logstash配置文件在input下加入

<pre><code class="line-numbers">beats {
    port =&gt; 5000
}
</code></pre>

和Input同级加入

<pre><code class="line-numbers">filter {
  #Only matched data are send to output.
  if [type] == "log"{
    grok {
      match =&gt; { "message" =&gt; "%{TIMESTAMP_ISO8601:time}\s\[%{LOGLEVEL:level}\]\[(?&lt;threadName&gt;([\s\S]*))\]\s%{NOTSPACE:loggerName}\s(?&lt;info&gt;([\s\S]*))"}
    }
    date {
      match =&gt; [ "time", "yyyy-MM-dd HH:mm:ss.SSS" ]
    }
  }
}
</code></pre>

Output修改为

<pre><code class="line-numbers">if [type] == "log"{
    elasticsearch {
      action =&gt; "index"          #The operation on ES
      hosts  =&gt; "[es的地址]"   #ElasticSearch host, can be array.
      index  =&gt; "systemlog"         #The index to write data to.
}
} else {
   elasticsearch {
      hosts =&gt; "[es的地址]"
      index =&gt; "数据库采集的index"
      document_id =&gt; "%{id}"
    }
    stdout {
      codec =&gt; json_lines
    }
  }
</code></pre>

<h4>filebeat安装</h4>

备份原有fielebeat.yml
新建filebeat.yml
写入

<pre><code class="language-yaml line-numbers">filebeat:
  prospectors:
    -
      paths:
        - [tomcat的catalina.out的绝对路径]
      input_type: log
      encoding: utf-8
      multiline:
       #pattern: '^[[:space:]]+(at|\.{3})\b|^Caused by:'
        pattern: '^[0-9]{4}-[0-9]{2}-[0-9]{2}'
        negate: true
        match: after
      processors:
        - drop_fields:
            fields: ["source","beat","host"]
output:
  logstash:
    hosts: ["[logstash地址]:[logstash中配置的filebeat的端口号]"]
setup.kibana:
  host: ["kibanna地址加端口号"]
</code></pre>

后台启动filebeat

<pre><code class="language-bash line-numbers">nohup ./filebeat -c ./filebeat.yml &amp;
</code></pre>

<h4>filebeat执行的过程</h4>

采集日志（通过multiline区分多行和单行）-》发往logstash-》logstash通过filter对日志信息进行拆解（通过grok表达式）为多个字段-》通过output插入es

<h4>附录</h4>

grok调试网站
<a href="http://grokdebug.herokuapp.com/">http://grokdebug.herokuapp.com/</a>(科学上网)
<a href="http://grok.qiexun.net/">http://grok.qiexun.net/</a>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>321</wp:post_id>
		<wp:post_date><![CDATA[2019-01-15 11:23:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-01-15 03:23:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[elasticsearch%e9%83%a8%e7%bd%b2%e5%92%8c%e9%87%87%e9%9b%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="elasticsearch"><![CDATA[elasticsearch]]></category>
		<category domain="post_tag" nicename="es"><![CDATA[es]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				ES2015(ES6)		</title>
		<link>https://blog.easysc.cn/?p=342</link>
		<pubDate>Tue, 26 Feb 2019 07:26:26 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">http://120.77.81.112:9000/?p=342</guid>
		<description></description>
		<content:encoded>
				<![CDATA[Reference：

Vue官方推荐<a href="https://babeljs.io/docs/en/learn">ES2015</a>

<a href="https://www.jianshu.com/p/220a54f7adce">ES2015简介和基本语法</a>

<a href="https://github.com/lukehoban/es6features">Luke Hoban's GitHub</a>

<a href="http://es6.ruanyifeng.com/">ECMAScript 6 入门</a>

<h2>目录</h2>

<a href="#箭头（Arrows）">箭头（Arrows）</a>

<a href="#类（Classes）">类（Classes）</a>

[增强的对象文字（Enhanced Object Literals）](#增强的对象文字（Enhanced Object Literals）)

[模板字符串（Template Strings）](#模板字符串（Template Strings）)

<a href="#解构（Destructuring）">解构（Destructuring）</a>

[默认值+其他+扩散（Default + Rest + Spread）](#默认值+其他+扩散（Default + Rest + Spread）)

[Let + Const](#Let + Const)

<h3>箭头（Arrows）</h3>

箭头是使用箭头(<code>=&gt;</code>)定义的函数，类似于JDK8中的<code>-&gt;</code>定义函数的方式，如果箭头函数在另外一个函数内时，他可以访问父函数中的参数，使用tihs的时候和围绕他的代码一致，可参考下列例子，箭头函数相当于一个匿名函数。

<pre><code class="language-javascript line-numbers">// Expression bodies
var odds = evens.map(v =&gt; v + 1);
var nums = evens.map((v, i) =&gt; v + i);

// Statement bodies
nums.forEach(v =&gt; {
  if (v % 5 === 0)
    fives.push(v);
});

// Lexical this
var bob = {
  _name: "Bob",
  _friends: [],
  printFriends() {
    this._friends.forEach(f =&gt;
      console.log(this._name + " knows " + f));
  }
};

// Lexical arguments
function square() {
  let example = () =&gt; {
    let numbers = [];
    for (let number of arguments) {
      numbers.push(number * number);
    }

    return numbers;
  };

  return example();
}

square(2, 4, 7.5, 8, 11.5, 21); // returns: [4, 16, 56.25, 64, 132.25, 441]
</code></pre>

<h3>类（Classes）</h3>

ES2015类比基于原型的OO模式简单。拥有一个方便的声明形式使类模式更易于使用，并鼓励互操作性。类支持基于原型的继承，超级调用，实例和静态方法以及构造函数。

这里需要注意的是，在类中定义的方法，都是带有作用域的普通函数，而不是箭头函数，方法内第一层所引用的this都指向当前实例，如果实例方法内包含箭头函数，则引擎就会根据包含层级把箭头函数内引用的this所指向的实际对象一直向上层搜索，直到到达一个函数作用域或块级作用域为止。如果一直搜索到达了运行环境的最上层，就会被指向undefined

<pre><code class="language-javascript line-numbers">class SkinnedMesh extends THREE.Mesh {
  constructor(geometry, materials) {
    super(geometry, materials);

    this.idMatrix = SkinnedMesh.defaultMatrix();
    this.bones = [];
    this.boneMatrices = [];
    //...
  }
  update(camera) {
    //...
    super.update();
  }
  static defaultMatrix() {
    return new THREE.Matrix4();
  }
}
</code></pre>

<h3>增强的对象文字（Enhanced Object Literals）</h3>

<pre><code class="language-javascript line-numbers">var obj = {
    // Sets the prototype. "__proto__" or '__proto__' would also work.
    __proto__: theProtoObj,
    // Computed property name does not set prototype or trigger early error for
    // duplicate __proto__ properties.
    ['__proto__']: somethingElse,
    // Shorthand for ‘handler: handler’
    handler,
    // Methods
    toString() {
     // Super calls
     return "d " + super.toString();
    },
    // Computed (dynamic) property names
    [ "prop_" + (() =&gt; 42)() ]: 42
};
</code></pre>

<h3>模板字符串（Template Strings）</h3>

当我们使用普通的字符串时，会使用单引号或双引号来包裹字符串的内容，在ES2015的模板字符串中使用反勾号`。

<ul>
<li>支持元素注入：

可以将一些元素注入到ES2015的模板字符串中。

<pre><code class="language-javascript line-numbers">//Syntax:`before-${injectVariable}-after`
const str="hello world"
const num=1
const bool=true
const obj={foo:'bar'}
const arr=[1,2,3]

const str1=`String:${str}`         //=&gt;String:hello world
const str2=`Number:${num}`         //=&gt;Number:1
const str3=`Boolean:${bool}`      //=&gt;Boolean:true
const str4=`Object:${obj}`        //=&gt;Object:[object Object]
const str5=`Array:${arr}`        //=&gt;Array:1,2,3
</code></pre></li>
<li>支持换行

<pre><code class="language-javascript line-numbers">/**
*Syntax:`
*content
*`
*/
const sql=`
select * from Users 
where FirstName='mike' 
limit 5;
`
</code></pre>

多行字符串无法像普通字符串使用双引号嵌套单引号来表达字符串中的字符串，可以使用反斜杠将需要显示的反勾号转义为普通的字符。添加了&#96;用于打印`。

<pre><code class="language-javascript line-numbers">const str1="Here is the outer string.'This is a string in another string'"
const str2=`Here is the outer string.\`This is a string in another string\``
</code></pre></li>
</ul>

<h3>解构（Destructuring）</h3>

解构允许使用模式匹配进行绑定，支持数组和对象，解构是故障弱化（fail-soft）的，就像标准对象搜索<code>foo["bar"]</code>一样，当没找到数据时产出<code>undefined</code>

<pre><code class="language-javascript line-numbers">  // list matching
  var [a, , b] = [1,2,3];

  // object matching
  var { op: a, lhs: { op: b }, rhs: c }
         = getASTNode()

  // object matching shorthand
  // binds `op`, `lhs` and `rhs` in scope
  var {op, lhs, rhs} = getASTNode()

  // Can be used in parameter position
  function g({name: x}) {
    console.log(x);
  }
  g({name: 5})

  // Fail-soft destructuring
  var [a] = [];
  a === undefined;

  // Fail-soft destructuring with defaults
  var [a = 1] = [];
  a === 1;
</code></pre>

<h3>默认值+其他+扩散（Default + Rest + Spread）</h3>

被调用者设定默认值，将数组变为方法调用参数的连续输入，将后面的参数作为一个数组，Rest <code>arguments</code>更直接地替换了对常见情况的需求和解决

类似于Python的写法

<code>javascript
  function f(x, y=12) {
    // y is 12 if not passed (or passed as undefined)
    return x + y;
  }
  f(3) == 15</code>

<code>javascript
  function f(x, ...y) {
    // y is an Array
    return x * y.length;
  }
  f(3, "hello", true) == 6</code>

<code>javascript
  function f(x, y, z) {
    return x + y + z;
  }
  // Pass each elem of array as argument
  f(...[1,2,3]) == 6</code>

<h3>Let + Const</h3>

let和const是继var之后新的变量定义方法，与let相比，const更容易被理解。const就是constant的缩写，用于定义变量，即不可变量。const定义常量的原理是阻隔变量名所对应的内存地址被改变。

<code>let</code>声明的变量只在它所在的代码块有效。

<code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。

变量与内存之间的关系由三个部分组成：变量名、内存绑定和内存（内存地址）。

<img src="https://upload-images.jianshu.io/upload_images/4041074-3059994760d79989.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/379/format/webp" alt="" />

ECMAScript在对变量的引用进行读取时，会从该变量对应的内存地址所指向的内存空间中读取内容。当用户改变变量的值时，引擎会重新从内存中分配一个新的内存空间以存储新的值，并将新的内存地址与变量进行绑定。const的原理便是在变量名与内存地址之间建立不可变得绑定，当后面的程序尝试申请新的内存空间时，引擎便会抛出错误。

在ES2015中，let可以说是var的进化版本，var大部分情况下可以被let替代，let和var的异同点如下表：

<img src="https://upload-images.jianshu.io/upload_images/4041074-8eb1b5256f85390b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/827/format/webp" alt="" />

<pre><code class="language-javascript line-numbers">function f() {
  {
    let x;
    {
      // this is ok since it's a block scoped name
      const x = "sneaky";
      // error, was just defined with `const` above
      x = "foo";
    }
    // this is ok since it was declared with `let`
    x = "bar";
    // error, already declared above in this block
    let x = "inner";
  }
}
</code></pre>

### Iterators + For...Of

ECMAScript引入了一种新的循环语句for...of，主要的用途是代替for...in循环语句；为Array对象引入了Array.forEach方法以代替for循环，Array.forEach方法的特点是自带闭包，以解决因为缺乏块级作用域导致需要使用取巧的方法来解决var的作用域问题。
 因为块级作用域的存在，使得for循环中的每一个当前值可以仅保留在所对应的循环体中，配合for-of循环语句更是免去了回调函数的使用。

<code>for...of</code>可以用来遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等

<pre><code class="language-javascript line-numbers">let a = [1,2,3,7,8,9,10,12];
let b = "字符串"
function fun(){
    a.forEach(e=&gt;{
      console.log(`这是一个循环-${e}`)
    })
    console.log('\r\n')

    for (const v of b){
      console.log(`使用for..of写的循环-${v}`)
    }

    console.log('\r\n')

    for(let k in b){
      console.log(`使用for..in写的循环-${k}`)
    }

    //配合解构遍历json数组
    for (const {a,c} of map){
      console.log(`使用for..of写的map循环--${a}-${c}`)
    }
}
--------
这是一个循环-1
这是一个循环-2
这是一个循环-3

使用for..of写的循环-字
使用for..of写的循环-符
使用for..of写的循环-串

使用for..in写的循环-0
使用for..in写的循环-1
使用for..in写的循环-2

使用for..of写的map循环--1-2
</code></pre>

<h3>生成器（Generators）</h3>

类似Python中的生成器

生成器的主要功能是：通过一段程序，持续迭代或枚举出符合某个公式或算法的有序数列中的元素，这个程序便是用于实现这个公式或算法的，而不需要将目标数列完整写出。

生成器函数使用<code>function*</code>表示这是一个生成器函数

<pre><code class="language-javascript line-numbers">function* fibo(){
//...
}

const fnName = function*() {/*...*/}
</code></pre>

生成器函数的函数体内容将会是所生成的生成器的执行内容，在这些内容之中，<code>yield</code>语句的引入使得生成器函数与普通函数有了区别。<code>yield</code>语句的作用与return语句冇些相似，但并非退出函数体，而是切出当前函数的运行时（此处为一个类协程，Semi-coroutine),与此同时可以将一个值（可以是任何类型）带到主线程中。

<pre><code class="language-javascript line-numbers">var fibonacci = {
  [Symbol.iterator]: function*() {
    var pre = 0, cur = 1;
    for (;;) {
      var temp = pre;
      pre = cur;
      cur += temp;
      yield cur;
    }
  }
}

for (var n of fibonacci) {
  // truncate the sequence at 1000
  if (n &gt; 1000)
    break;
  console.log(n);
}
</code></pre>

如上方的例子，<code>yield</code>的作用是在每次执行到<code>yield</code>的时候输出cur的值，相当于每次执行生成器的时候，<code>fibonacci</code>的for就循环一次，到<code>yield</code>的时候返回结果，下次调用的时候继续循环（不是重新开始）

生成器的接口是（仅使用<a href="http://typescriptlang.org/">TypeScript</a>类型语法进行展示）

<pre><code class="language-javascript line-numbers">interface Generator extends Iterator {
    next(value?: any): IteratorResult;
    throw(exception: any);
}
</code></pre>

<h3>编码（Unicode）</h3>

支持完整Unicode的非破坏性添加，包括字符串中的新unicode文字形式和<code>u</code>处理代码点的新RegExp 模式，以及用于处理21位代码点级别的字符串的新API。这些新增功能支持在JavaScript中构建全局应用程序

<pre><code class="language-javascript line-numbers">// same as ES5.1
"𠮷".length == 2

// new RegExp behaviour, opt-in ‘u’
"𠮷".match(/./u)[0].length == 2

// new form
"\u{20BB7}" == "𠮷" == "\uD842\uDFB7"

// new String ops
"𠮷".codePointAt(0) == 0x20BB7

// for-of iterates code points
for(var c of "𠮷") {
  console.log(c);
}
</code></pre>

<h3>模块（Modules）</h3>

组件定义的语言层面的支持，从流行的JavaScript模块加载器（AMD，CommonJS）中编纂成的模式，由主机定义的默认加载程序定义的运行时行为。隐式异步模型 - 在请求的模块可用和处理之前，代码不会执行。

<ol>
<li>引入模块

ES Module中有很多种引入模块的方法，最基本的便是import语句。

<pre><code class="language-javascript line-numbers">import name form 'module-name'
import * as name from 'module-name'
import {member} from 'module-name'
import {meber as alias} from 'module-name'
import 'module-name'
</code></pre>

引入默认模块

<pre><code class="language-javascript line-numbers">//Syntax:import namespace from 'module-name'

import http from 'http'
import url from 'url'
import fs from 'fs'
</code></pre>

引入模块部分接口
ES2015中的 模块化机制支持引入一个模块的部分接口

<pre><code class="language-javascript line-numbers">//Syntax:import {meber1,meber2} from 'module-name'

import {isEmpty} from 'lodash'
import {EventEmitter} from 'events'

console.log(isEmpty({}))  //=&gt;true
</code></pre>

从模块中局部引用的接口定义一个别名，以避免指代不明或接口重名的情况出现

<pre><code class="language-javascript line-numbers">//Syntax:import {meber as alias} from 'module-name'
import {createServer as createHTTPServer} from 'http'
import {createServer as createHTTPSServer} from 'https'
</code></pre>

引入全部局部接口到指定命名空间
有的模块不会定义默认接口，只是定义了若干个命名接口，将其中的所有接口定义到一个命名空间中，使用以下语法。

<pre><code class="language-javascript line-numbers">//Syntax:import * as namespace from 'module-name'
import * as lib from 'module'
lib.method1()
lib.method2()
</code></pre>

混入引入默认接口和命名接口
同时引入默认接口和其它命名接口，可以通过混合语句来实现。

<pre><code class="language-javascript line-numbers">//Syntax:import {default as  &lt;default name&gt;,method1} from 'module-name'
import {default as Client,utils} from 'module'
</code></pre>

注意：引入的默认接口必须要使用as语句被赋予一个别名，因为在除模块引入语句以外的地方default是一个保留关键字，所以无法使用。

<pre><code class="language-javascript line-numbers">import {default ,utils} from 'module'  //Wrong
</code></pre>

简洁的语法

<pre><code class="language-javascript line-numbers">//Syntax:import  &lt;default name&gt;,{&lt;named modules&gt;} from 'module-name'
import Client,{utils} from 'module'
import Client,* as lib from 'module'
</code></pre>

不引入接口，仅运行模块代码
在某些场景下，一些模块并不需要向外暴露任何接口，只需要执行内容的代码（如系统初始化）。

<pre><code class="language-javascript line-numbers">//Syntax:import 'module-name'
import 'system-apply'
</code></pre></li>
<li>定义模块

ES Module中以文件名及其相对或绝对路径作为该模块被引用时的标识。</p></li>
<li><p>暴露模块

暴露单一接口
如果需要定义一个项目内的工具集模块，需要将其中定义的函数或者对象暴露到该文件所定义的模块上。

<pre><code class="language-javascript line-numbers">//Syntax:export &lt;statement&gt;

//module.js
export const apiRoot='http://example.com/api'
export function method(){
   //...
}
export class foo{
   //...
}

//app.js
import {method,foo} from 'module.js'
</code></pre>

export 语句后所跟着的语句需要具有生命部分和赋值部分
1.声明部分（Statement）为export语句提供了所暴露接口的标识；
2.赋值部分（Assignment）为export语句提供了接口的值。

那些不符合这两个条件的语句无法被暴露在当前文件所定义的模块上，以下代码被视为非法代码。

<pre><code class="language-javascript line-numbers">//1
export 'foo'
//2
const foo='bar'
export foo
//3
export function(){}
</code></pre>

暴露模块默认接口
在某些时候，一个模块只需要暴露一个接口，比如需要使用模块机制定义一个只含有一个单一工具类的模块时，就没有必要让这个工具类成为该模块的一部分，而是让这个类成为这个模块。

<pre><code class="language-javascript line-numbers">//Syntax:export default &lt;value&gt;
//client.js
export default class Client{
  //...
}
//app.js
import Client from 'client.js'
</code></pre>

混合使用暴露接口语句
开发者可以为一个模块同时定义默认接口和其它命名接口

<pre><code class="language-javascript line-numbers">//module.js
export default class  Client{
   //...
}
export const foo='bar'

//app.js
import Client,{foo} from 'module'
</code></pre>

暴露一个模块的所有接口
在第三方类库的开发中，不免需要将各种不同的功能块分成若干个模块来进行开发，以便管理。ES Module可以将import语句和export组合，直接将一个模块的接口暴露到另外一个模块上。

<pre><code class="language-javascript line-numbers">//Syntax:export * from  'other-module'
//module-1.js
export function foo(){/*....*/}
//module.js
export * from 'module-1'
//app.js
import {foo} from 'module'
</code></pre>

暴露一个模块的部分接口

<pre><code class="language-javascript line-numbers">//Syntax:export {member} from 'module-name'
export {member} from 'module'
export {default as ModuleDefault} from 'module'
</code></pre>

暴露一个模块的默认接口
可以将一个模块的默认接口作为另一个模块的默认接口。

<pre><code class="language-javascript line-numbers">export {default} from  'module'
</code></pre></li>
</ol>

<h3>Symbol</h3>

这是一种新的原始数据类型，表示独一无二的值，Symbol的值具有互不等价的特性，开发者同时可以为Symbol值添加一个描述。

基本数据类型有6种：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）

<ol>
<li>基本语法

<ul>
<li>生成唯一的Symbol值

执行Symbol({description})函数可以生成一个与其它Symbol值互不等价的Symbol值，其中Symbol()函数可以接受一个除Symbol值以外的值作为该Symbol值的描述，以便通过开发者的辨认判断其为可选的。

<pre><code class="language-javascript line-numbers">//Syntax:Symbol([description]):Symbol

const symbol=Symbol()    //=&gt;Symbol()
const symbolForSomething=Symbol('something')   //=&gt;Symbol(something)
const symbolWithNumber=Symbol(3.14)    //=&gt;Symbol(3.14)
const symbolWidthObject=Symbol({'foo':'bar'})  //=&gt;Symbol([object Object])

//Don't use a symbol to be another symbol's description
const anotherSymbol=Symbol(symbol)  //=&gt;TypeError:Cannot convert a Symbol value to a string
</code></pre>

描述值仅仅是起到描述的作用，不会对Symbol值本身起到任何改变的作用。即便是两个具有相同描述值的Symbol值也不具有等价性。

<pre><code class="language-javascript line-numbers">const symbol1=Symbol('footer')
const symbol2=Symbol('footer')
symbol1==symbol2   //=&gt;false
</code></pre>

注意：Symbol函数并不是一个构造函数，不能使用new语句来生成Symbol“对象”，否则会抛出TypeError错误。

由此可知，Symbol是一种值类型而非引用类型。这就意味着如果将Symbol值作为函数形参进行传递，将会进行复制值传递而非引用传递，这跟其它值类型（字符串，数字等）的行为是一致的。

<pre><code class="language-javascript line-numbers">const symbol=Symbol('hello')
function fn1(_symbol){
   return _symbol==symbol
}
console.log(fn1(symbol))   //=&gt;true
function fn2(_symbol){
   _symbol=null
  console.log(_symbol)
}
fn2(symbol)  //=&gt;null 
</code></pre>

如果希望得到一个Symbol“对象”，可以使用Object()函数实现。

<pre><code class="language-javascript line-numbers">const symbol=Symbol('foo')
typeof symbol   //=&gt;symbol
const symbolObj=Object(symbol)
typeof symbolObj   //=&gt;object
</code></pre></li>
<li>注册全局可重用Symbol

ES2015标准除了提供具有唯一性的Symbol值以外，同样还允许开发者在当前运行时中定义一些全局有效性的Symbol。开发者可以通过一个key向当前运行时注册一个需要在其他程序中使用的Symbol。

<pre><code class="language-javascript line-numbers">//Syntax:Symbol.for([key]):Symbol
const symbol=Symbol.for('footer')
</code></pre>

Symbol. for ()与Symbol ()的区別是，Symbol . for ()会根据传入的key在全局作用域中注册一个Symbol值，如果某一个key从未被注册到全局作用域中，便会创建一个Symbol值并根据key注册到全局环境中。如果该key己被注册，就会返冋一个与第一次使用所创建的Symbol值等价的Symbol值。

<pre><code class="language-javascript line-numbers">const symbol = Symbol.for('foo')
const obj ={}
obj[symbol] = 'bar'

const anotherSymbol = Symbol.for('foo')

console.log(symbol === anotherSymbol) //=&gt; true
console.log (obj [anotherSymbol])    //=&gt; jbar
</code></pre>

这在大型系统的开发中可以用于一些全局的配罝数据中或者用于需要多处使用的数据中。</p></li>
<li><p>获取全局Symbol的key

既然可以通过字符串的key在全局环境中注册一个全局Symbol，那么同样也可以根据这些全局的Symbol获取到它们所对应的key。

<pre><code class="language-javascript line-numbers">//Syntax:Symbol kefFor(&lt;global symbol&gt;):String
const  symbol=Symbol.for('foobar')
console.log(Symbol.keyFor(symbol))   //=&gt;foobar
</code></pre></li>
</ul>

<ol start="2">
<li>常用Symbol值</li>
</ol>

ES2015标准定义了一些内置的常用Symbol值，这些Symbol值的应用深入到了 ECMAScript引擎运行中的各个角落。开发者可以运用这些常用Symbol值对代码的内部运行逻辑进行修改或拓展，以实现更高级的需求。

<img src="https://upload-images.jianshu.io/upload_images/4041074-a9b31c5726c545db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/835/format/webp" alt="" />

<ol start="3">
<li>Symbol.iterator</li>
</ol>

在ES2015标准中定义了可迭代对象（Iterable Object)和新的for-of循环语句，其中可迭代对象并不是一种类型，而是带有@@iterator属性和可以被for-of循环语句所遍历的对象的统称。

<ol start="4">
<li>Symbol.hasInstance</li>
</ol>

Symbol.haslnstance为开发者提供了可以用于扩展instanceof语句内部逻辑的权限，开发者可以将其作为属性
键，用于为一个类定义静态方法，该方法的第一个形参便是被检测的对象，而该方法的返回值便是决定了当次instanceof语句的返回结果。

<pre><code class="language-javascript line-numbers">class Foo (
  static [Symbol.haslnstance](obj) {
  console.log(obj)      //=&gt;{}
  return true
 }
}
console.log({} instanceof Foo)    //=&gt;true
</code></pre>

<ol start="5">
<li>Symbol.match</li>
</ol>

Symbol.match是正则表达式（或者对象）在作为字符串使用match ()方法时，内部运行逻辑的自定义逻辑入口。开发者可以通过Symbol.match来自行实现match ()方法的运行逻辑，比如利用strcmp (在ECMAScript中为String.prototype.localeCompare())来实现。

<pre><code class="language-javascript line-numbers">const  re = /foo/
re[Symbol.match]=function(str){
     const regexp=this
     console.log(str)   //=&gt;bar
    //...
    return true
}
'bar'.match(re)   //=&gt;true 
</code></pre>

<ol start="6">
<li>Symbol.toPrimitive</li>
</ol>

Symbol.toPrimitive为开发者提供了更高级的控制权力，使得引用类型的对象在转换为值类型时可以进行自定义处理，无论是转换为字符串还是数字。

开发者可以使用Symbol.toPrimitive作为属性键为对象定义一个方法，这个方法接受一个参数，这个参数用于判断当前隐式转换的目标类型。

<img src="https://upload-images.jianshu.io/upload_images/4041074-596c1427adf57cb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/824/format/webp" alt="" />

需要注意的是，这里的default并不是因为目标类型无法被转换，而是因为语法上容易造成混乱。

<ol start="7">
<li>Symbol.toStringTag</li>
</ol>

常用Symbol的值在前面己经提到过，它的作用是可以决定这个类的实例在调用toString()方法时的标签内容。

在Object类及其所有的子类的实例中，有一个利用Symbol .toStringTag作为键的属性，该属性定义着当这个对象的toString()方法被调用时，所返回的Tag的内容是什么。

比如在开发者定义的类中，就可以通过Symbol. toStringTag来修改toString()屮的标签内容，利用它作为属性键为类型定义一个Getter。

<pre><code class="language-javascript line-numbers">class Bar {}
class Foo{
   get  [Symbol.toStringTagl() { return  'Bar'}
}

const obj =new  Foo()
console.log(obj .toString() )   //=&gt; [object Bar]
</code></pre></li>
</ol>

<h3>Proxy</h3>

Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。

<pre><code class="language-javascript line-numbers">var proxy = new Proxy({}, {
  get: function(target, property) {
    return 35;
  }
});

proxy.time // 35
proxy.name // 35
proxy.title // 35
</code></pre>

<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有<code>Proxy</code>的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。<code>get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。

注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例（上例是<code>proxy</code>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。

一个技巧是将 Proxy 对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用。

<pre><code class="language-javascript line-numbers">var object = { proxy: new Proxy(target, handler) };
</code></pre>

Proxy 实例也可以作为其他对象的原型对象。

<pre><code class="language-javascript line-numbers">var proxy = new Proxy({}, {
  get: function(target, property) {
    return 35;
  }
});

let obj = Object.create(proxy);
obj.time // 35
</code></pre>

上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。

同一个拦截器函数，可以设置拦截多个操作。

<pre><code class="language-javascript line-numbers">var handler = {
  get: function(target, name) {
    if (name === 'prototype') {
      return Object.prototype;
    }
    return 'Hello, ' + name;
  },

  apply: function(target, thisBinding, args) {
    return args[0];
  },

  construct: function(target, args) {
    return {value: args[1]};
  }
};

var fproxy = new Proxy(function(x, y) {
  return x + y;
}, handler);

fproxy(1, 2) // 1
new fproxy(1, 2) // {value: 2}
fproxy.prototype === Object.prototype // true
fproxy.foo === "Hello, foo" // true
</code></pre>

对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。

下面是 Proxy 支持的拦截操作一览，一共 13 种。

<ul>
<li><strong>get(target, propKey, receiver)</strong>：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy['foo']</code>。</li>
<li><strong>set(target, propKey, value, receiver)</strong>：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy['foo'] = v</code>，返回一个布尔值。</li>
<li><strong>has(target, propKey)</strong>：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li>
<li><strong>deleteProperty(target, propKey)</strong>：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li>
<li><strong>ownKeys(target)</strong>：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li>
<li><strong>getOwnPropertyDescriptor(target, propKey)</strong>：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li>
<li><strong>defineProperty(target, propKey, propDesc)</strong>：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li>
<li><strong>preventExtensions(target)</strong>：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li>
<li><strong>getPrototypeOf(target)</strong>：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li>
<li><strong>isExtensible(target)</strong>：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li>
<li><strong>setPrototypeOf(target, proto)</strong>：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li><strong>apply(target, object, args)</strong>：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li>
<li><strong>construct(target, args)</strong>：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li>
</ul>

<h3>Promise</h3>

Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。

<h3>Reflect</h3>

<code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。

（1） 将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。

（2） 修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。

<pre><code class="language-javascript line-numbers">// 老写法
try {
  Object.defineProperty(target, property, attributes);
  // success
} catch (e) {
  // failure
}

// 新写法
if (Reflect.defineProperty(target, property, attributes)) {
  // success
} else {
  // failure
}
</code></pre>

（3） 让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。

<pre><code class="language-javascript line-numbers">// 老写法
'assign' in Object // true

// 新写法
Reflect.has(Object, 'assign') // true
</code></pre>

（4）<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。

<pre><code class="language-javascript line-numbers">Proxy(target, {
  set: function(target, name, value, receiver) {
    var success = Reflect.set(target,name, value, receiver);
    if (success) {
      console.log('property ' + name + ' on ' + target + ' set to ' + value);
    }
    return success;
  }
});
</code></pre>

上面代码中，<code>Proxy</code>方法拦截<code>target</code>对象的属性赋值行为。它采用<code>Reflect.set</code>方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。

下面是另一个例子。

<pre><code class="language-javascript line-numbers">var loggedObj = new Proxy(obj, {
  get(target, name) {
    console.log('get', target, name);
    return Reflect.get(target, name);
  },
  deleteProperty(target, name) {
    console.log('delete' + name);
    return Reflect.deleteProperty(target, name);
  },
  has(target, name) {
    console.log('has' + name);
    return Reflect.has(target, name);
  }
});
</code></pre>

上面代码中，每一个<code>Proxy</code>对象的拦截操作（<code>get</code>、<code>delete</code>、<code>has</code>），内部都调用对应的<code>Reflect</code>方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。

有了<code>Reflect</code>对象以后，很多操作会更易读。

<pre><code class="language-javascript line-numbers">// 老写法
Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1

// 新写法
Reflect.apply(Math.floor, undefined, [1.75]) // 1
</code></pre>

<strong>静态方法</strong>
<code>Reflect</code>对象一共有 13 个静态方法。

<ul>
<li>Reflect.apply(target, thisArg, args)</li>
<li>Reflect.construct(target, args)</li>
<li>Reflect.get(target, name, receiver)</li>
<li>Reflect.set(target, name, value, receiver)</li>
<li>Reflect.defineProperty(target, name, desc)</li>
<li>Reflect.deleteProperty(target, name)</li>
<li>Reflect.has(target, name)</li>
<li>Reflect.ownKeys(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.getOwnPropertyDescriptor(target, name)</li>
<li>Reflect.getPrototypeOf(target)</li>
<li>Reflect.setPrototypeOf(target, prototype)</li>
</ul>

上面这些方法的作用，大部分与<code>Object</code>对象的同名方法的作用都是相同的，而且它与<code>Proxy</code>对象的方法是一一对应的。下面是对它们的解释。

<h3>Map + Set + WeakMap +WeakSet</h3>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>342</wp:post_id>
		<wp:post_date><![CDATA[2019-02-26 15:26:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-26 07:26:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[es2015es6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="es6"><![CDATA[es6]]></category>
		<category domain="category" nicename="front"><![CDATA[front]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				Spring boot集成Quartz		</title>
		<link>https://blog.easysc.cn/?p=392</link>
		<pubDate>Thu, 04 Apr 2019 02:24:07 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">https://blog.easysc.cn/?p=392</guid>
		<description></description>
		<content:encoded>
				<![CDATA[说明：
Spring boot2.x之后Quartz有Springboot的Starter，这里分两部分，使用<code>2.0.5.RELEASE</code>作为Spring boot版本

<ul>
<li>不使用Starter集成</li>
<li>使用Starter集成</li>
</ul>

<h2>不使用Starter集成</h2>

引入pom

<pre data-language=XML><code class="language-markup line-numbers">&lt;dependency&gt;
    &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;
    &lt;artifactId&gt;quartz&lt;/artifactId&gt;
    &lt;version&gt;2.3.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;
    &lt;artifactId&gt;quartz-jobs&lt;/artifactId&gt;
    &lt;version&gt;2.3.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
    &lt;!--使用Springboot中的Spring版本--&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h3>在resource下新建quartz.properties</h3>

<pre><code class="language-properties line-numbers">org.quartz.scheduler.instanceName=MyScheduler
org.quartz.scheduler.instanceId=AUTO
org.quartz.threadPool.threadCount=5
org.quartz.scheduler.rmi.export = false
org.quartz.scheduler.rmi.proxy = false
org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool
org.quartz.scheduler.wrapJobExecutionInUserTransaction = false
# 默认存储在内存中
#org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore
# 这里使用数据库存储，需导入sql，sql位置：quartz包下（官网下载）org/quartz/impl/jdbcjobstore
org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreTX
org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegate
org.quartz.jobStore.tablePrefix=QRTZ_
org.quartz.jobStore.dataSource=myDS
# 使用Druid替换默认的C3P0
org.quartz.dataSource.myDS.connectionProvider.class=com.cc.fortest.common.config.DruidConnectionProvider
org.quartz.dataSource.myDS.driver=com.mysql.jdbc.Driver
org.quartz.dataSource.myDS.URL=jdbc:mysql://127.0.0.1:3306/quartz?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false
org.quartz.dataSource.myDS.user=root
org.quartz.dataSource.myDS.password=123456
org.quartz.dataSource.myDS.maxConnection=5
</code></pre>

<h3>配置类</h3>

<pre><code class="language-java line-numbers">import org.quartz.Scheduler;
import org.springframework.beans.factory.config.PropertiesFactoryBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;
import org.springframework.scheduling.quartz.SchedulerFactoryBean;

import java.io.IOException;
import java.util.Properties;

@Configuration
public class SchedledConfiguration {

    @Bean(name = "SchedulerFactory")
    public SchedulerFactoryBean schedulerFactoryBean() throws IOException {
        SchedulerFactoryBean factory = new SchedulerFactoryBean();
        factory.setQuartzProperties(quartzProperties());
        return factory;
    }

    @Bean
    public Properties quartzProperties() throws IOException {
        PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
        propertiesFactoryBean.setLocation(new ClassPathResource("/quartz.properties"));
        //在quartz.properties中的属性被读取并注入后再初始化对象
        propertiesFactoryBean.afterPropertiesSet();
        return propertiesFactoryBean.getObject();
    }

    @Bean(name = "Scheduler")
    public Scheduler scheduler(SchedulerFactoryBean SchedulerFactory) {
        return SchedulerFactory.getScheduler();
    }
}
</code></pre>

<h3>新建一个Job</h3>

<pre><code class="language-java line-numbers">import org.quartz.Job;
import org.quartz.JobDataMap;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;

import java.util.Date;

public class MyJob implements Job {
    public static final String CRON = "0/5 * * * * ?";

    @Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        System.out.println("任务执行进入,执行时间, "+new Date());
        JobDataMap dataMap = jobExecutionContext.getMergedJobDataMap();
        String name = dataMap.getString("name");
        System.out.println("Hello "+name);
    }
}
</code></pre>

<h3>测试类</h3>

<pre><code class="language-java line-numbers">    @Autowired
    @Qualifier("Scheduler")
    private Scheduler scheduler;

    @Test
    public void quartzTest() throws SchedulerException, IOException {
        scheduler.start();
        JobDataMap jobDataMap = new JobDataMap();
        jobDataMap.put("name", "John");
        JobDetail jobDetail = JobBuilder.newJob(MyJob.class)
                .withIdentity(MyJob.class.getSimpleName(), "group")
                .setJobData(jobDataMap)
                .build();
        CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(MyJob.CRON);
        CronTrigger trigger = TriggerBuilder.newTrigger()
                .withIdentity(MyJob.class.getSimpleName(), "group")
                .withSchedule(cronScheduleBuilder)
                .build();
        try {
            scheduler.scheduleJob(jobDetail, trigger);
        } catch (SchedulerException e) {
            e.printStackTrace();
        }
        System.in.read();
    }
</code></pre>

<h3>使用Druid替换Quartz默认连接池C3P0</h3>

新建一个类实现<code>ConnectionProvider</code>

<pre><code class="language-java line-numbers">import com.alibaba.druid.pool.DruidDataSource;
import lombok.Data;
import org.quartz.SchedulerException;
import org.quartz.utils.ConnectionProvider;

import java.sql.Connection;
import java.sql.SQLException;

/**
 * 将Quartz的连接池改为Druid，常量Quartz自动注入
 */
@Data
public class DruidConnectionProvider implements ConnectionProvider {
    //JDBC驱动
    private String driver;
    //JDBC连接串
    private String URL;
    //数据库用户名
    private String user;
    //数据库用户密码
    private String password;
    //数据库最大连接数
    private int maxConnection;
    //数据库SQL查询每次连接返回执行到连接池，以确保它仍然是有效的。
    private String validationQuery;
    private boolean validateOnCheckout;
    private int idleConnectionValidationSeconds;
    private String maxCachedStatementsPerConnection;
    private String discardIdleConnectionsSeconds;
    private static final int DEFAULT_DB_MAX_CONNECTIONS = 10;
    private static final int DEFAULT_DB_MAX_CACHED_STATEMENTS_PER_CONNECTION = 120;
    //Druid连接池
    private DruidDataSource datasource;

    public Connection getConnection() throws SQLException {
        return datasource.getConnection();
    }
    public void shutdown() throws SQLException {
        datasource.close();
    }
    public void initialize() throws SQLException{
        if (this.URL == null) {
            throw new SQLException("DBPool could not be created: DB URL cannot be null");
        }
        if (this.driver == null) {
            throw new SQLException("DBPool driver could not be created: DB driver class name cannot be null!");
        }
        if (this.maxConnection &lt; 0) {
            throw new SQLException("DBPool maxConnectins could not be created: Max connections must be greater than zero!");
        }
        datasource = new DruidDataSource();
        try{
            datasource.setDriverClassName(this.driver);
        } catch (Exception e) {
            try {
                throw new SchedulerException("Problem setting driver class name on datasource: " + e.getMessage(), e);
            } catch (SchedulerException e1) {
            }
        }
        datasource.setUrl(this.URL);
        datasource.setUsername(this.user);
        datasource.setPassword(this.password);
        datasource.setMaxActive(this.maxConnection);
        datasource.setMinIdle(1);
        datasource.setMaxPoolPreparedStatementPerConnectionSize(DEFAULT_DB_MAX_CONNECTIONS);
        if (this.validationQuery != null) {
            datasource.setValidationQuery(this.validationQuery);
            if(!this.validateOnCheckout)
                datasource.setTestOnReturn(true);
            else
                datasource.setTestOnBorrow(true);
            datasource.setValidationQueryTimeout(this.idleConnectionValidationSeconds);
        }
    }
}
</code></pre>

<h2>使用Starter集成</h2>

引入pom

<pre data-language=XML><code class="language-markup line-numbers">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<pre><code class="language-java line-numbers">import org.quartz.JobDataMap;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.springframework.scheduling.quartz.QuartzJobBean;

import java.util.Date;

public class MyJob extends QuartzJobBean {
    public static final String CRON = "0/5 * * * * ?";

    @Override
    protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        System.out.println("任务执行进入,执行时间, "+new Date());
        JobDataMap dataMap = jobExecutionContext.getMergedJobDataMap();
        String name = dataMap.getString("name");
        System.out.println("Hello "+name);
    }
}
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>392</wp:post_id>
		<wp:post_date><![CDATA[2019-04-04 10:24:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-04 02:24:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[spring-boot%e9%9b%86%e6%88%90quartz]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="spring"><![CDATA[spring]]></category>
		<category domain="category" nicename="spring-boot"><![CDATA[spring boot]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				Spring boot注解		</title>
		<link>https://blog.easysc.cn/?p=395</link>
		<pubDate>Thu, 04 Apr 2019 02:25:22 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">https://blog.easysc.cn/?p=395</guid>
		<description></description>
		<content:encoded>
				<![CDATA[记一些springboot中用的较少但可能会用到的注解

<pre><code class="language-java line-numbers">//读取以te开头的配置文件
@ConfigurationProperties("te")
//加载自定义配置文件到spring上下文
@PropertySource()
//包扫描，默认是扫描当前包下的所有包
@ComponentScan(excludeFilters = {@ComponentScan.Filter(pattern = "^[C]",type = FilterType.REGEX)})
//一个接口有多个实现类时，优先使用有该注解的类
@Primary
//避免注入歧义
@Qualifier

/*
条件装配Bean
*/
//使用一个实现了Condition接口的类作为判断是否注入Bean
@Conditional

//根据配置active的配置文件来配置决定是否加载Bean，没配置active或default，这个Bean不会被加载
//JAVA_OPTS="-Dspring.profiles.active=dev"
@Profile
//可以从xml中加载Bean
@ImportResource
//指定Bean的Class，将其加载到容器中
@Import

/*
Spring EL表达式
*/
//代表占位符，它会读取山下文属性装配到属性中
${...}
//T（...）代表的是引入类，如果不是Java自身的类要写全限定名
#{T(Sytem).currentTimeMillis()}
//可以调用容器中的其他Bean的属性给当前属性赋值，beanName是容器中Bean的名称
#{beanName.str}
//这里问号是判断是否为空，如果不为空才会执行后面的方法
#{beanName.str?.toUpperCase()}
//还可以使用EL表达式进行算术运算，字符串比较，字符串连接，三位运算
@Value("#{beanName.str eq 'Spring Boot'}")//字符串比较

//给一个类增加新的方法（aop）
/*
 eg:
 @DeclareParents(value = "com.springboot2.x.learn.lang.CatService",defaultImpl = CatValidatorImpl.class)
    public CatValidator catValidator;
 CatService如果是一个接口，可跟一个+号，表示所有实现类
*/
@DeclareParents

//mybatis的注解，指定别名
@Alias
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>395</wp:post_id>
		<wp:post_date><![CDATA[2019-04-04 10:25:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-04 02:25:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[spring-boot%e6%b3%a8%e8%a7%a3]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="spring"><![CDATA[spring]]></category>
		<category domain="category" nicename="spring-boot"><![CDATA[spring boot]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				Quartz基本介绍		</title>
		<link>https://blog.easysc.cn/?p=398</link>
		<pubDate>Thu, 04 Apr 2019 02:29:32 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">https://blog.easysc.cn/?p=398</guid>
		<description></description>
		<content:encoded>
				<![CDATA[参考引用：

<a href="https://www.w3cschool.cn/quartz_doc/">Quartz官方文档</a>

<a href="https://blog.csdn.net/u010648555/article/details/54863144">Quartz大致介绍</a>

<a href="https://blog.csdn.net/yangshangwei/article/details/78172788#calendarintervaltrigger">Quartz-Trigger详解</a>

<h2>基本概念</h2>

<strong><em>Quartz是一个完全由Java编写的开源作业调度框架</em></strong>，是OpenSymphony开源组织在Job scheduling领域又一个开源项目，可以创建，暂停，取消，同时运行，处理多个定时任务，在设定时间到达时自动执行任务，且非常易用。

<h2>核心概念</h2>

<strong>Job</strong> 表示一个工作，要执行的具体内容。此<strong><em>接口</em></strong>中只有一个方法，如下：

<pre><code class="language-java line-numbers">void execute(JobExecutionContext context) 
</code></pre>

<strong>JobDetail</strong> 表示一个具体的可执行的调度程序，Job 是这个可执行程调度程序所要执行的内容，另外 JobDetail 还包含了这个任务调度的方案和策略。

<strong>Trigger</strong> 代表一个调度参数的配置，什么时候去调。

<strong>Scheduler</strong> 代表一个调度容器，一个调度容器中可以注册多个 JobDetail 和 Trigger。当 Trigger 与 JobDetail 组合，就可以被 Scheduler 容器调度了。

注：<strong>一个Job可以被多个Trigger 绑定，但是一个Trigger只能绑定一个Job！</strong>

<h2>定时器的种类</h2>

Quartz 中五种类型的 Trigger：

<ul>
<li>SimpleTrigger：用来触发只需执行一次或者在给定时间触发并且重复N次且每次执行延迟一定时间的任务</p></li>
<li><p>CronTirgger：使用Cron表达式来触发，附：<a href="http://www.bejson.com/othertools/cron/">Cron在线生成器</a></p></li>
<li><p>DailyTimeIntervalTrigger：指定每天的某个时间段内，以一定的时间间隔执行任务。并且它可以支持指定星期。</p></li>
<li><p>NthIncludedDayTrigger：用于在每一间隔类型的第几天执行 Job</p></li>
<li><p>CalendarIntervalTrigger：类似于SimpleTrigger，指定从某一个时间开始，以一定的时间间隔执行的任务</p></li>
</ul>

<h2>存储方式</h2>

<ul>
<li><p>RAMJobStore：使用内存作为存储</p></li>
<li><p>JDBCJobStore ：使用数据库作为存储</p></li>
</ul>

<table>
<thead>
<tr>
  <th><strong>类型</strong></th>
  <th><strong>优点</strong></th>
  <th><strong>缺点</strong></th>
</tr>
</thead>
<tbody>
<tr>
  <td>RAMJobStore</td>
  <td>不要外部数据库，配置容易，运行速度快</td>
  <td>因为调度程序信息是存储在被分配给JVM的内存里面，所以，当应用程序停止运行时，所有调度信息将被丢失。另外因为存储到JVM内存里面，所以可以存储多少个Job和Trigger将会受到限制</td>
</tr>
<tr>
  <td>JDBCJobStore</td>
  <td>支持集群，因为所有的任务信息都会保存到数据库中，可以控制事物，还有就是如果应用服务器关闭或者重启，任务信息都不会丢失，并且可以恢复因服务器关闭或者重启而导致执行失败的任务</td>
  <td>运行速度的快慢取决与连接数据库的快慢</td>
</tr>
</tbody>
</table>

<p>注：使用数据库方式时，需要配置数据源，并导入Quartz提供的sql，需要下载对应版本的Quartz，<a href="http://www.quartz-scheduler.org/downloads/">官网传送门</a>，sql位置：<code>org/quartz/impl/jdbcjobstore</code>，选择对应数据源的sql导入]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>398</wp:post_id>
		<wp:post_date><![CDATA[2019-04-04 10:29:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-04 02:29:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[quartz%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="java"><![CDATA[java]]></category>
		<category domain="post_tag" nicename="java"><![CDATA[java]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				wordpress docker搭建 https化记录		</title>
		<link>https://blog.easysc.cn/?p=404</link>
		<pubDate>Mon, 08 Apr 2019 01:38:52 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">https://blog.easysc.cn/?p=404</guid>
		<description></description>
		<content:encoded>
				<![CDATA[参考：

<a href="https://www.cnblogs.com/wushangjue/p/7795969.html">Centos7.4下用Docker-Compose部署WordPress</a>

<h2>使用docker-compose创建wordpress</h2>

安装略过

编写docker-compose.yml文件

写入如下内容：

<pre><code class="language-yaml line-numbers">version: '3'

services:
   db:
     image: mysql:5.7
     volumes:
       - db_data:/var/lib/mysql
     restart: always
     environment:
       MYSQL_ROOT_PASSWORD: "your password"
       MYSQL_DATABASE: wordpress
       MYSQL_USER: wordpress
       MYSQL_PASSWORD: wordpress

   wordpress:
     depends_on:
       - db
     image: wordpress:latest
     volumes:
        - wp_site:/var/www/html
     ports:
       - "9000:80"
     restart: always
     environment:
       WORDPRESS_DB_HOST: db:3306
       WORDPRESS_DB_USER: wordpress
       WORDPRESS_DB_PASSWORD: wordpress

volumes:
    db_data:
    wp_site:

networks:
  default:
    external:
      name: nginx-network
</code></pre>

docker创建一个网络

<pre><code class="language-bash line-numbers">docker network create nginx-network
</code></pre>

然后使用docker-compose构建

<pre><code class="language-bash line-numbers">docker-compose up -d
</code></pre>

<h2>配置Nginx</h2>

按照上面的内容

wordpress可以通过端口9000访问，但是现在先不忙访问

在对应的域名服务商上配置好域名映射，使域名能够正确访问到服务器的80端口（Nginx）

配置好了之后修改Nginx配置，将请求代理到9000端口

注：这时候还没有配置https

<pre><code class="language-nginx line-numbers">upstream ssl{
        server 127.0.0.1:9000 weight=1;
}

server {
    listen 80;
    location / {
        proxy_pass http://ssl;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Host $http_host;
        proxy_set_header X-NginX-Proxy true;
    }
}
</code></pre>

重启nginx，就可以访问到网站了

https从现在开始配置

首先配置好wordpress，然后到wordpress中下载一个插件<strong>Really Simple SSL</strong>

这时候点击启用，会提示没有证书，下一步就是将https配置到Nginx上

这里略过

配置好了之后，通过https访问刚才的页面的时候，就会有启用https，点击启用，就可以使用https访问了

<h2>附录</h2>

<h3>docker的一些命令</h3>

查看创建的数据卷

<pre><code class="language-bash line-numbers">docker volume ls
</code></pre>

删除所有没有用到的数据卷

<pre><code class="language-bash line-numbers">docker volume prune
</code></pre>

查看数据卷对应主机的位置

<pre><code class="language-bash line-numbers">docker volume inspect --format '{{ .Mountpoint }}' 数据卷名称
</code></pre>

停掉docker-compose，和up一样需要在docker-compose.yml目录执行

<pre><code class="language-bash line-numbers">docker-copose down
</code></pre>

列出现在的网络

<pre><code class="language-bash line-numbers">docker network ls
</code></pre>

查看容器的日志

<pre><code class="language-bash line-numbers">docker logs 容器id/名称
</code></pre>

<h3>docker版本</h3>

查看docker版本

<pre><code class="language-bash line-numbers">docker version
</code></pre>

本文使用的docker 版本为

<pre><code class="language-bash line-numbers">Client:
 Version:           18.09.3
 API version:       1.39
 Go version:        go1.10.8
 Git commit:        774a1f4
 Built:             Thu Feb 28 06:33:21 2019
 OS/Arch:           linux/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          18.09.3
  API version:      1.39 (minimum version 1.12)
  Go version:       go1.10.8
  Git commit:       774a1f4
  Built:            Thu Feb 28 06:02:24 2019
  OS/Arch:          linux/amd64
  Experimental:     false
</code></pre>

<h3>Nginx配置http端口跳转到https端口</h3>

方式一

<pre><code class="language-nginx line-numbers">server {
        listen      80;
        server_name 域名;
        rewrite /(.*) https://$host/$1 permanent;
}
</code></pre>

方式二

在方式一基础上将rewrite修改为

<pre><code class="language-nginx line-numbers">return      301 https://$server_name$request_uri;
</code></pre>

还有些其他方式，自行百度]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>404</wp:post_id>
		<wp:post_date><![CDATA[2019-04-08 09:38:52]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-08 01:38:52]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[wordpress-docker%e6%90%ad%e5%bb%ba-https%e5%8c%96%e8%ae%b0%e5%bd%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="docker"><![CDATA[docker]]></category>
		<category domain="post_tag" nicename="docker"><![CDATA[docker]]></category>
		<category domain="category" nicename="various"><![CDATA[杂]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				Let&#039;s Encrypt泛域名SSL证书配置		</title>
		<link>https://blog.easysc.cn/?p=408</link>
		<pubDate>Tue, 09 Apr 2019 01:53:35 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">https://blog.easysc.cn/?p=408</guid>
		<description></description>
		<content:encoded>
				<![CDATA[参考

<a href="https://www.laozuo.org/11668.html">Let's Encrypt泛域名SSL证书申请</a>

<a href="https://www.cnblogs.com/esofar/p/9291685.html">快速签发 Let's Encrypt 证书指南</a>

<a href="https://www.jianshu.com/p/dbe180979e77">acme.sh 配合 letsencrypt 配置泛域名</a>

<a href="https://github.com/Neilpang/acme.sh">acme.sh的GitHub</a>

<h2>安装</h2>

必备软件

<pre><code class="language-bash line-numbers">yum install -y curl socat cron
</code></pre>

安装acme.sh

<pre><code class="language-bash line-numbers">curl https://get.acme.sh | sh
</code></pre>

整个安装过程进行了以下几步，了解一下即可：

<ol>
<li>把 acme.sh 安装到当前用户的主目录<code>$HOME</code>下的<code>.acme.sh</code>文件夹中，即<code>~/.acme.sh/</code>，之后所有生成的证书也会放在这个目录下；</li>
<li>创建了一个指令别名<code>alias acme.sh=~/.acme.sh/acme.sh</code>，这样我们可以通过<code>acme.sh</code>命令方便快速地使用 acme.sh 脚本；</li>
<li>自动创建<code>cronjob</code>定时任务, 每天 0:00 点自动检测所有的证书，如果快过期了，则会自动更新证书。</li>
</ol>

安装命令执行完毕后，执行<code>acme.sh --version</code>确认是否能正常使用<code>acme.sh</code>命令。

<pre><code class="language-bash line-numbers">cd ~/.acme.sh/
./acme.sh --version
-------------------------------
https://github.com/Neilpang/acme.sh
v2.8.1
</code></pre>

更高级的安装选项请参考: <a href="https://github.com/Neilpang/acme.sh/wiki/How-to-install">https://github.com/Neilpang/acme.sh/wiki/How-to-install</a>

<h2>生成证书</h2>

<code>acme.sh</code> 支持直接使用主流 DNS 提供商的 API 接口来完成域名验证以及一些相关操作具体 <a href="https://github.com/Neilpang/acme.sh/tree/master/dnsapi">dnsapi 链接</a>

以阿里云为例：

首先获取你的阿里云API Key: <a href="https://ak-console.aliyun.com/#/accesskey">https://ak-console.aliyun.com/#/accesskey</a>

注：如果使用阿里RAM访问权限控制，需要授权<code>管理HTTPDNS的权限</code> <code>管理云解析(DNS)的权限</code>这两个权限

编辑acme.sh，加入

<pre><code class="line-numbers">export Ali_Key="自己的AccessKeyID"
export Ali_Secret="自己的AccessKeySecret"
</code></pre>

然后执行

<pre><code class="language-bash line-numbers">./acme.sh --issue -d 域名 -d *.域名 --dns dns_ali --log
</code></pre>

<code>--log</code>表示生成日志文件<code>acme.sh.log</code>，方便生成失败的时候查看原因

如果想自定义证书目录可以加上<code>-w</code>参数

<h2>Nginx配置SSL</h2>

Nginx支持SSL要先安装ssl模块<code>--with-http_ssl_module</code>

生成dhparam

<pre><code class="language-bash line-numbers">sudo mkdir /usr/local/nginx/ssl
sudo openssl dhparam -out /usr/local/nginx/ssl/dhparam.pem 2048
</code></pre>

生成会生成一段时间

<h3>安装证书</h3>

生成的证书是放在<code>~/acme.sh/域名</code>下的，这是<code>acme</code>内部目录，不应该让nginx直接读取，所以使用<code>--installcert</code>命令将证书文件放到其他位置

<pre><code class="language-bash line-numbers">./acme.sh  --installcert -d 域名 \
         --key-file /usr/local/nginx/ssl/域名.key \
         --fullchain-file /usr/local/nginx/ssl/fullchain.cer \
         --reloadcmd "service nginx force-reload"
------------或者--------------
./acme.sh --installcert -d 域名 -key-file /usr/local/nginx/ssl/域名.key --fullchain-file /usr/local/nginx/ssl/fullchain.cer --reloadcmd "server nginx force-reload"
</code></pre>

注：<code>--reloadcmd</code>可以不加，这个表示安装完成后执行的命令，但是最好是填上，基本每隔两个月就会执行一次，就需要重载或重启nginx证书才能及时的更新

<h3>配置Nginx</h3>

这里只展示了必要配置

<pre><code class="language-nginx line-numbers">    server {
        listen      80;
        server_name 域名;
        # 访问80端口重定向到https端口
        return 301 https://$host$request_uri;
    }

    server {
        listen       443 ssl http2;
        ssl on;
        server_name  域名;
        ssl_certificate /usr/local/nginx/ssl/fullchain.cer;
        ssl_certificate_key /usr/local/nginx/ssl/域名.key;
        ssl_dhparam /usr/local/nginx/ssl/dhparam.pem;
    }
</code></pre>

ssl的详细设置可以查看<a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html">Module ngx_http_ssl_module</a>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>408</wp:post_id>
		<wp:post_date><![CDATA[2019-04-09 09:53:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-09 01:53:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[lets-encrypt%e6%b3%9b%e5%9f%9f%e5%90%8dssl%e8%af%81%e4%b9%a6%e9%85%8d%e7%bd%ae]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="various"><![CDATA[杂]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_3ec471e97880c9b79a82bf9d37581f23]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				mysql存储过程		</title>
		<link>https://blog.easysc.cn/?p=422</link>
		<pubDate>Fri, 23 Aug 2019 07:09:15 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">https://blog.easysc.cn/?p=422</guid>
		<description></description>
		<content:encoded>
				<![CDATA[参考：

<a href="https://www.cnblogs.com/l5580/p/5993238.html">Mysql存储过程</a>

<a href="http://imysql.com/mysql-refman/5.7/sql-syntax.html#declare-handler">DECLARE ... HANDLER</a>

<h2>存储过程的创建</h2>

<pre><code class="language-mysql line-numbers">CREATE PROCEDURE 存储过程名()
</code></pre>

<h2>存储过程的删除</h2>

<pre><code class="language-mysql line-numbers">-- 删除存储过程后面不需要跟(),只给出存储过程名
DROP PROCEDURE productpricing;     
</code></pre>

<h3>删除时先判断是否存在</h3>

<pre><code class="language-mysql line-numbers">DROP PROCEDURE IF EXISTS productpricing
</code></pre>

<h2>Mysql命令行客户机的分隔符</h2>

默认的MySQL语句分隔符为分号;作为语句分隔符。如果命令行实用程序要解释存储过程自身的 ; 字符，则他们最终不会成为存储过程的成分，这会使存储过程中的SQL出现句法错误，解决方法是临时更改命令实用程序的语句分隔符，使用DELIMITER

<pre><code class="language-mysql line-numbers">-- 定义新的语句分隔符为//
DELIMITER //    

CREATE PROCEDURE productpricing()
-- 表示开始存储过程
BEGIN

SELECT Avg(prod_price) AS priceaverage

FROM products;
-- 表示存储过程结束
END //
-- 改回原来的语句分隔符为;
DELIMITER ;    
-- 除\符号外，任何字符都可以作为语句分隔符
</code></pre>

<h2>参数</h2>

<h3>入参</h3>

创建存储过程时指定

<pre><code class="language-mysql line-numbers">-- 每个参数都要指定类型
CREATE PROCEDURE productpricing(
    IN param1 VARCHAR(50),
    IN param2 Integer(11)
)
</code></pre>

<h3>出参（返回值）</h3>

<pre><code class="language-mysql line-numbers">-- 每个参数都要指定类型 DEFAULT用于指定默认值
CREATE PROCEDURE productpricing(
    IN param1 VARCHAR(50) DEFAULT "",
    IN param2 INT(11),
    OUT param3 DECIMAL(8,2)
    OUT param4 TIMESTAMP
)
</code></pre>

<h4>调用</h4>

<pre><code class="language-mysql line-numbers">-- 这里调用时指定了出参的变量，前面要加@
CALL productpricing("调用入参",11,@outParam1,@outParam2);
select @outParam1,@outParam2
</code></pre>

<h3>局部变量</h3>

<pre><code class="language-mysql line-numbers">-- 定义局部变量，局部变量声明要放在存储过程开始的地方
DECLARE x VARCHAR(11);
</code></pre>

<h3>查询赋值</h3>

<pre><code class="language-mysql line-numbers">DECLARE _roleId INT(11);
DECLARE _roleName VARCHAR(20);
-- 可以使用INTO将查询语句中的列结果赋值给变量
SELECT role_id,role_name
INTO _roleId,_roleName
FROM
sys_role
</code></pre>

<h3>设置变量的值</h3>

<pre><code class="language-mysql line-numbers">SET x = 5;
</code></pre>

<h2>流程控制语句</h2>

<h3>IF</h3>

<pre><code class="language-mysql line-numbers">-- IF
IF x = 5 THEN
SELECT * FROM sys_role;
-- ELSEIF
ELSEIF x = 6 THEN
SELECT id FROM sys_role;
-- ELSE 这里不用写THEN
ELSE
SELECT role_name FROM sys_role;
-- IF执行之后一定要END IF，这里有;
END IF;
</code></pre>

<h3>Case语句</h3>

<pre><code class="language-mysql line-numbers">CASE [case值]
WHEN [条件] THEN [执行的内容]
WHEN [条件] THEN [执行的内容] 
ELSE [执行的内容]
End CASE
</code></pre>

<h2>游标</h2>

游标（cursor）是一个存储在MYSQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。

<strong>使用游标</strong>

使用游标涉及几个明确的步骤：

<ol>
<li>在能够使用游标前，必须声明（定义）它，这个过程实际上没有检索数据，它只是定义要使用的SELECT语句</p></li>
<li><p>一旦声明后，必须打开游标以供使用。这个过程用钱吗定义的SELECT语句吧数据实际检索出来</p></li>
<li><p>对于填有数据的游标，根据需要取出（检索）的各行</p></li>
<li><p>在接受游标使用时，必须关闭它 <strong>如果不明确关闭游标，MySQL将会在到达END语句时自动关闭它</strong></p></li>
</ol>

<h3>创建游标</h3>

<p>游标可用DECLARE 语句创建。 DECLARE命名游标，并定义相应的SELECT语句。

<pre><code class="language-mysql line-numbers">DECLARE [游标名称] CURSOR FOR [查询语句];
-- 例子
DECLARE cur CURSOR FOR SELECT role_id FROM sys_role;
</code></pre>

<h3>打开和关闭游标</h3>

<pre><code class="language-mysql line-numbers">OPEN [游标名称];
-- CLOSE释放游标使用的所有内部内存和资源，因此，每个游标不需要时都应该关闭
CLOSE [游标名称];
</code></pre>

<h3>使用游标数据</h3>

在一个游标被打开后，可以使用FETCH语句分别访问它的每一行。FETCH指定检索什么数据（所需的要列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行从第一行到最后一行

<pre><code class="language-mysql line-numbers">-- 每次FETCH取的是一行的数据
FETCH cura INTO userId,roleId,roleName;
</code></pre>

<h3>循环</h3>

有几种循环游标的方式

<ul>
<li>WHILE [循环条件] DO [循环体] END WHILE</li>
<li>REPEAT [循环体] UNTIL [结束标志] END REPEAT;</li>
<li>loop名称:LOOP ...... END LOOP; 使用 LEAVE [loop名称] 可以 离开LOOP循环</li>
</ul>

定义循环结束的标志

<pre><code class="language-mysql line-numbers">DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET [变量]=TRUE;
-- 或者下面的也可以
DECLARE CONTINUE HANDLER FOR NOT FOUND SET [变量] = TRUE;
</code></pre>

关于MYSQL的DECLARE...HANDLER用法可以参考

<a href="http://imysql.com/mysql-refman/5.7/sql-syntax.html#declare-handler">DECLARE ... HANDLER</a>

<h2>比较完整的例子</h2>

<pre><code class="language-mysql line-numbers">-- 如果存在就删除
DROP PROCEDURE IF EXISTS testPro;
-- 定义分隔符
DELIMITER //
-- 创建存储过程
CREATE PROCEDURE testPro(
    IN inParam Int(11),
    OUT outParam VARCHAR(20)
)
BEGIN
    -- 定义局部变量
    DECLARE _roleName VARCHAR(20);
    DECLARE done BIT DEFAULT FALSE;
    DECLARE roleName VARCHAR(50);
    DECLARE roleId INT(11);
    DECLARE userId INT(11);
    -- 定义一个游标
    DECLARE cura CURSOR FOR SELECT id,role_id,role_name FROM sys_user;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=TRUE;
    -- 也可以这样写DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    -- 查询表
    SELECT role_name
    -- 将查询的结果赋值给_roleName
    INTO _roleName
    FROM sys_role WHERE role_id = inParam;
    -- 设置outParam的值
    IF _roleName = "ADMIN" THEN
        SET outParam = "管理员";
    ELSEIF _roleName = "EMPLOYEE" THEN
        SET outParam = "员工";
    ELSE
        SET outParam = "未知";
    END IF;
    -- 打开游标
    OPEN cura;
        -- 循环
        REPEAT
            FETCH cura INTO userId,roleId,roleName;
            IF roleId IS NOT NULL THEN
                UPDATE sys_user SET role_name = (SELECT role_name FROM sys_role WHERE role_id = roleId) WHERE id = userId;
            END IF;
        UNTIL done END REPEAT;
    CLOSE cura;
END //
DELIMITER ;
-- 调用
CALL testPro(2,@testOut);
SELECT @testOut;
</code></pre>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>422</wp:post_id>
		<wp:post_date><![CDATA[2019-08-23 15:09:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-23 07:09:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[mysql%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="mysql"><![CDATA[mysql]]></category>
		<category domain="post_tag" nicename="mysql"><![CDATA[mysql]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>
				使用docker搭建redis集群		</title>
		<link>https://blog.easysc.cn/?p=425</link>
		<pubDate>Thu, 12 Sep 2019 04:08:05 +0000</pubDate>
		<dc:creator><![CDATA[cononyc]]></dc:creator>
		<guid isPermaLink="false">https://blog.easysc.cn/?p=425</guid>
		<description></description>
		<content:encoded>
				<![CDATA[参考：

<a href="https://www.cnblogs.com/lianggp/p/8136222.html">docker redis4.0 集群（cluster）搭建</a>

<h2>创建redis容器</h2>

<h3>1.创建配置文件</h3>

要搭建集群的文件夹下创建redis-cluster.tmpl，内容为以下内容，根据需要更改我这里文件在<code>/root/redis-cluster</code>(后面会用到这个路径)下

<pre><code class="line-numbers">port ${PORT}
protected-mode no
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
cluster-announce-ip 39.10X.XX.XX //自己服务器IP
cluster-announce-port ${PORT}
cluster-announce-bus-port 1${PORT}
appendonly yes
</code></pre>

如果需要密码则加上配置

<pre><code class="line-numbers">masterauth 123456
requirepass 123456
</code></pre>

注：5.x以下版本不支持在创建集群的时候指定密码，所以要先创建好集群之后，再设置密码，5.x+版本支持在创建集群的时候指定参数<code>-a</code>来指定创建集群时候密码

<h3>2.docker创建集群的网络</h3>

<pre><code class="language-bash line-numbers">docker network create redis-net
</code></pre>

<h3>3.生成配置信息</h3>

<pre><code class="language-bash line-numbers">for port in `seq 7000 7005`; do \
  mkdir -p ./${port}/conf \
  &amp;&amp; PORT=${port} envsubst &lt; ./redis-cluster.tmpl &gt; ./${port}/conf/redis.conf \
  &amp;&amp; mkdir -p ./${port}/data; \
done
</code></pre>

执行之后会在当前目录下生成 7000-7005的文件夹，对应不同的端口，里面包含conf和data文件夹

<h3>4.创建redis容器</h3>

<pre><code class="language-bash line-numbers">for port in `seq 7000 7005`; do \
  docker run -d -ti -p ${port}:${port} -p 1${port}:1${port} \
  -v /root/redis-cluster/${port}/conf/redis.conf:/usr/local/etc/redis/redis.conf \
  -v /root/redis-cluster/${port}/data:/data \
  --restart always --name redis-${port} --net redis-net \
  redis:4.0 redis-server /usr/local/etc/redis/redis.conf; \
done
</code></pre>

这里会启动6个redis 打开端口7000-7005,17000-17005并映射到了主机，将端口文件夹中的配置文件挂载到容器中，端口文件夹中的data文件夹挂载到容器中的/data下并自动重启

注：这里使用的是redis的4.0版本

<h2>集群</h2>

<h3>3.x版本</h3>

redis在4.x+版本提供了对docker的友好支持，如果需要redis能够使用外网访问，最好使用redis4.x+版本。3.x版本使用docker的默认网络配置只能够创建内网能够访问的docker redis集群，如果需要外网能够访问可能要更改redis-net的网络模式为host，并使用<code>redis-trib.rb</code>来创建集群，这里没有做尝试。

<h3>4.x版本</h3>

使用ruby来指定redis的<code>redis-trib.rb</code>来创建集群

注：5.0的redis版本似乎不支持使用这种方式（5.0使用redis-cli来创建集群，使用5.0的话不需要使用ruby，用其中一个redis实例来执行redis-cli创建集群的命令即可），所以这里的<code>redis-trib.rb</code>文件需要使用5.0以下的版本，参考文章中的获取的<code>redis-trib.rb</code>是属于stable版本的，最新stable版本的似乎已经是5.0的了，所以这里需要去到redis5.0版本以下的源码中去获取该文件。

<h4>1.下载<code>redis-trib.rb</code></h4>

下载redis4.x的源码文件（自行下载，这里不赘述），解压，我这里解压到<code>/root/redis-4.0.12</code>这个文件夹下的

<h4>2.使用ruby + redis-trib.rb 创建集群</h4>

<pre><code class="language-bash line-numbers">echo yes | docker run -i --rm -v /root/redis-4.0.12/src/redis-trib.rb:/redis-trib.rb --net redis-net ruby sh -c '\
  gem install redis -v 4.0 \
  &amp;&amp; ruby redis-trib.rb create --replicas 1 \
  '"$(for port in `seq 7000 7005`; do \
    echo -n "$(docker inspect --format '{{ (index .NetworkSettings.Networks "redis-net").IPAddress }}' "redis-${port}")":${port} ' ' ; \
  done)"
</code></pre>

这里就是将<code>/root/redis-4.0.12/src/redis-trib.rb</code>该文件挂载到容器的<code>/redis-trib.rb</code>这个目录下，然后使用ruby来执行该文件创建集群

<h3>5.x版本</h3>

5.x使用redis-cli来创建集群，所以这里不需要去挂载<code>redis-trib.rb</code>,单独启动一个5.x的redis实例，指定redis-cli创建集群的命令就可以了

<pre><code class="language-bash line-numbers">echo yes | docker run -i --rm -p 6379 --net redis-net redis:5.0 \
   redis-cli --cluster create \
   $(for port in `seq 7000 7005`; do \
     echo -n "$(docker inspect --format '{{ (index .NetworkSettings.Networks "redis-net").IPAddress }}' "redis-${port}")":${port} ' ' ; \
     done) $(echo "--cluster-replicas 1")
</code></pre>

如果使用了密码加上配置（5.x+版本支持，在配置文件中加<code>masterauth</code> <code>requirepass</code>属性）

<pre><code class="line-numbers">-a 123456
</code></pre>

即

<pre><code class="language-bash line-numbers">echo yes | docker run -i --rm -p 6379 --net redis-net redis:5.0 \
   redis-cli --cluster create \
   $(for port in `seq 7000 7005`; do \
     echo -n "$(docker inspect --format '{{ (index .NetworkSettings.Networks "redis-net").IPAddress }}' "redis-${port}")":${port} ' ' ; \
     done) $(echo "--cluster-replicas 1 -a 123456")
</code></pre>

注：

<ol>
<li>操作环境为cento7</li>
<li>注意各种路径</p></li>
<li><p>执行之前要保证之前填的自己的IP的服务器的端口7000-7005,17000-17005端口是打开的，云服务器端口也要打开（如果需要外网连接的话），要不有可能一直卡在

<pre><code class="line-numbers">Waiting for the cluster to join...
</code></pre></li>
</ol>]]>		</content:encoded>
		<excerpt:encoded>
				<![CDATA[]]>		</excerpt:encoded>
		<wp:post_id>425</wp:post_id>
		<wp:post_date><![CDATA[2019-09-12 12:08:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-09-12 04:08:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bd%bf%e7%94%a8docker%e6%90%ad%e5%bb%baredis%e9%9b%86%e7%be%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="docker"><![CDATA[docker]]></category>
		<category domain="post_tag" nicename="docker"><![CDATA[docker]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
				</channel>
</rss>
	